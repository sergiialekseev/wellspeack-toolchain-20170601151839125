{"version":3,"sources":["webpack:///js/app.bundle.js","webpack:///webpack/bootstrap 91fa6240a5e12b29c466","webpack:///./src/client/app/app.js","webpack:///./src/client/assets/media/images/favicon.png","webpack:///./src/client/assets/media/images/logo-fb.png","webpack:///./~/diff-match-patch/index.js","webpack:///./src/client/app/common/directives/suggestions/suggestions.directive.js","webpack:///./src/client/app/configs/text.config.js","webpack:///./src/client/app/common/directives/suggestions/suggestions-form.tpl.jade","webpack:///./src/client/app/modules/index.js","webpack:///./src/client/app/modules/speech/index.js","webpack:///./src/client/app/modules/speech/templates/index.js","webpack:///./src/client/assets/media/images/logo.png","webpack:///./src/client/app/modules/speech/templates/speech.tpl.jade","webpack:///./src/client/app/modules/speech/templates/speech.src.tpl.jade","webpack:///./src/client/app/modules/speech/templates/speech.src.random.tpl.jade","webpack:///./src/client/app/modules/speech/templates/speech.src.custom.tpl.jade","webpack:///./src/client/app/modules/speech/speech.route.js","webpack:///./src/client/app/modules/header.tpl.jade","webpack:///./src/client/app/modules/sidebar.tpl.jade","webpack:///./src/client/app/modules/speech/speech.controller.js","webpack:///./~/watson-speech/index.js","webpack:///./~/process/browser.js","webpack:///./~/watson-speech/speech-to-text/index.js","webpack:///./~/buffer/index.js","webpack:///./~/watson-speech/speech-to-text/recognize-microphone.js","webpack:///./~/get-user-media-promise/lib/get-user-media-promise.js","webpack:///./~/microphone-stream/microphone-stream.js","webpack:///./~/stream-browserify/index.js","webpack:///./~/events/events.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/readable-stream/readable.js","webpack:///./~/readable-stream/lib/_stream_readable.js","webpack:///./~/process-nextick-args/index.js","webpack:///./~/buffer-shims/index.js","webpack:///./~/core-util-is/lib/util.js","webpack:///./~/readable-stream/lib/_stream_duplex.js","webpack:///./~/readable-stream/lib/_stream_writable.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/util-deprecate/browser.js","webpack:///./~/string_decoder/index.js","webpack:///./~/readable-stream/lib/_stream_transform.js","webpack:///./~/readable-stream/lib/_stream_passthrough.js","webpack:///./~/readable-stream/writable.js","webpack:///./~/readable-stream/duplex.js","webpack:///./~/readable-stream/transform.js","webpack:///./~/readable-stream/passthrough.js","webpack:///./~/util/util.js","webpack:///./~/util/support/isBufferBrowser.js","webpack:///./~/watson-speech/speech-to-text/recognize-stream.js","webpack:///./~/object.pick/index.js","webpack:///./~/isobject/index.js","webpack:///./src/client/app/modules/header.controller.js"],"names":["app","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_app","_app2","_common","_common2","_modules","_modules2","angular","config","name","element","document","ready","bootstrap","d","w","push","yaCounter23830300","Ya","Metrika","clickmap","trackLinks","accurateTrackBounce","webvisor","trackHash","e","n","getElementsByTagName","s","createElement","f","parentNode","insertBefore","type","async","src","opera","addEventListener","window","i","o","g","r","a","q","arguments","l","Date","ga","patchesCopy","diff_match_patch","prototype","patch_apply","patches","text","length","this","patch_deepCopy","nullPadding","patch_addPadding","patch_splitMax","delta","results","x","start_loc","expected_loc","start2","text1","diff_text1","diffs","end_loc","Match_MaxBits","match_main","substring","length2","length1","text2","diff_text2","diff_main","diff_levenshtein","Patch_DeleteThreshold","diff_cleanupSemanticLossless","index2","index1","y","mod","DIFF_EQUAL","diff_xIndex","DIFF_INSERT","DIFF_DELETE","paddingLength","Patch_Margin","String","fromCharCode","start1","patch","unshift","extraLength","patch_size","bigpatch","splice","precontext","patch_obj","empty","diff_type","diff_text","shift","postcontext","patch_toText","join","patch_fromText","textline","split","textPointer","patchHeader","match","Error","parseInt","sign","charAt","line","decodeURI","ex","toString","coords1","coords2","op","encodeURI","replace","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_text","_text2","SuggestionsDirective","restrict","templateUrl","controller","Restangular","$filter","_this","open","alert","show","success","suggestion","userId","createdOn","toggleForm","sentSuggestion","all","post","then","result","closeMessage","controllerAs","bindToController","wellspeakText","title","source","random","custom","placeholder","selectPlaceholder","example","recognizing","wait","turnOn","speakNow","pronounciation","clickHere","missed","wrong","sidebar","myProfile","myStat","settings","support","helperLayout","switcher","pronunciation","check","panel","volume","mic","appDisabled","mainText","link","download","suggestionsForm","leaveComent","button","phrase","successMessage","errorMessage","_speech","_speech2","_header","_header2","_speech3","_speech4","_speech5","_speech6","factory","$stateProvider","state","url","views","","header@speech","source@speech","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","SpeachModuleController","$scope","SpeachFactory","helper","explanation","WatsonSpeech","loadingResults","phrases","activePhraseIndex","listening","hasResults","userResult","userResultDiffs","speechDefined","audio","TextToSpeech","synthesize","userSource","token","tokenTTS","$apply","selectedRule","rules","changeRule","cleanResults","getNewPhrase","ctrl","Id","data","SpeechToText","recognizeMicrophone","tokenSTT","continuous","keepMicrophone","navigator","userAgent","indexOf","promise","setResult","bind","console","log","percentage","get","ruleTypes","_this2","_","find","rulesExamples","RuleId","ShortExample","isActiveSource","Phrase","userSentence","process","version","env","TRAVIS_BRANCH","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","cachedSetTimeout","len","run","cachedClearTimeout","Item","fun","array","noop","setTimeout","clearTimeout","nextTick","args","Array","apply","browser","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","Buffer","recognizeFile","getModels","WebAudioL16Stream","RecognizeStream","FilePlayer","FormatStream","TimingStream","WritableElementStream","getUserMedia","MicrophoneStream","global","callback","objectMode","decodeStrings","options","outputElement","format","smart_formatting","rsOpts","assign","readableObjectMode","getMicStream","recognizeStream","keepMic","preservedMicStream","unpipe","bitBucket","Promise","resolve","video","micStream","bufferSize","stream","pipe","stop","err","end","l16Stream","L16","writableObjectMode","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","NotSupportedError","message","FakePromise","cb","constraints","mediaDevices","reject","gum","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","undefined","opts","recorderProcess","recording","self","inputBuffer","getChannelData","AudioContext","inputChannels","outputChannels","Readable","webkitAudioContext","context","audioInput","createMediaStreamSource","recorder","createScriptProcessor","onaudioprocess","connect","destination","getTracks","disconnect","close","channels","bitDepth","sampleRate","signed","float","util","inherits","_read","toRaw","chunk","Float32Array","buffer","Stream","EE","EventEmitter","Writable","Duplex","Transform","PassThrough","dest","ondata","write","pause","ondrain","readable","resume","onend","didOnEnd","onclose","destroy","onerror","er","cleanup","listenerCount","_isStdio","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","handler","listeners","error","slice","listener","newListener","warned","trace","fired","list","position","ret","evlistener","emitter","create","ctor","superCtor","super_","constructor","TempCtor","READABLE_STREAM","prependListener","event","fn","hasPrependListener","isArray","ReadableState","hwm","highWaterMark","defaultHwm","pipes","pipesCount","flowing","ended","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","defaultEncoding","ranOut","awaitDrain","readingMore","decoder","encoding","StringDecoder","_readableState","read","readableAddChunk","addToFront","chunkInvalid","onEofChunk","_e","skipAdd","emitReadable","maybeReadMore","needMoreData","computeNewHighWaterMark","MAX_HWM","howMuchToRead","isBuffer","debug","processNextTick","emitReadable_","flow","maybeReadMore_","pipeOnDrain","EElistenerCount","nReadingNextTick","resume_","fromList","stringMode","buf","bufferShim","allocUnsafe","_buf","cpy","Math","min","copy","endReadable","endReadableNT","forEach","xs","debugUtil","debuglog","from","isPaused","setEncoding","enc","nOrig","doRead","pipeOpts","onunpipe","onfinish","cleanedUp","_writableState","needDrain","doEnd","stdout","stderr","endFn","dests","_i","ev","res","wrap","paused","method","events","_fromList","arg1","arg2","arg3","SlowBuffer","MAX_LEN","kMaxLength","alloc","size","fill","RangeError","_fill","fillBuf","flen","encodingOrOffset","Uint8Array","ArrayBuffer","offset","byteLength","out","allocUnsafeSlow","objectToString","isBoolean","isNull","isNullOrUndefined","isString","isSymbol","isRegExp","re","isDate","isError","isPrimitive","allowHalfOpen","onEndNT","objectKeys","keys","v","setImmediate","nop","WriteReq","next","WritableState","ending","finished","noDecode","writing","corked","bufferProcessing","onwrite","writecb","writelen","bufferedRequest","lastBufferedRequest","pendingcb","prefinished","errorEmitted","bufferedRequestCount","corkedRequestsFree","CorkedRequest","_write","writev","_writev","writeAfterEnd","validChunk","valid","decodeChunk","writeOrBuffer","last","doWrite","onwriteError","onwriteStateUpdate","needFinish","clearBuffer","asyncWrite","afterWrite","onwriteDrain","finishMaybe","entry","holder","count","finish","prefinish","need","endWritable","internalUtil","deprecate","getBuffer","current","cork","uncork","setDefaultEncoding","toLowerCase","clearImmediate","Timeout","clearFn","_id","_clearFn","Function","immediateIds","nextImmediateId","setInterval","clearInterval","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","msg","deprecated","warn","localStorage","val","assertEncoding","isBufferEncoding","passThroughWrite","utf16DetectIncompleteChar","charReceived","charLength","base64DetectIncompleteChar","isEncoding","surrogateSize","detectIncompleteChar","charBuffer","charStr","available","charCode","charCodeAt","cr","TransformState","afterTransform","needTransform","transforming","writechunk","writeencoding","ts","_transformState","rs","transform","_transform","flush","_flush","done","ws","inspect","ctx","seen","stylize","stylizeNoColor","depth","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","str","styleType","style","styles","arrayToHash","hash","idx","recurseTimes","primitive","formatPrimitive","visibleKeys","getOwnPropertyNames","formatError","RegExp","base","braces","toUTCString","output","formatArray","map","formatProperty","pop","reduceToSingleString","simple","JSON","stringify","hasOwnProperty","desc","getOwnPropertyDescriptor","set","substr","numLinesEst","reduce","prev","cur","ar","pad","timestamp","time","getHours","getMinutes","getSeconds","getDate","months","getMonth","prop","formatRegExp","objects","Number","throwDeprecation","traceDeprecation","noDeprecation","debugEnviron","debugs","NODE_DEBUG","toUpperCase","test","pid","bold","italic","underline","inverse","white","grey","black","blue","cyan","green","magenta","red","yellow","special","number","boolean","null","string","date","regexp","origin","add","readUInt8","flowForResults","silent","initialized","pick","W3CWebSocket","w3cwebsocket","contentType","defaults","qs","OPENING_MESSAGE_PARAMS_ALLOWED","QUERY_PARAMS_ALLOWED","initialize","emitError","frame","raw","content_type","queryParams","model","queryString","textModeDefaults","action","content-type","inactivity_timeout","interim_results","word_confidence","timestamps","max_alternatives","objectModeDefaults","openingMessage","socket","headers","onopen","sendJSON","code","reason","onmessage","parse","jsonEx","index","result_index","alternatives","transcript","send","sendData","afterSend","getContentType","bufferedAmount","closingMessage","readyState","CLOSED","CLOSING","NavbarController"],"mappings":"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","file":"js/app.bundle.js","sourcesContent":["var app =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\tvar _app = __webpack_require__(3);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\tvar _common = __webpack_require__(5);\n\t\n\tvar _common2 = _interopRequireDefault(_common);\n\t\n\tvar _modules = __webpack_require__(12);\n\t\n\tvar _modules2 = _interopRequireDefault(_modules);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar app = angular.module('app', ['ui.router', 'ngAnimate', 'restangular', _common2.default, _modules2.default]).config(_app2.default).name;\n\t\n\tangular.element(document).ready(function () {\n\t    angular.bootstrap(document, [app]);\n\t});\n\t\n\t(function (d, w, c) {\n\t    (w[c] = w[c] || []).push(function () {\n\t        try {\n\t            w.yaCounter23830300 = new Ya.Metrika({\n\t                id: 23830300,\n\t                clickmap: true,\n\t                trackLinks: true,\n\t                accurateTrackBounce: true,\n\t                webvisor: true,\n\t                trackHash: true\n\t            });\n\t        } catch (e) {}\n\t    });\n\t\n\t    var n = d.getElementsByTagName(\"script\")[0],\n\t        s = d.createElement(\"script\"),\n\t        f = function f() {\n\t        n.parentNode.insertBefore(s, n);\n\t    };\n\t    s.type = \"text/javascript\";\n\t    s.async = true;\n\t    s.src = \"https://mc.yandex.ru/metrika/watch.js\";\n\t\n\t    if (w.opera == \"[object Opera]\") {\n\t        d.addEventListener(\"DOMContentLoaded\", f, false);\n\t    } else {\n\t        f();\n\t    }\n\t})(document, window, \"yandex_metrika_callbacks\");\n\t\n\t(function (i, s, o, g, r, a, m) {\n\t    i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {\n\t        (i[r].q = i[r].q || []).push(arguments);\n\t    }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);\n\t})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\n\t\n\tga('create', 'UA-47736010-1', 'auto');\n\tga('send', 'pageview');\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/png/favicon.png\";\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/png/logo-fb.png\";\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = config;\n\t\n\tvar _main = __webpack_require__(4);\n\t\n\tvar _main2 = _interopRequireDefault(_main);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction config($urlRouterProvider, RestangularProvider) {\n\t    'ngInject';\n\t\n\t    $urlRouterProvider.otherwise('/');\n\t\n\t    RestangularProvider.setBaseUrl(_main2.default.apiUrl);\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar mainConfig = {};\n\t\n\tmainConfig.apiUrl =  false ? 'http://localhost:9000/api/' : '/api/';\n\t\n\tmainConfig.states = {\n\t    app: {\n\t        url: '/',\n\t        abstractState: 'app',\n\t        modules: {\n\t            speech: {\n\t                url: '/',\n\t                state: 'app.speech'\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\texports.default = mainConfig;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _directives = __webpack_require__(6);\n\t\n\tvar _directives2 = _interopRequireDefault(_directives);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.common', [_directives2.default]).name;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _diffMatchPatchDirective = __webpack_require__(7);\n\t\n\tvar _diffMatchPatchDirective2 = _interopRequireDefault(_diffMatchPatchDirective);\n\t\n\tvar _suggestionsDirective = __webpack_require__(9);\n\t\n\tvar _suggestionsDirective2 = _interopRequireDefault(_suggestionsDirective);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('app.directives', []).directive('diffMatchPatch', _diffMatchPatchDirective2.default).directive('suggestionsForm', _suggestionsDirective2.default).name;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DiffMatchPatchDirective =\n\t/* @ngInject */\n\tfunction DiffMatchPatchDirective() {\n\t    _classCallCheck(this, DiffMatchPatchDirective);\n\t\n\t    this.restrict = 'E';\n\t    this.replace = true;\n\t    this.scope = {\n\t        source: '=sourceObj',\n\t        result: '=resultObj',\n\t        diffs: '=diffsObj'\n\t    };\n\t    this.template = '<div class=\"result-text\" ng-bind-html=\"val\"></div>';\n\t    this.controller = function ($scope, $element, $attrs, $sce) {\n\t        'ngInject';\n\t\n\t        var DiffMatchPatch = __webpack_require__(8);\n\t        var dmp = new DiffMatchPatch();\n\t        var source = $scope.source.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()?]/g, \"\").trim();\n\t        var result = $scope.result.replace(/[.,\\/#!$%\\^&\\*;:{}=\\-_`~()?]/g, \"\").trim();\n\t        dmp.diff_prettyHtml = function (diffs) {\n\t            var html = [];\n\t            var pattern_amp = /&/g;\n\t            var pattern_lt = /</g;\n\t            var pattern_gt = />/g;\n\t            var pattern_para = /\\n/g;\n\t            var DIFF_DELETE = -1;\n\t            var DIFF_INSERT = 1;\n\t            var DIFF_EQUAL = 0;\n\t            var equal = '';\n\t            $scope.diffs = {\n\t                insert: 0,\n\t                delete: 0,\n\t                percentage: 0\n\t            };\n\t            for (var x = 0; x < diffs.length; x++) {\n\t                var op = diffs[x][0]; // Operation (insert, delete, equal)\n\t                var data = diffs[x][1]; // Text of change.\n\t                var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;').replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n\t                switch (op) {\n\t                    case DIFF_INSERT:\n\t                        html[x] = '<ins>' + text + '</ins>';\n\t                        $scope.diffs.insert = $scope.diffs.insert + text.length;\n\t                        break;\n\t                    case DIFF_DELETE:\n\t                        html[x] = '<del>' + text + '</del>';\n\t                        $scope.diffs.delete = $scope.diffs.delete + text.length;\n\t                        break;\n\t                    case DIFF_EQUAL:\n\t                        html[x] = '<span>' + text + '</span>';\n\t                        equal += text;\n\t                        break;\n\t                }\n\t            }\n\t            $scope.diffs.percentage = Math.round(equal.length / source.length * 100);\n\t            return html.join('');\n\t        };\n\t\n\t        var comparisonResult = dmp.diff_main(result.toLowerCase(), source.toLowerCase());\n\t        dmp.diff_cleanupSemantic(comparisonResult);\n\t        dmp.diff_cleanupEfficiency(comparisonResult);\n\t        $scope.val = $sce.trustAsHtml(dmp.diff_prettyHtml(comparisonResult));\n\t    };\n\t};\n\t\n\texports.default = function () {\n\t    return new DiffMatchPatchDirective();\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict'\r\n\t\r\n\t/**\r\n\t * Diff Match and Patch\r\n\t *\r\n\t * Copyright 2006 Google Inc.\r\n\t * http://code.google.com/p/google-diff-match-patch/\r\n\t *\r\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n\t * you may not use this file except in compliance with the License.\r\n\t * You may obtain a copy of the License at\r\n\t *\r\n\t *   http://www.apache.org/licenses/LICENSE-2.0\r\n\t *\r\n\t * Unless required by applicable law or agreed to in writing, software\r\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\t * See the License for the specific language governing permissions and\r\n\t * limitations under the License.\r\n\t */\r\n\t\r\n\t/**\r\n\t * @fileoverview Computes the difference between two texts to create a patch.\r\n\t * Applies the patch onto another text, allowing for errors.\r\n\t * @author fraser@google.com (Neil Fraser)\r\n\t */\r\n\t\r\n\t/**\r\n\t * Class containing the diff, match and patch methods.\r\n\t * @constructor\r\n\t */\r\n\tfunction diff_match_patch() {\r\n\t\r\n\t  // Defaults.\r\n\t  // Redefine these in your program to override the defaults.\r\n\t\r\n\t  // Number of seconds to map a diff before giving up (0 for infinity).\r\n\t  this.Diff_Timeout = 1.0;\r\n\t  // Cost of an empty edit operation in terms of edit characters.\r\n\t  this.Diff_EditCost = 4;\r\n\t  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n\t  this.Match_Threshold = 0.5;\r\n\t  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n\t  // A match this many characters away from the expected location will add\r\n\t  // 1.0 to the score (0.0 is a perfect match).\r\n\t  this.Match_Distance = 1000;\r\n\t  // When deleting a large block of text (over ~64 characters), how close do\r\n\t  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n\t  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n\t  // end points of a delete need to match.\r\n\t  this.Patch_DeleteThreshold = 0.5;\r\n\t  // Chunk size for context length.\r\n\t  this.Patch_Margin = 4;\r\n\t\r\n\t  // The number of bits in an int.\r\n\t  this.Match_MaxBits = 32;\r\n\t}\r\n\t\r\n\t\r\n\t//  DIFF FUNCTIONS\r\n\t\r\n\t\r\n\t/**\r\n\t * The data structure representing a diff is an array of tuples:\r\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n\t */\r\n\tvar DIFF_DELETE = -1;\r\n\tvar DIFF_INSERT = 1;\r\n\tvar DIFF_EQUAL = 0;\r\n\t\r\n\t/** @typedef {{0: number, 1: string}} */\r\n\tdiff_match_patch.Diff;\r\n\t\r\n\t\r\n\t/**\r\n\t * Find the differences between two texts.  Simplifies the problem by stripping\r\n\t * any common prefix or suffix off the texts before diffing.\r\n\t * @param {string} text1 Old string to be diffed.\r\n\t * @param {string} text2 New string to be diffed.\r\n\t * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n\t *     then don't run a line-level diff first to identify the changed areas.\r\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\r\n\t * @param {number} opt_deadline Optional time when the diff should be complete\r\n\t *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n\t *     instead.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n\t    opt_deadline) {\r\n\t  // Set a deadline by which time the diff must be complete.\r\n\t  if (typeof opt_deadline == 'undefined') {\r\n\t    if (this.Diff_Timeout <= 0) {\r\n\t      opt_deadline = Number.MAX_VALUE;\r\n\t    } else {\r\n\t      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n\t    }\r\n\t  }\r\n\t  var deadline = opt_deadline;\r\n\t\r\n\t  // Check for null inputs.\r\n\t  if (text1 == null || text2 == null) {\r\n\t    throw new Error('Null input. (diff_main)');\r\n\t  }\r\n\t\r\n\t  // Check for equality (speedup).\r\n\t  if (text1 == text2) {\r\n\t    if (text1) {\r\n\t      return [[DIFF_EQUAL, text1]];\r\n\t    }\r\n\t    return [];\r\n\t  }\r\n\t\r\n\t  if (typeof opt_checklines == 'undefined') {\r\n\t    opt_checklines = true;\r\n\t  }\r\n\t  var checklines = opt_checklines;\r\n\t\r\n\t  // Trim off common prefix (speedup).\r\n\t  var commonlength = this.diff_commonPrefix(text1, text2);\r\n\t  var commonprefix = text1.substring(0, commonlength);\r\n\t  text1 = text1.substring(commonlength);\r\n\t  text2 = text2.substring(commonlength);\r\n\t\r\n\t  // Trim off common suffix (speedup).\r\n\t  commonlength = this.diff_commonSuffix(text1, text2);\r\n\t  var commonsuffix = text1.substring(text1.length - commonlength);\r\n\t  text1 = text1.substring(0, text1.length - commonlength);\r\n\t  text2 = text2.substring(0, text2.length - commonlength);\r\n\t\r\n\t  // Compute the diff on the middle block.\r\n\t  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\t\r\n\t  // Restore the prefix and suffix.\r\n\t  if (commonprefix) {\r\n\t    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n\t  }\r\n\t  if (commonsuffix) {\r\n\t    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n\t  }\r\n\t  this.diff_cleanupMerge(diffs);\r\n\t  return diffs;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Find the differences between two texts.  Assumes that the texts do not\r\n\t * have any common prefix or suffix.\r\n\t * @param {string} text1 Old string to be diffed.\r\n\t * @param {string} text2 New string to be diffed.\r\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n\t *     line-level diff first to identify the changed areas.\r\n\t *     If true, then run a faster, slightly less optimal diff.\r\n\t * @param {number} deadline Time when the diff should be complete by.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n\t    deadline) {\r\n\t  var diffs;\r\n\t\r\n\t  if (!text1) {\r\n\t    // Just add some text (speedup).\r\n\t    return [[DIFF_INSERT, text2]];\r\n\t  }\r\n\t\r\n\t  if (!text2) {\r\n\t    // Just delete some text (speedup).\r\n\t    return [[DIFF_DELETE, text1]];\r\n\t  }\r\n\t\r\n\t  var longtext = text1.length > text2.length ? text1 : text2;\r\n\t  var shorttext = text1.length > text2.length ? text2 : text1;\r\n\t  var i = longtext.indexOf(shorttext);\r\n\t  if (i != -1) {\r\n\t    // Shorter text is inside the longer text (speedup).\r\n\t    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n\t             [DIFF_EQUAL, shorttext],\r\n\t             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n\t    // Swap insertions for deletions if diff is reversed.\r\n\t    if (text1.length > text2.length) {\r\n\t      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n\t    }\r\n\t    return diffs;\r\n\t  }\r\n\t\r\n\t  if (shorttext.length == 1) {\r\n\t    // Single character string.\r\n\t    // After the previous speedup, the character can't be an equality.\r\n\t    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n\t  }\r\n\t\r\n\t  // Check to see if the problem can be split in two.\r\n\t  var hm = this.diff_halfMatch_(text1, text2);\r\n\t  if (hm) {\r\n\t    // A half-match was found, sort out the return data.\r\n\t    var text1_a = hm[0];\r\n\t    var text1_b = hm[1];\r\n\t    var text2_a = hm[2];\r\n\t    var text2_b = hm[3];\r\n\t    var mid_common = hm[4];\r\n\t    // Send both pairs off for separate processing.\r\n\t    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n\t    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n\t    // Merge the results.\r\n\t    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n\t  }\r\n\t\r\n\t  if (checklines && text1.length > 100 && text2.length > 100) {\r\n\t    return this.diff_lineMode_(text1, text2, deadline);\r\n\t  }\r\n\t\r\n\t  return this.diff_bisect_(text1, text2, deadline);\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Do a quick line-level diff on both strings, then rediff the parts for\r\n\t * greater accuracy.\r\n\t * This speedup can produce non-minimal diffs.\r\n\t * @param {string} text1 Old string to be diffed.\r\n\t * @param {string} text2 New string to be diffed.\r\n\t * @param {number} deadline Time when the diff should be complete by.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n\t  // Scan the text on a line-by-line basis first.\r\n\t  var a = this.diff_linesToChars_(text1, text2);\r\n\t  text1 = a.chars1;\r\n\t  text2 = a.chars2;\r\n\t  var linearray = a.lineArray;\r\n\t\r\n\t  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\t\r\n\t  // Convert the diff back to original text.\r\n\t  this.diff_charsToLines_(diffs, linearray);\r\n\t  // Eliminate freak matches (e.g. blank lines)\r\n\t  this.diff_cleanupSemantic(diffs);\r\n\t\r\n\t  // Rediff any replacement blocks, this time character-by-character.\r\n\t  // Add a dummy entry at the end.\r\n\t  diffs.push([DIFF_EQUAL, '']);\r\n\t  var pointer = 0;\r\n\t  var count_delete = 0;\r\n\t  var count_insert = 0;\r\n\t  var text_delete = '';\r\n\t  var text_insert = '';\r\n\t  while (pointer < diffs.length) {\r\n\t    switch (diffs[pointer][0]) {\r\n\t      case DIFF_INSERT:\r\n\t        count_insert++;\r\n\t        text_insert += diffs[pointer][1];\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        count_delete++;\r\n\t        text_delete += diffs[pointer][1];\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        // Upon reaching an equality, check for prior redundancies.\r\n\t        if (count_delete >= 1 && count_insert >= 1) {\r\n\t          // Delete the offending records and add the merged ones.\r\n\t          diffs.splice(pointer - count_delete - count_insert,\r\n\t                       count_delete + count_insert);\r\n\t          pointer = pointer - count_delete - count_insert;\r\n\t          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n\t          for (var j = a.length - 1; j >= 0; j--) {\r\n\t            diffs.splice(pointer, 0, a[j]);\r\n\t          }\r\n\t          pointer = pointer + a.length;\r\n\t        }\r\n\t        count_insert = 0;\r\n\t        count_delete = 0;\r\n\t        text_delete = '';\r\n\t        text_insert = '';\r\n\t        break;\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t  diffs.pop();  // Remove the dummy entry at the end.\r\n\t\r\n\t  return diffs;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Find the 'middle snake' of a diff, split the problem in two\r\n\t * and return the recursively constructed diff.\r\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n\t * @param {string} text1 Old string to be diffed.\r\n\t * @param {string} text2 New string to be diffed.\r\n\t * @param {number} deadline Time at which to bail if not yet complete.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n\t  // Cache the text lengths to prevent multiple calls.\r\n\t  var text1_length = text1.length;\r\n\t  var text2_length = text2.length;\r\n\t  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n\t  var v_offset = max_d;\r\n\t  var v_length = 2 * max_d;\r\n\t  var v1 = new Array(v_length);\r\n\t  var v2 = new Array(v_length);\r\n\t  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n\t  // integers and undefined.\r\n\t  for (var x = 0; x < v_length; x++) {\r\n\t    v1[x] = -1;\r\n\t    v2[x] = -1;\r\n\t  }\r\n\t  v1[v_offset + 1] = 0;\r\n\t  v2[v_offset + 1] = 0;\r\n\t  var delta = text1_length - text2_length;\r\n\t  // If the total number of characters is odd, then the front path will collide\r\n\t  // with the reverse path.\r\n\t  var front = (delta % 2 != 0);\r\n\t  // Offsets for start and end of k loop.\r\n\t  // Prevents mapping of space beyond the grid.\r\n\t  var k1start = 0;\r\n\t  var k1end = 0;\r\n\t  var k2start = 0;\r\n\t  var k2end = 0;\r\n\t  for (var d = 0; d < max_d; d++) {\r\n\t    // Bail out if deadline is reached.\r\n\t    if ((new Date()).getTime() > deadline) {\r\n\t      break;\r\n\t    }\r\n\t\r\n\t    // Walk the front path one step.\r\n\t    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n\t      var k1_offset = v_offset + k1;\r\n\t      var x1;\r\n\t      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n\t        x1 = v1[k1_offset + 1];\r\n\t      } else {\r\n\t        x1 = v1[k1_offset - 1] + 1;\r\n\t      }\r\n\t      var y1 = x1 - k1;\r\n\t      while (x1 < text1_length && y1 < text2_length &&\r\n\t             text1.charAt(x1) == text2.charAt(y1)) {\r\n\t        x1++;\r\n\t        y1++;\r\n\t      }\r\n\t      v1[k1_offset] = x1;\r\n\t      if (x1 > text1_length) {\r\n\t        // Ran off the right of the graph.\r\n\t        k1end += 2;\r\n\t      } else if (y1 > text2_length) {\r\n\t        // Ran off the bottom of the graph.\r\n\t        k1start += 2;\r\n\t      } else if (front) {\r\n\t        var k2_offset = v_offset + delta - k1;\r\n\t        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n\t          // Mirror x2 onto top-left coordinate system.\r\n\t          var x2 = text1_length - v2[k2_offset];\r\n\t          if (x1 >= x2) {\r\n\t            // Overlap detected.\r\n\t            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    // Walk the reverse path one step.\r\n\t    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n\t      var k2_offset = v_offset + k2;\r\n\t      var x2;\r\n\t      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n\t        x2 = v2[k2_offset + 1];\r\n\t      } else {\r\n\t        x2 = v2[k2_offset - 1] + 1;\r\n\t      }\r\n\t      var y2 = x2 - k2;\r\n\t      while (x2 < text1_length && y2 < text2_length &&\r\n\t             text1.charAt(text1_length - x2 - 1) ==\r\n\t             text2.charAt(text2_length - y2 - 1)) {\r\n\t        x2++;\r\n\t        y2++;\r\n\t      }\r\n\t      v2[k2_offset] = x2;\r\n\t      if (x2 > text1_length) {\r\n\t        // Ran off the left of the graph.\r\n\t        k2end += 2;\r\n\t      } else if (y2 > text2_length) {\r\n\t        // Ran off the top of the graph.\r\n\t        k2start += 2;\r\n\t      } else if (!front) {\r\n\t        var k1_offset = v_offset + delta - k2;\r\n\t        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n\t          var x1 = v1[k1_offset];\r\n\t          var y1 = v_offset + x1 - k1_offset;\r\n\t          // Mirror x2 onto top-left coordinate system.\r\n\t          x2 = text1_length - x2;\r\n\t          if (x1 >= x2) {\r\n\t            // Overlap detected.\r\n\t            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t  // Diff took too long and hit the deadline or\r\n\t  // number of diffs equals number of characters, no commonality at all.\r\n\t  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Given the location of the 'middle snake', split the diff in two parts\r\n\t * and recurse.\r\n\t * @param {string} text1 Old string to be diffed.\r\n\t * @param {string} text2 New string to be diffed.\r\n\t * @param {number} x Index of split point in text1.\r\n\t * @param {number} y Index of split point in text2.\r\n\t * @param {number} deadline Time at which to bail if not yet complete.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n\t    deadline) {\r\n\t  var text1a = text1.substring(0, x);\r\n\t  var text2a = text2.substring(0, y);\r\n\t  var text1b = text1.substring(x);\r\n\t  var text2b = text2.substring(y);\r\n\t\r\n\t  // Compute both diffs serially.\r\n\t  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n\t  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\t\r\n\t  return diffs.concat(diffsb);\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\r\n\t * hashes where each Unicode character represents one line.\r\n\t * @param {string} text1 First string.\r\n\t * @param {string} text2 Second string.\r\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n\t *     An object containing the encoded text1, the encoded text2 and\r\n\t *     the array of unique strings.\r\n\t *     The zeroth element of the array of unique strings is intentionally blank.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n\t  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n\t  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\t\r\n\t  // '\\x00' is a valid character, but various debuggers don't like it.\r\n\t  // So we'll insert a junk entry to avoid generating a null character.\r\n\t  lineArray[0] = '';\r\n\t\r\n\t  /**\r\n\t   * Split a text into an array of strings.  Reduce the texts to a string of\r\n\t   * hashes where each Unicode character represents one line.\r\n\t   * Modifies linearray and linehash through being a closure.\r\n\t   * @param {string} text String to encode.\r\n\t   * @return {string} Encoded string.\r\n\t   * @private\r\n\t   */\r\n\t  function diff_linesToCharsMunge_(text) {\r\n\t    var chars = '';\r\n\t    // Walk the text, pulling out a substring for each line.\r\n\t    // text.split('\\n') would would temporarily double our memory footprint.\r\n\t    // Modifying text would create many large strings to garbage collect.\r\n\t    var lineStart = 0;\r\n\t    var lineEnd = -1;\r\n\t    // Keeping our own length variable is faster than looking it up.\r\n\t    var lineArrayLength = lineArray.length;\r\n\t    while (lineEnd < text.length - 1) {\r\n\t      lineEnd = text.indexOf('\\n', lineStart);\r\n\t      if (lineEnd == -1) {\r\n\t        lineEnd = text.length - 1;\r\n\t      }\r\n\t      var line = text.substring(lineStart, lineEnd + 1);\r\n\t      lineStart = lineEnd + 1;\r\n\t\r\n\t      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n\t          (lineHash[line] !== undefined)) {\r\n\t        chars += String.fromCharCode(lineHash[line]);\r\n\t      } else {\r\n\t        chars += String.fromCharCode(lineArrayLength);\r\n\t        lineHash[line] = lineArrayLength;\r\n\t        lineArray[lineArrayLength++] = line;\r\n\t      }\r\n\t    }\r\n\t    return chars;\r\n\t  }\r\n\t\r\n\t  var chars1 = diff_linesToCharsMunge_(text1);\r\n\t  var chars2 = diff_linesToCharsMunge_(text2);\r\n\t  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n\t * text.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @param {!Array.<string>} lineArray Array of unique strings.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    var chars = diffs[x][1];\r\n\t    var text = [];\r\n\t    for (var y = 0; y < chars.length; y++) {\r\n\t      text[y] = lineArray[chars.charCodeAt(y)];\r\n\t    }\r\n\t    diffs[x][1] = text.join('');\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Determine the common prefix of two strings.\r\n\t * @param {string} text1 First string.\r\n\t * @param {string} text2 Second string.\r\n\t * @return {number} The number of characters common to the start of each\r\n\t *     string.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n\t  // Quick check for common null cases.\r\n\t  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n\t    return 0;\r\n\t  }\r\n\t  // Binary search.\r\n\t  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n\t  var pointermin = 0;\r\n\t  var pointermax = Math.min(text1.length, text2.length);\r\n\t  var pointermid = pointermax;\r\n\t  var pointerstart = 0;\r\n\t  while (pointermin < pointermid) {\r\n\t    if (text1.substring(pointerstart, pointermid) ==\r\n\t        text2.substring(pointerstart, pointermid)) {\r\n\t      pointermin = pointermid;\r\n\t      pointerstart = pointermin;\r\n\t    } else {\r\n\t      pointermax = pointermid;\r\n\t    }\r\n\t    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n\t  }\r\n\t  return pointermid;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Determine the common suffix of two strings.\r\n\t * @param {string} text1 First string.\r\n\t * @param {string} text2 Second string.\r\n\t * @return {number} The number of characters common to the end of each string.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n\t  // Quick check for common null cases.\r\n\t  if (!text1 || !text2 ||\r\n\t      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n\t    return 0;\r\n\t  }\r\n\t  // Binary search.\r\n\t  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n\t  var pointermin = 0;\r\n\t  var pointermax = Math.min(text1.length, text2.length);\r\n\t  var pointermid = pointermax;\r\n\t  var pointerend = 0;\r\n\t  while (pointermin < pointermid) {\r\n\t    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n\t        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n\t      pointermin = pointermid;\r\n\t      pointerend = pointermin;\r\n\t    } else {\r\n\t      pointermax = pointermid;\r\n\t    }\r\n\t    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n\t  }\r\n\t  return pointermid;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Determine if the suffix of one string is the prefix of another.\r\n\t * @param {string} text1 First string.\r\n\t * @param {string} text2 Second string.\r\n\t * @return {number} The number of characters common to the end of the first\r\n\t *     string and the start of the second string.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n\t  // Cache the text lengths to prevent multiple calls.\r\n\t  var text1_length = text1.length;\r\n\t  var text2_length = text2.length;\r\n\t  // Eliminate the null case.\r\n\t  if (text1_length == 0 || text2_length == 0) {\r\n\t    return 0;\r\n\t  }\r\n\t  // Truncate the longer string.\r\n\t  if (text1_length > text2_length) {\r\n\t    text1 = text1.substring(text1_length - text2_length);\r\n\t  } else if (text1_length < text2_length) {\r\n\t    text2 = text2.substring(0, text1_length);\r\n\t  }\r\n\t  var text_length = Math.min(text1_length, text2_length);\r\n\t  // Quick check for the worst case.\r\n\t  if (text1 == text2) {\r\n\t    return text_length;\r\n\t  }\r\n\t\r\n\t  // Start by looking for a single character match\r\n\t  // and increase length until no match is found.\r\n\t  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n\t  var best = 0;\r\n\t  var length = 1;\r\n\t  while (true) {\r\n\t    var pattern = text1.substring(text_length - length);\r\n\t    var found = text2.indexOf(pattern);\r\n\t    if (found == -1) {\r\n\t      return best;\r\n\t    }\r\n\t    length += found;\r\n\t    if (found == 0 || text1.substring(text_length - length) ==\r\n\t        text2.substring(0, length)) {\r\n\t      best = length;\r\n\t      length++;\r\n\t    }\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Do the two texts share a substring which is at least half the length of the\r\n\t * longer text?\r\n\t * This speedup can produce non-minimal diffs.\r\n\t * @param {string} text1 First string.\r\n\t * @param {string} text2 Second string.\r\n\t * @return {Array.<string>} Five element Array, containing the prefix of\r\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n\t *     text2 and the common middle.  Or null if there was no match.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n\t  if (this.Diff_Timeout <= 0) {\r\n\t    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n\t    return null;\r\n\t  }\r\n\t  var longtext = text1.length > text2.length ? text1 : text2;\r\n\t  var shorttext = text1.length > text2.length ? text2 : text1;\r\n\t  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n\t    return null;  // Pointless.\r\n\t  }\r\n\t  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\t\r\n\t  /**\r\n\t   * Does a substring of shorttext exist within longtext such that the substring\r\n\t   * is at least half the length of longtext?\r\n\t   * Closure, but does not reference any external variables.\r\n\t   * @param {string} longtext Longer string.\r\n\t   * @param {string} shorttext Shorter string.\r\n\t   * @param {number} i Start index of quarter length substring within longtext.\r\n\t   * @return {Array.<string>} Five element Array, containing the prefix of\r\n\t   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n\t   *     of shorttext and the common middle.  Or null if there was no match.\r\n\t   * @private\r\n\t   */\r\n\t  function diff_halfMatchI_(longtext, shorttext, i) {\r\n\t    // Start with a 1/4 length substring at position i as a seed.\r\n\t    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n\t    var j = -1;\r\n\t    var best_common = '';\r\n\t    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n\t    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n\t      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n\t                                               shorttext.substring(j));\r\n\t      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n\t                                               shorttext.substring(0, j));\r\n\t      if (best_common.length < suffixLength + prefixLength) {\r\n\t        best_common = shorttext.substring(j - suffixLength, j) +\r\n\t            shorttext.substring(j, j + prefixLength);\r\n\t        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n\t        best_longtext_b = longtext.substring(i + prefixLength);\r\n\t        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n\t        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n\t      }\r\n\t    }\r\n\t    if (best_common.length * 2 >= longtext.length) {\r\n\t      return [best_longtext_a, best_longtext_b,\r\n\t              best_shorttext_a, best_shorttext_b, best_common];\r\n\t    } else {\r\n\t      return null;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // First check if the second quarter is the seed for a half-match.\r\n\t  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n\t                             Math.ceil(longtext.length / 4));\r\n\t  // Check again based on the third quarter.\r\n\t  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n\t                             Math.ceil(longtext.length / 2));\r\n\t  var hm;\r\n\t  if (!hm1 && !hm2) {\r\n\t    return null;\r\n\t  } else if (!hm2) {\r\n\t    hm = hm1;\r\n\t  } else if (!hm1) {\r\n\t    hm = hm2;\r\n\t  } else {\r\n\t    // Both matched.  Select the longest.\r\n\t    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n\t  }\r\n\t\r\n\t  // A half-match was found, sort out the return data.\r\n\t  var text1_a, text1_b, text2_a, text2_b;\r\n\t  if (text1.length > text2.length) {\r\n\t    text1_a = hm[0];\r\n\t    text1_b = hm[1];\r\n\t    text2_a = hm[2];\r\n\t    text2_b = hm[3];\r\n\t  } else {\r\n\t    text2_a = hm[0];\r\n\t    text2_b = hm[1];\r\n\t    text1_a = hm[2];\r\n\t    text1_b = hm[3];\r\n\t  }\r\n\t  var mid_common = hm[4];\r\n\t  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n\t  var changes = false;\r\n\t  var equalities = [];  // Stack of indices where equalities are found.\r\n\t  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n\t  /** @type {?string} */\r\n\t  var lastequality = null;\r\n\t  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n\t  var pointer = 0;  // Index of current position.\r\n\t  // Number of characters that changed prior to the equality.\r\n\t  var length_insertions1 = 0;\r\n\t  var length_deletions1 = 0;\r\n\t  // Number of characters that changed after the equality.\r\n\t  var length_insertions2 = 0;\r\n\t  var length_deletions2 = 0;\r\n\t  while (pointer < diffs.length) {\r\n\t    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n\t      equalities[equalitiesLength++] = pointer;\r\n\t      length_insertions1 = length_insertions2;\r\n\t      length_deletions1 = length_deletions2;\r\n\t      length_insertions2 = 0;\r\n\t      length_deletions2 = 0;\r\n\t      lastequality = diffs[pointer][1];\r\n\t    } else {  // An insertion or deletion.\r\n\t      if (diffs[pointer][0] == DIFF_INSERT) {\r\n\t        length_insertions2 += diffs[pointer][1].length;\r\n\t      } else {\r\n\t        length_deletions2 += diffs[pointer][1].length;\r\n\t      }\r\n\t      // Eliminate an equality that is smaller or equal to the edits on both\r\n\t      // sides of it.\r\n\t      if (lastequality && (lastequality.length <=\r\n\t          Math.max(length_insertions1, length_deletions1)) &&\r\n\t          (lastequality.length <= Math.max(length_insertions2,\r\n\t                                           length_deletions2))) {\r\n\t        // Duplicate record.\r\n\t        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n\t                     [DIFF_DELETE, lastequality]);\r\n\t        // Change second copy to insert.\r\n\t        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n\t        // Throw away the equality we just deleted.\r\n\t        equalitiesLength--;\r\n\t        // Throw away the previous equality (it needs to be reevaluated).\r\n\t        equalitiesLength--;\r\n\t        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n\t        length_insertions1 = 0;  // Reset the counters.\r\n\t        length_deletions1 = 0;\r\n\t        length_insertions2 = 0;\r\n\t        length_deletions2 = 0;\r\n\t        lastequality = null;\r\n\t        changes = true;\r\n\t      }\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t\r\n\t  // Normalize the diff.\r\n\t  if (changes) {\r\n\t    this.diff_cleanupMerge(diffs);\r\n\t  }\r\n\t  this.diff_cleanupSemanticLossless(diffs);\r\n\t\r\n\t  // Find any overlaps between deletions and insertions.\r\n\t  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n\t  //   -> <del>abc</del>xxx<ins>def</ins>\r\n\t  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n\t  //   -> <ins>def</ins>xxx<del>abc</del>\r\n\t  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n\t  pointer = 1;\r\n\t  while (pointer < diffs.length) {\r\n\t    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n\t        diffs[pointer][0] == DIFF_INSERT) {\r\n\t      var deletion = diffs[pointer - 1][1];\r\n\t      var insertion = diffs[pointer][1];\r\n\t      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n\t      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n\t      if (overlap_length1 >= overlap_length2) {\r\n\t        if (overlap_length1 >= deletion.length / 2 ||\r\n\t            overlap_length1 >= insertion.length / 2) {\r\n\t          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n\t          diffs.splice(pointer, 0,\r\n\t              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n\t          diffs[pointer - 1][1] =\r\n\t              deletion.substring(0, deletion.length - overlap_length1);\r\n\t          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n\t          pointer++;\r\n\t        }\r\n\t      } else {\r\n\t        if (overlap_length2 >= deletion.length / 2 ||\r\n\t            overlap_length2 >= insertion.length / 2) {\r\n\t          // Reverse overlap found.\r\n\t          // Insert an equality and swap and trim the surrounding edits.\r\n\t          diffs.splice(pointer, 0,\r\n\t              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n\t          diffs[pointer - 1][0] = DIFF_INSERT;\r\n\t          diffs[pointer - 1][1] =\r\n\t              insertion.substring(0, insertion.length - overlap_length2);\r\n\t          diffs[pointer + 1][0] = DIFF_DELETE;\r\n\t          diffs[pointer + 1][1] =\r\n\t              deletion.substring(overlap_length2);\r\n\t          pointer++;\r\n\t        }\r\n\t      }\r\n\t      pointer++;\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Look for single edits surrounded on both sides by equalities\r\n\t * which can be shifted sideways to align the edit to a word boundary.\r\n\t * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n\t  /**\r\n\t   * Given two strings, compute a score representing whether the internal\r\n\t   * boundary falls on logical boundaries.\r\n\t   * Scores range from 6 (best) to 0 (worst).\r\n\t   * Closure, but does not reference any external variables.\r\n\t   * @param {string} one First string.\r\n\t   * @param {string} two Second string.\r\n\t   * @return {number} The score.\r\n\t   * @private\r\n\t   */\r\n\t  function diff_cleanupSemanticScore_(one, two) {\r\n\t    if (!one || !two) {\r\n\t      // Edges are the best.\r\n\t      return 6;\r\n\t    }\r\n\t\r\n\t    // Each port of this function behaves slightly differently due to\r\n\t    // subtle differences in each language's definition of things like\r\n\t    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n\t    // the choice has been made to use each language's native features\r\n\t    // rather than force total conformity.\r\n\t    var char1 = one.charAt(one.length - 1);\r\n\t    var char2 = two.charAt(0);\r\n\t    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n\t    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n\t    var whitespace1 = nonAlphaNumeric1 &&\r\n\t        char1.match(diff_match_patch.whitespaceRegex_);\r\n\t    var whitespace2 = nonAlphaNumeric2 &&\r\n\t        char2.match(diff_match_patch.whitespaceRegex_);\r\n\t    var lineBreak1 = whitespace1 &&\r\n\t        char1.match(diff_match_patch.linebreakRegex_);\r\n\t    var lineBreak2 = whitespace2 &&\r\n\t        char2.match(diff_match_patch.linebreakRegex_);\r\n\t    var blankLine1 = lineBreak1 &&\r\n\t        one.match(diff_match_patch.blanklineEndRegex_);\r\n\t    var blankLine2 = lineBreak2 &&\r\n\t        two.match(diff_match_patch.blanklineStartRegex_);\r\n\t\r\n\t    if (blankLine1 || blankLine2) {\r\n\t      // Five points for blank lines.\r\n\t      return 5;\r\n\t    } else if (lineBreak1 || lineBreak2) {\r\n\t      // Four points for line breaks.\r\n\t      return 4;\r\n\t    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n\t      // Three points for end of sentences.\r\n\t      return 3;\r\n\t    } else if (whitespace1 || whitespace2) {\r\n\t      // Two points for whitespace.\r\n\t      return 2;\r\n\t    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n\t      // One point for non-alphanumeric.\r\n\t      return 1;\r\n\t    }\r\n\t    return 0;\r\n\t  }\r\n\t\r\n\t  var pointer = 1;\r\n\t  // Intentionally ignore the first and last element (don't need checking).\r\n\t  while (pointer < diffs.length - 1) {\r\n\t    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n\t        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n\t      // This is a single edit surrounded by equalities.\r\n\t      var equality1 = diffs[pointer - 1][1];\r\n\t      var edit = diffs[pointer][1];\r\n\t      var equality2 = diffs[pointer + 1][1];\r\n\t\r\n\t      // First, shift the edit as far left as possible.\r\n\t      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n\t      if (commonOffset) {\r\n\t        var commonString = edit.substring(edit.length - commonOffset);\r\n\t        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n\t        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n\t        equality2 = commonString + equality2;\r\n\t      }\r\n\t\r\n\t      // Second, step character by character right, looking for the best fit.\r\n\t      var bestEquality1 = equality1;\r\n\t      var bestEdit = edit;\r\n\t      var bestEquality2 = equality2;\r\n\t      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n\t          diff_cleanupSemanticScore_(edit, equality2);\r\n\t      while (edit.charAt(0) === equality2.charAt(0)) {\r\n\t        equality1 += edit.charAt(0);\r\n\t        edit = edit.substring(1) + equality2.charAt(0);\r\n\t        equality2 = equality2.substring(1);\r\n\t        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n\t            diff_cleanupSemanticScore_(edit, equality2);\r\n\t        // The >= encourages trailing rather than leading whitespace on edits.\r\n\t        if (score >= bestScore) {\r\n\t          bestScore = score;\r\n\t          bestEquality1 = equality1;\r\n\t          bestEdit = edit;\r\n\t          bestEquality2 = equality2;\r\n\t        }\r\n\t      }\r\n\t\r\n\t      if (diffs[pointer - 1][1] != bestEquality1) {\r\n\t        // We have an improvement, save it back to the diff.\r\n\t        if (bestEquality1) {\r\n\t          diffs[pointer - 1][1] = bestEquality1;\r\n\t        } else {\r\n\t          diffs.splice(pointer - 1, 1);\r\n\t          pointer--;\r\n\t        }\r\n\t        diffs[pointer][1] = bestEdit;\r\n\t        if (bestEquality2) {\r\n\t          diffs[pointer + 1][1] = bestEquality2;\r\n\t        } else {\r\n\t          diffs.splice(pointer + 1, 1);\r\n\t          pointer--;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t};\r\n\t\r\n\t// Define some regex patterns for matching boundaries.\r\n\tdiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\n\tdiff_match_patch.whitespaceRegex_ = /\\s/;\r\n\tdiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\n\tdiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\n\tdiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\t\r\n\t/**\r\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n\t  var changes = false;\r\n\t  var equalities = [];  // Stack of indices where equalities are found.\r\n\t  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n\t  /** @type {?string} */\r\n\t  var lastequality = null;\r\n\t  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n\t  var pointer = 0;  // Index of current position.\r\n\t  // Is there an insertion operation before the last equality.\r\n\t  var pre_ins = false;\r\n\t  // Is there a deletion operation before the last equality.\r\n\t  var pre_del = false;\r\n\t  // Is there an insertion operation after the last equality.\r\n\t  var post_ins = false;\r\n\t  // Is there a deletion operation after the last equality.\r\n\t  var post_del = false;\r\n\t  while (pointer < diffs.length) {\r\n\t    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n\t      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n\t          (post_ins || post_del)) {\r\n\t        // Candidate found.\r\n\t        equalities[equalitiesLength++] = pointer;\r\n\t        pre_ins = post_ins;\r\n\t        pre_del = post_del;\r\n\t        lastequality = diffs[pointer][1];\r\n\t      } else {\r\n\t        // Not a candidate, and can never become one.\r\n\t        equalitiesLength = 0;\r\n\t        lastequality = null;\r\n\t      }\r\n\t      post_ins = post_del = false;\r\n\t    } else {  // An insertion or deletion.\r\n\t      if (diffs[pointer][0] == DIFF_DELETE) {\r\n\t        post_del = true;\r\n\t      } else {\r\n\t        post_ins = true;\r\n\t      }\r\n\t      /*\r\n\t       * Five types to be split:\r\n\t       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n\t       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n\t       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n\t       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n\t       * <ins>A</ins><del>B</del>X<del>C</del>\r\n\t       */\r\n\t      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n\t                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n\t                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n\t        // Duplicate record.\r\n\t        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n\t                     [DIFF_DELETE, lastequality]);\r\n\t        // Change second copy to insert.\r\n\t        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n\t        equalitiesLength--;  // Throw away the equality we just deleted;\r\n\t        lastequality = null;\r\n\t        if (pre_ins && pre_del) {\r\n\t          // No changes made which could affect previous entry, keep going.\r\n\t          post_ins = post_del = true;\r\n\t          equalitiesLength = 0;\r\n\t        } else {\r\n\t          equalitiesLength--;  // Throw away the previous equality.\r\n\t          pointer = equalitiesLength > 0 ?\r\n\t              equalities[equalitiesLength - 1] : -1;\r\n\t          post_ins = post_del = false;\r\n\t        }\r\n\t        changes = true;\r\n\t      }\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t\r\n\t  if (changes) {\r\n\t    this.diff_cleanupMerge(diffs);\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Reorder and merge like edit sections.  Merge equalities.\r\n\t * Any edit section can move as long as it doesn't cross an equality.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n\t  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n\t  var pointer = 0;\r\n\t  var count_delete = 0;\r\n\t  var count_insert = 0;\r\n\t  var text_delete = '';\r\n\t  var text_insert = '';\r\n\t  var commonlength;\r\n\t  while (pointer < diffs.length) {\r\n\t    switch (diffs[pointer][0]) {\r\n\t      case DIFF_INSERT:\r\n\t        count_insert++;\r\n\t        text_insert += diffs[pointer][1];\r\n\t        pointer++;\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        count_delete++;\r\n\t        text_delete += diffs[pointer][1];\r\n\t        pointer++;\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        // Upon reaching an equality, check for prior redundancies.\r\n\t        if (count_delete + count_insert > 1) {\r\n\t          if (count_delete !== 0 && count_insert !== 0) {\r\n\t            // Factor out any common prefixies.\r\n\t            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n\t            if (commonlength !== 0) {\r\n\t              if ((pointer - count_delete - count_insert) > 0 &&\r\n\t                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n\t                  DIFF_EQUAL) {\r\n\t                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n\t                    text_insert.substring(0, commonlength);\r\n\t              } else {\r\n\t                diffs.splice(0, 0, [DIFF_EQUAL,\r\n\t                                    text_insert.substring(0, commonlength)]);\r\n\t                pointer++;\r\n\t              }\r\n\t              text_insert = text_insert.substring(commonlength);\r\n\t              text_delete = text_delete.substring(commonlength);\r\n\t            }\r\n\t            // Factor out any common suffixies.\r\n\t            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n\t            if (commonlength !== 0) {\r\n\t              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n\t                  commonlength) + diffs[pointer][1];\r\n\t              text_insert = text_insert.substring(0, text_insert.length -\r\n\t                  commonlength);\r\n\t              text_delete = text_delete.substring(0, text_delete.length -\r\n\t                  commonlength);\r\n\t            }\r\n\t          }\r\n\t          // Delete the offending records and add the merged ones.\r\n\t          if (count_delete === 0) {\r\n\t            diffs.splice(pointer - count_insert,\r\n\t                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n\t          } else if (count_insert === 0) {\r\n\t            diffs.splice(pointer - count_delete,\r\n\t                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n\t          } else {\r\n\t            diffs.splice(pointer - count_delete - count_insert,\r\n\t                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n\t                [DIFF_INSERT, text_insert]);\r\n\t          }\r\n\t          pointer = pointer - count_delete - count_insert +\r\n\t                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n\t        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n\t          // Merge this equality with the previous one.\r\n\t          diffs[pointer - 1][1] += diffs[pointer][1];\r\n\t          diffs.splice(pointer, 1);\r\n\t        } else {\r\n\t          pointer++;\r\n\t        }\r\n\t        count_insert = 0;\r\n\t        count_delete = 0;\r\n\t        text_delete = '';\r\n\t        text_insert = '';\r\n\t        break;\r\n\t    }\r\n\t  }\r\n\t  if (diffs[diffs.length - 1][1] === '') {\r\n\t    diffs.pop();  // Remove the dummy entry at the end.\r\n\t  }\r\n\t\r\n\t  // Second pass: look for single edits surrounded on both sides by equalities\r\n\t  // which can be shifted sideways to eliminate an equality.\r\n\t  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n\t  var changes = false;\r\n\t  pointer = 1;\r\n\t  // Intentionally ignore the first and last element (don't need checking).\r\n\t  while (pointer < diffs.length - 1) {\r\n\t    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n\t        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n\t      // This is a single edit surrounded by equalities.\r\n\t      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n\t          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n\t        // Shift the edit over the previous equality.\r\n\t        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n\t            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n\t                                        diffs[pointer - 1][1].length);\r\n\t        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n\t        diffs.splice(pointer - 1, 1);\r\n\t        changes = true;\r\n\t      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n\t          diffs[pointer + 1][1]) {\r\n\t        // Shift the edit over the next equality.\r\n\t        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n\t        diffs[pointer][1] =\r\n\t            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n\t            diffs[pointer + 1][1];\r\n\t        diffs.splice(pointer + 1, 1);\r\n\t        changes = true;\r\n\t      }\r\n\t    }\r\n\t    pointer++;\r\n\t  }\r\n\t  // If shifts were made, the diff needs reordering and another shift sweep.\r\n\t  if (changes) {\r\n\t    this.diff_cleanupMerge(diffs);\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * loc is a location in text1, compute and return the equivalent location in\r\n\t * text2.\r\n\t * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @param {number} loc Location within text1.\r\n\t * @return {number} Location within text2.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n\t  var chars1 = 0;\r\n\t  var chars2 = 0;\r\n\t  var last_chars1 = 0;\r\n\t  var last_chars2 = 0;\r\n\t  var x;\r\n\t  for (x = 0; x < diffs.length; x++) {\r\n\t    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n\t      chars1 += diffs[x][1].length;\r\n\t    }\r\n\t    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n\t      chars2 += diffs[x][1].length;\r\n\t    }\r\n\t    if (chars1 > loc) {  // Overshot the location.\r\n\t      break;\r\n\t    }\r\n\t    last_chars1 = chars1;\r\n\t    last_chars2 = chars2;\r\n\t  }\r\n\t  // Was the location was deleted?\r\n\t  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n\t    return last_chars2;\r\n\t  }\r\n\t  // Add the remaining character length.\r\n\t  return last_chars2 + (loc - last_chars1);\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Convert a diff array into a pretty HTML report.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @return {string} HTML representation.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n\t  var html = [];\r\n\t  var pattern_amp = /&/g;\r\n\t  var pattern_lt = /</g;\r\n\t  var pattern_gt = />/g;\r\n\t  var pattern_para = /\\n/g;\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n\t    var data = diffs[x][1];  // Text of change.\r\n\t    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n\t        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n\t    switch (op) {\r\n\t      case DIFF_INSERT:\r\n\t        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        html[x] = '<span>' + text + '</span>';\r\n\t        break;\r\n\t    }\r\n\t  }\r\n\t  return html.join('');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Compute and return the source text (all equalities and deletions).\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @return {string} Source text.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n\t  var text = [];\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    if (diffs[x][0] !== DIFF_INSERT) {\r\n\t      text[x] = diffs[x][1];\r\n\t    }\r\n\t  }\r\n\t  return text.join('');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Compute and return the destination text (all equalities and insertions).\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @return {string} Destination text.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n\t  var text = [];\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    if (diffs[x][0] !== DIFF_DELETE) {\r\n\t      text[x] = diffs[x][1];\r\n\t    }\r\n\t  }\r\n\t  return text.join('');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Compute the Levenshtein distance; the number of inserted, deleted or\r\n\t * substituted characters.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @return {number} Number of changes.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n\t  var levenshtein = 0;\r\n\t  var insertions = 0;\r\n\t  var deletions = 0;\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    var op = diffs[x][0];\r\n\t    var data = diffs[x][1];\r\n\t    switch (op) {\r\n\t      case DIFF_INSERT:\r\n\t        insertions += data.length;\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        deletions += data.length;\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        // A deletion and an insertion is one substitution.\r\n\t        levenshtein += Math.max(insertions, deletions);\r\n\t        insertions = 0;\r\n\t        deletions = 0;\r\n\t        break;\r\n\t    }\r\n\t  }\r\n\t  levenshtein += Math.max(insertions, deletions);\r\n\t  return levenshtein;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Crush the diff into an encoded string which describes the operations\r\n\t * required to transform text1 into text2.\r\n\t * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n\t * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n\t * @return {string} Delta text.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n\t  var text = [];\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    switch (diffs[x][0]) {\r\n\t      case DIFF_INSERT:\r\n\t        text[x] = '+' + encodeURI(diffs[x][1]);\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        text[x] = '-' + diffs[x][1].length;\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        text[x] = '=' + diffs[x][1].length;\r\n\t        break;\r\n\t    }\r\n\t  }\r\n\t  return text.join('\\t').replace(/%20/g, ' ');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Given the original text1, and an encoded string which describes the\r\n\t * operations required to transform text1 into text2, compute the full diff.\r\n\t * @param {string} text1 Source string for the diff.\r\n\t * @param {string} delta Delta text.\r\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n\t * @throws {!Error} If invalid input.\r\n\t */\r\n\tdiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n\t  var diffs = [];\r\n\t  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n\t  var pointer = 0;  // Cursor in text1\r\n\t  var tokens = delta.split(/\\t/g);\r\n\t  for (var x = 0; x < tokens.length; x++) {\r\n\t    // Each token begins with a one character parameter which specifies the\r\n\t    // operation of this token (delete, insert, equality).\r\n\t    var param = tokens[x].substring(1);\r\n\t    switch (tokens[x].charAt(0)) {\r\n\t      case '+':\r\n\t        try {\r\n\t          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n\t        } catch (ex) {\r\n\t          // Malformed URI sequence.\r\n\t          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n\t        }\r\n\t        break;\r\n\t      case '-':\r\n\t        // Fall through.\r\n\t      case '=':\r\n\t        var n = parseInt(param, 10);\r\n\t        if (isNaN(n) || n < 0) {\r\n\t          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n\t        }\r\n\t        var text = text1.substring(pointer, pointer += n);\r\n\t        if (tokens[x].charAt(0) == '=') {\r\n\t          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n\t        } else {\r\n\t          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n\t        }\r\n\t        break;\r\n\t      default:\r\n\t        // Blank tokens are ok (from a trailing \\t).\r\n\t        // Anything else is an error.\r\n\t        if (tokens[x]) {\r\n\t          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n\t                          tokens[x]);\r\n\t        }\r\n\t    }\r\n\t  }\r\n\t  if (pointer != text1.length) {\r\n\t    throw new Error('Delta length (' + pointer +\r\n\t        ') does not equal source text length (' + text1.length + ').');\r\n\t  }\r\n\t  return diffs;\r\n\t};\r\n\t\r\n\t\r\n\t//  MATCH FUNCTIONS\r\n\t\r\n\t\r\n\t/**\r\n\t * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n\t * @param {string} text The text to search.\r\n\t * @param {string} pattern The pattern to search for.\r\n\t * @param {number} loc The location to search around.\r\n\t * @return {number} Best match index or -1.\r\n\t */\r\n\tdiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n\t  // Check for null inputs.\r\n\t  if (text == null || pattern == null || loc == null) {\r\n\t    throw new Error('Null input. (match_main)');\r\n\t  }\r\n\t\r\n\t  loc = Math.max(0, Math.min(loc, text.length));\r\n\t  if (text == pattern) {\r\n\t    // Shortcut (potentially not guaranteed by the algorithm)\r\n\t    return 0;\r\n\t  } else if (!text.length) {\r\n\t    // Nothing to match.\r\n\t    return -1;\r\n\t  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n\t    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n\t    return loc;\r\n\t  } else {\r\n\t    // Do a fuzzy compare.\r\n\t    return this.match_bitap_(text, pattern, loc);\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n\t * Bitap algorithm.\r\n\t * @param {string} text The text to search.\r\n\t * @param {string} pattern The pattern to search for.\r\n\t * @param {number} loc The location to search around.\r\n\t * @return {number} Best match index or -1.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n\t  if (pattern.length > this.Match_MaxBits) {\r\n\t    throw new Error('Pattern too long for this browser.');\r\n\t  }\r\n\t\r\n\t  // Initialise the alphabet.\r\n\t  var s = this.match_alphabet_(pattern);\r\n\t\r\n\t  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\t\r\n\t  /**\r\n\t   * Compute and return the score for a match with e errors and x location.\r\n\t   * Accesses loc and pattern through being a closure.\r\n\t   * @param {number} e Number of errors in match.\r\n\t   * @param {number} x Location of match.\r\n\t   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n\t   * @private\r\n\t   */\r\n\t  function match_bitapScore_(e, x) {\r\n\t    var accuracy = e / pattern.length;\r\n\t    var proximity = Math.abs(loc - x);\r\n\t    if (!dmp.Match_Distance) {\r\n\t      // Dodge divide by zero error.\r\n\t      return proximity ? 1.0 : accuracy;\r\n\t    }\r\n\t    return accuracy + (proximity / dmp.Match_Distance);\r\n\t  }\r\n\t\r\n\t  // Highest score beyond which we give up.\r\n\t  var score_threshold = this.Match_Threshold;\r\n\t  // Is there a nearby exact match? (speedup)\r\n\t  var best_loc = text.indexOf(pattern, loc);\r\n\t  if (best_loc != -1) {\r\n\t    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n\t    // What about in the other direction? (speedup)\r\n\t    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n\t    if (best_loc != -1) {\r\n\t      score_threshold =\r\n\t          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Initialise the bit arrays.\r\n\t  var matchmask = 1 << (pattern.length - 1);\r\n\t  best_loc = -1;\r\n\t\r\n\t  var bin_min, bin_mid;\r\n\t  var bin_max = pattern.length + text.length;\r\n\t  var last_rd;\r\n\t  for (var d = 0; d < pattern.length; d++) {\r\n\t    // Scan for the best match; each iteration allows for one more error.\r\n\t    // Run a binary search to determine how far from 'loc' we can stray at this\r\n\t    // error level.\r\n\t    bin_min = 0;\r\n\t    bin_mid = bin_max;\r\n\t    while (bin_min < bin_mid) {\r\n\t      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n\t        bin_min = bin_mid;\r\n\t      } else {\r\n\t        bin_max = bin_mid;\r\n\t      }\r\n\t      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n\t    }\r\n\t    // Use the result from this iteration as the maximum for the next.\r\n\t    bin_max = bin_mid;\r\n\t    var start = Math.max(1, loc - bin_mid + 1);\r\n\t    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\t\r\n\t    var rd = Array(finish + 2);\r\n\t    rd[finish + 1] = (1 << d) - 1;\r\n\t    for (var j = finish; j >= start; j--) {\r\n\t      // The alphabet (s) is a sparse hash, so the following line generates\r\n\t      // warnings.\r\n\t      var charMatch = s[text.charAt(j - 1)];\r\n\t      if (d === 0) {  // First pass: exact match.\r\n\t        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n\t      } else {  // Subsequent passes: fuzzy match.\r\n\t        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n\t                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n\t                last_rd[j + 1];\r\n\t      }\r\n\t      if (rd[j] & matchmask) {\r\n\t        var score = match_bitapScore_(d, j - 1);\r\n\t        // This match will almost certainly be better than any existing match.\r\n\t        // But check anyway.\r\n\t        if (score <= score_threshold) {\r\n\t          // Told you so.\r\n\t          score_threshold = score;\r\n\t          best_loc = j - 1;\r\n\t          if (best_loc > loc) {\r\n\t            // When passing loc, don't exceed our current distance from loc.\r\n\t            start = Math.max(1, 2 * loc - best_loc);\r\n\t          } else {\r\n\t            // Already passed loc, downhill from here on in.\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    // No hope for a (better) match at greater error levels.\r\n\t    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n\t      break;\r\n\t    }\r\n\t    last_rd = rd;\r\n\t  }\r\n\t  return best_loc;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Initialise the alphabet for the Bitap algorithm.\r\n\t * @param {string} pattern The text to encode.\r\n\t * @return {!Object} Hash of character locations.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n\t  var s = {};\r\n\t  for (var i = 0; i < pattern.length; i++) {\r\n\t    s[pattern.charAt(i)] = 0;\r\n\t  }\r\n\t  for (var i = 0; i < pattern.length; i++) {\r\n\t    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n\t  }\r\n\t  return s;\r\n\t};\r\n\t\r\n\t\r\n\t//  PATCH FUNCTIONS\r\n\t\r\n\t\r\n\t/**\r\n\t * Increase the context until it is unique,\r\n\t * but don't let the pattern expand beyond Match_MaxBits.\r\n\t * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n\t * @param {string} text Source text.\r\n\t * @private\r\n\t */\r\n\tdiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n\t  if (text.length == 0) {\r\n\t    return;\r\n\t  }\r\n\t  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n\t  var padding = 0;\r\n\t\r\n\t  // Look for the first and last matches of pattern in text.  If two different\r\n\t  // matches are found, increase the pattern length.\r\n\t  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n\t         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n\t         this.Patch_Margin) {\r\n\t    padding += this.Patch_Margin;\r\n\t    pattern = text.substring(patch.start2 - padding,\r\n\t                             patch.start2 + patch.length1 + padding);\r\n\t  }\r\n\t  // Add one chunk for good luck.\r\n\t  padding += this.Patch_Margin;\r\n\t\r\n\t  // Add the prefix.\r\n\t  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n\t  if (prefix) {\r\n\t    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n\t  }\r\n\t  // Add the suffix.\r\n\t  var suffix = text.substring(patch.start2 + patch.length1,\r\n\t                              patch.start2 + patch.length1 + padding);\r\n\t  if (suffix) {\r\n\t    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n\t  }\r\n\t\r\n\t  // Roll back the start points.\r\n\t  patch.start1 -= prefix.length;\r\n\t  patch.start2 -= prefix.length;\r\n\t  // Extend the lengths.\r\n\t  patch.length1 += prefix.length + suffix.length;\r\n\t  patch.length2 += prefix.length + suffix.length;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Compute a list of patches to turn text1 into text2.\r\n\t * Use diffs if provided, otherwise compute it ourselves.\r\n\t * There are four ways to call this function, depending on what data is\r\n\t * available to the caller:\r\n\t * Method 1:\r\n\t * a = text1, b = text2\r\n\t * Method 2:\r\n\t * a = diffs\r\n\t * Method 3 (optimal):\r\n\t * a = text1, b = diffs\r\n\t * Method 4 (deprecated, use method 3):\r\n\t * a = text1, b = text2, c = diffs\r\n\t *\r\n\t * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n\t * Array of diff tuples for text1 to text2 (method 2).\r\n\t * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n\t * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n\t * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n\t * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n\t  var text1, diffs;\r\n\t  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n\t      typeof opt_c == 'undefined') {\r\n\t    // Method 1: text1, text2\r\n\t    // Compute diffs from text1 and text2.\r\n\t    text1 = /** @type {string} */(a);\r\n\t    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n\t    if (diffs.length > 2) {\r\n\t      this.diff_cleanupSemantic(diffs);\r\n\t      this.diff_cleanupEfficiency(diffs);\r\n\t    }\r\n\t  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n\t      typeof opt_c == 'undefined') {\r\n\t    // Method 2: diffs\r\n\t    // Compute text1 from diffs.\r\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n\t    text1 = this.diff_text1(diffs);\r\n\t  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n\t      typeof opt_c == 'undefined') {\r\n\t    // Method 3: text1, diffs\r\n\t    text1 = /** @type {string} */(a);\r\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n\t  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n\t      opt_c && typeof opt_c == 'object') {\r\n\t    // Method 4: text1, text2, diffs\r\n\t    // text2 is not used.\r\n\t    text1 = /** @type {string} */(a);\r\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n\t  } else {\r\n\t    throw new Error('Unknown call format to patch_make.');\r\n\t  }\r\n\t\r\n\t  if (diffs.length === 0) {\r\n\t    return [];  // Get rid of the null case.\r\n\t  }\r\n\t  var patches = [];\r\n\t  var patch = new diff_match_patch.patch_obj();\r\n\t  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n\t  var char_count1 = 0;  // Number of characters into the text1 string.\r\n\t  var char_count2 = 0;  // Number of characters into the text2 string.\r\n\t  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n\t  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n\t  // context info.\r\n\t  var prepatch_text = text1;\r\n\t  var postpatch_text = text1;\r\n\t  for (var x = 0; x < diffs.length; x++) {\r\n\t    var diff_type = diffs[x][0];\r\n\t    var diff_text = diffs[x][1];\r\n\t\r\n\t    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n\t      // A new patch starts here.\r\n\t      patch.start1 = char_count1;\r\n\t      patch.start2 = char_count2;\r\n\t    }\r\n\t\r\n\t    switch (diff_type) {\r\n\t      case DIFF_INSERT:\r\n\t        patch.diffs[patchDiffLength++] = diffs[x];\r\n\t        patch.length2 += diff_text.length;\r\n\t        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n\t                         postpatch_text.substring(char_count2);\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        patch.length1 += diff_text.length;\r\n\t        patch.diffs[patchDiffLength++] = diffs[x];\r\n\t        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n\t                         postpatch_text.substring(char_count2 +\r\n\t                             diff_text.length);\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n\t            patchDiffLength && diffs.length != x + 1) {\r\n\t          // Small equality inside a patch.\r\n\t          patch.diffs[patchDiffLength++] = diffs[x];\r\n\t          patch.length1 += diff_text.length;\r\n\t          patch.length2 += diff_text.length;\r\n\t        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n\t          // Time for a new patch.\r\n\t          if (patchDiffLength) {\r\n\t            this.patch_addContext_(patch, prepatch_text);\r\n\t            patches.push(patch);\r\n\t            patch = new diff_match_patch.patch_obj();\r\n\t            patchDiffLength = 0;\r\n\t            // Unlike Unidiff, our patch lists have a rolling context.\r\n\t            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n\t            // Update prepatch text & pos to reflect the application of the\r\n\t            // just completed patch.\r\n\t            prepatch_text = postpatch_text;\r\n\t            char_count1 = char_count2;\r\n\t          }\r\n\t        }\r\n\t        break;\r\n\t    }\r\n\t\r\n\t    // Update the current character count.\r\n\t    if (diff_type !== DIFF_INSERT) {\r\n\t      char_count1 += diff_text.length;\r\n\t    }\r\n\t    if (diff_type !== DIFF_DELETE) {\r\n\t      char_count2 += diff_text.length;\r\n\t    }\r\n\t  }\r\n\t  // Pick up the leftover patch if not empty.\r\n\t  if (patchDiffLength) {\r\n\t    this.patch_addContext_(patch, prepatch_text);\r\n\t    patches.push(patch);\r\n\t  }\r\n\t\r\n\t  return patches;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Given an array of patches, return another array that is identical.\r\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n\t  // Making deep copies is hard in JavaScript.\r\n\t  var patchesCopy = [];\r\n\t  for (var x = 0; x < patches.length; x++) {\r\n\t    var patch = patches[x];\r\n\t    var patchCopy = new diff_match_patch.patch_obj();\r\n\t    patchCopy.diffs = [];\r\n\t    for (var y = 0; y < patch.diffs.length; y++) {\r\n\t      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n\t    }\r\n\t    patchCopy.start1 = patch.start1;\r\n\t    patchCopy.start2 = patch.start2;\r\n\t    patchCopy.length1 = patch.length1;\r\n\t    patchCopy.length2 = patch.length2;\r\n\t    patchesCopy[x] = patchCopy;\r\n\t  }\r\n\t  return patchesCopy;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Merge a set of patches onto the text.  Return a patched text, as well\r\n\t * as a list of true/false values indicating which patches were applied.\r\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n\t * @param {string} text Old text.\r\n\t * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n\t *      new text and an array of boolean values.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n\t  if (patches.length == 0) {\r\n\t    return [text, []];\r\n\t  }\r\n\t\r\n\t  // Deep copy the patches so that no changes are made to originals.\r\n\t  patches = this.patch_deepCopy(patches);\r\n\t\r\n\t  var nullPadding = this.patch_addPadding(patches);\r\n\t  text = nullPadding + text + nullPadding;\r\n\t\r\n\t  this.patch_splitMax(patches);\r\n\t  // delta keeps track of the offset between the expected and actual location\r\n\t  // of the previous patch.  If there are patches expected at positions 10 and\r\n\t  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n\t  // has an effective expected position of 22.\r\n\t  var delta = 0;\r\n\t  var results = [];\r\n\t  for (var x = 0; x < patches.length; x++) {\r\n\t    var expected_loc = patches[x].start2 + delta;\r\n\t    var text1 = this.diff_text1(patches[x].diffs);\r\n\t    var start_loc;\r\n\t    var end_loc = -1;\r\n\t    if (text1.length > this.Match_MaxBits) {\r\n\t      // patch_splitMax will only provide an oversized pattern in the case of\r\n\t      // a monster delete.\r\n\t      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n\t                                  expected_loc);\r\n\t      if (start_loc != -1) {\r\n\t        end_loc = this.match_main(text,\r\n\t            text1.substring(text1.length - this.Match_MaxBits),\r\n\t            expected_loc + text1.length - this.Match_MaxBits);\r\n\t        if (end_loc == -1 || start_loc >= end_loc) {\r\n\t          // Can't find valid trailing context.  Drop this patch.\r\n\t          start_loc = -1;\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      start_loc = this.match_main(text, text1, expected_loc);\r\n\t    }\r\n\t    if (start_loc == -1) {\r\n\t      // No match found.  :(\r\n\t      results[x] = false;\r\n\t      // Subtract the delta for this failed patch from subsequent patches.\r\n\t      delta -= patches[x].length2 - patches[x].length1;\r\n\t    } else {\r\n\t      // Found a match.  :)\r\n\t      results[x] = true;\r\n\t      delta = start_loc - expected_loc;\r\n\t      var text2;\r\n\t      if (end_loc == -1) {\r\n\t        text2 = text.substring(start_loc, start_loc + text1.length);\r\n\t      } else {\r\n\t        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n\t      }\r\n\t      if (text1 == text2) {\r\n\t        // Perfect match, just shove the replacement text in.\r\n\t        text = text.substring(0, start_loc) +\r\n\t               this.diff_text2(patches[x].diffs) +\r\n\t               text.substring(start_loc + text1.length);\r\n\t      } else {\r\n\t        // Imperfect match.  Run a diff to get a framework of equivalent\r\n\t        // indices.\r\n\t        var diffs = this.diff_main(text1, text2, false);\r\n\t        if (text1.length > this.Match_MaxBits &&\r\n\t            this.diff_levenshtein(diffs) / text1.length >\r\n\t            this.Patch_DeleteThreshold) {\r\n\t          // The end points match, but the content is unacceptably bad.\r\n\t          results[x] = false;\r\n\t        } else {\r\n\t          this.diff_cleanupSemanticLossless(diffs);\r\n\t          var index1 = 0;\r\n\t          var index2;\r\n\t          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n\t            var mod = patches[x].diffs[y];\r\n\t            if (mod[0] !== DIFF_EQUAL) {\r\n\t              index2 = this.diff_xIndex(diffs, index1);\r\n\t            }\r\n\t            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n\t              text = text.substring(0, start_loc + index2) + mod[1] +\r\n\t                     text.substring(start_loc + index2);\r\n\t            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n\t              text = text.substring(0, start_loc + index2) +\r\n\t                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n\t                         index1 + mod[1].length));\r\n\t            }\r\n\t            if (mod[0] !== DIFF_DELETE) {\r\n\t              index1 += mod[1].length;\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t  // Strip the padding off.\r\n\t  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n\t  return [text, results];\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Add some padding on text start and end so that edges can match something.\r\n\t * Intended to be called only from within patch_apply.\r\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n\t * @return {string} The padding string added to each side.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n\t  var paddingLength = this.Patch_Margin;\r\n\t  var nullPadding = '';\r\n\t  for (var x = 1; x <= paddingLength; x++) {\r\n\t    nullPadding += String.fromCharCode(x);\r\n\t  }\r\n\t\r\n\t  // Bump all the patches forward.\r\n\t  for (var x = 0; x < patches.length; x++) {\r\n\t    patches[x].start1 += paddingLength;\r\n\t    patches[x].start2 += paddingLength;\r\n\t  }\r\n\t\r\n\t  // Add some padding on start of first diff.\r\n\t  var patch = patches[0];\r\n\t  var diffs = patch.diffs;\r\n\t  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n\t    // Add nullPadding equality.\r\n\t    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n\t    patch.start1 -= paddingLength;  // Should be 0.\r\n\t    patch.start2 -= paddingLength;  // Should be 0.\r\n\t    patch.length1 += paddingLength;\r\n\t    patch.length2 += paddingLength;\r\n\t  } else if (paddingLength > diffs[0][1].length) {\r\n\t    // Grow first equality.\r\n\t    var extraLength = paddingLength - diffs[0][1].length;\r\n\t    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n\t    patch.start1 -= extraLength;\r\n\t    patch.start2 -= extraLength;\r\n\t    patch.length1 += extraLength;\r\n\t    patch.length2 += extraLength;\r\n\t  }\r\n\t\r\n\t  // Add some padding on end of last diff.\r\n\t  patch = patches[patches.length - 1];\r\n\t  diffs = patch.diffs;\r\n\t  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n\t    // Add nullPadding equality.\r\n\t    diffs.push([DIFF_EQUAL, nullPadding]);\r\n\t    patch.length1 += paddingLength;\r\n\t    patch.length2 += paddingLength;\r\n\t  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n\t    // Grow last equality.\r\n\t    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n\t    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n\t    patch.length1 += extraLength;\r\n\t    patch.length2 += extraLength;\r\n\t  }\r\n\t\r\n\t  return nullPadding;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Look through the patches and break up any which are longer than the maximum\r\n\t * limit of the match algorithm.\r\n\t * Intended to be called only from within patch_apply.\r\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n\t  var patch_size = this.Match_MaxBits;\r\n\t  for (var x = 0; x < patches.length; x++) {\r\n\t    if (patches[x].length1 <= patch_size) {\r\n\t      continue;\r\n\t    }\r\n\t    var bigpatch = patches[x];\r\n\t    // Remove the big old patch.\r\n\t    patches.splice(x--, 1);\r\n\t    var start1 = bigpatch.start1;\r\n\t    var start2 = bigpatch.start2;\r\n\t    var precontext = '';\r\n\t    while (bigpatch.diffs.length !== 0) {\r\n\t      // Create one of several smaller patches.\r\n\t      var patch = new diff_match_patch.patch_obj();\r\n\t      var empty = true;\r\n\t      patch.start1 = start1 - precontext.length;\r\n\t      patch.start2 = start2 - precontext.length;\r\n\t      if (precontext !== '') {\r\n\t        patch.length1 = patch.length2 = precontext.length;\r\n\t        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n\t      }\r\n\t      while (bigpatch.diffs.length !== 0 &&\r\n\t             patch.length1 < patch_size - this.Patch_Margin) {\r\n\t        var diff_type = bigpatch.diffs[0][0];\r\n\t        var diff_text = bigpatch.diffs[0][1];\r\n\t        if (diff_type === DIFF_INSERT) {\r\n\t          // Insertions are harmless.\r\n\t          patch.length2 += diff_text.length;\r\n\t          start2 += diff_text.length;\r\n\t          patch.diffs.push(bigpatch.diffs.shift());\r\n\t          empty = false;\r\n\t        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n\t                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n\t                   diff_text.length > 2 * patch_size) {\r\n\t          // This is a large deletion.  Let it pass in one chunk.\r\n\t          patch.length1 += diff_text.length;\r\n\t          start1 += diff_text.length;\r\n\t          empty = false;\r\n\t          patch.diffs.push([diff_type, diff_text]);\r\n\t          bigpatch.diffs.shift();\r\n\t        } else {\r\n\t          // Deletion or equality.  Only take as much as we can stomach.\r\n\t          diff_text = diff_text.substring(0,\r\n\t              patch_size - patch.length1 - this.Patch_Margin);\r\n\t          patch.length1 += diff_text.length;\r\n\t          start1 += diff_text.length;\r\n\t          if (diff_type === DIFF_EQUAL) {\r\n\t            patch.length2 += diff_text.length;\r\n\t            start2 += diff_text.length;\r\n\t          } else {\r\n\t            empty = false;\r\n\t          }\r\n\t          patch.diffs.push([diff_type, diff_text]);\r\n\t          if (diff_text == bigpatch.diffs[0][1]) {\r\n\t            bigpatch.diffs.shift();\r\n\t          } else {\r\n\t            bigpatch.diffs[0][1] =\r\n\t                bigpatch.diffs[0][1].substring(diff_text.length);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      // Compute the head context for the next patch.\r\n\t      precontext = this.diff_text2(patch.diffs);\r\n\t      precontext =\r\n\t          precontext.substring(precontext.length - this.Patch_Margin);\r\n\t      // Append the end context for this patch.\r\n\t      var postcontext = this.diff_text1(bigpatch.diffs)\r\n\t                            .substring(0, this.Patch_Margin);\r\n\t      if (postcontext !== '') {\r\n\t        patch.length1 += postcontext.length;\r\n\t        patch.length2 += postcontext.length;\r\n\t        if (patch.diffs.length !== 0 &&\r\n\t            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n\t          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n\t        } else {\r\n\t          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n\t        }\r\n\t      }\r\n\t      if (!empty) {\r\n\t        patches.splice(++x, 0, patch);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Take a list of patches and return a textual representation.\r\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n\t * @return {string} Text representation of patches.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_toText = function(patches) {\r\n\t  var text = [];\r\n\t  for (var x = 0; x < patches.length; x++) {\r\n\t    text[x] = patches[x];\r\n\t  }\r\n\t  return text.join('');\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Parse a textual representation of patches and return a list of Patch objects.\r\n\t * @param {string} textline Text representation of patches.\r\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n\t * @throws {!Error} If invalid input.\r\n\t */\r\n\tdiff_match_patch.prototype.patch_fromText = function(textline) {\r\n\t  var patches = [];\r\n\t  if (!textline) {\r\n\t    return patches;\r\n\t  }\r\n\t  var text = textline.split('\\n');\r\n\t  var textPointer = 0;\r\n\t  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n\t  while (textPointer < text.length) {\r\n\t    var m = text[textPointer].match(patchHeader);\r\n\t    if (!m) {\r\n\t      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n\t    }\r\n\t    var patch = new diff_match_patch.patch_obj();\r\n\t    patches.push(patch);\r\n\t    patch.start1 = parseInt(m[1], 10);\r\n\t    if (m[2] === '') {\r\n\t      patch.start1--;\r\n\t      patch.length1 = 1;\r\n\t    } else if (m[2] == '0') {\r\n\t      patch.length1 = 0;\r\n\t    } else {\r\n\t      patch.start1--;\r\n\t      patch.length1 = parseInt(m[2], 10);\r\n\t    }\r\n\t\r\n\t    patch.start2 = parseInt(m[3], 10);\r\n\t    if (m[4] === '') {\r\n\t      patch.start2--;\r\n\t      patch.length2 = 1;\r\n\t    } else if (m[4] == '0') {\r\n\t      patch.length2 = 0;\r\n\t    } else {\r\n\t      patch.start2--;\r\n\t      patch.length2 = parseInt(m[4], 10);\r\n\t    }\r\n\t    textPointer++;\r\n\t\r\n\t    while (textPointer < text.length) {\r\n\t      var sign = text[textPointer].charAt(0);\r\n\t      try {\r\n\t        var line = decodeURI(text[textPointer].substring(1));\r\n\t      } catch (ex) {\r\n\t        // Malformed URI sequence.\r\n\t        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n\t      }\r\n\t      if (sign == '-') {\r\n\t        // Deletion.\r\n\t        patch.diffs.push([DIFF_DELETE, line]);\r\n\t      } else if (sign == '+') {\r\n\t        // Insertion.\r\n\t        patch.diffs.push([DIFF_INSERT, line]);\r\n\t      } else if (sign == ' ') {\r\n\t        // Minor equality.\r\n\t        patch.diffs.push([DIFF_EQUAL, line]);\r\n\t      } else if (sign == '@') {\r\n\t        // Start of next patch.\r\n\t        break;\r\n\t      } else if (sign === '') {\r\n\t        // Blank line?  Whatever.\r\n\t      } else {\r\n\t        // WTF?\r\n\t        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n\t      }\r\n\t      textPointer++;\r\n\t    }\r\n\t  }\r\n\t  return patches;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Class representing one patch operation.\r\n\t * @constructor\r\n\t */\r\n\tdiff_match_patch.patch_obj = function() {\r\n\t  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n\t  this.diffs = [];\r\n\t  /** @type {?number} */\r\n\t  this.start1 = null;\r\n\t  /** @type {?number} */\r\n\t  this.start2 = null;\r\n\t  /** @type {number} */\r\n\t  this.length1 = 0;\r\n\t  /** @type {number} */\r\n\t  this.length2 = 0;\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Emmulate GNU diff's format.\r\n\t * Header: @@ -382,8 +481,9 @@\r\n\t * Indicies are printed as 1-based, not 0-based.\r\n\t * @return {string} The GNU diff string.\r\n\t */\r\n\tdiff_match_patch.patch_obj.prototype.toString = function() {\r\n\t  var coords1, coords2;\r\n\t  if (this.length1 === 0) {\r\n\t    coords1 = this.start1 + ',0';\r\n\t  } else if (this.length1 == 1) {\r\n\t    coords1 = this.start1 + 1;\r\n\t  } else {\r\n\t    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n\t  }\r\n\t  if (this.length2 === 0) {\r\n\t    coords2 = this.start2 + ',0';\r\n\t  } else if (this.length2 == 1) {\r\n\t    coords2 = this.start2 + 1;\r\n\t  } else {\r\n\t    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n\t  }\r\n\t  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n\t  var op;\r\n\t  // Escape the body of the patch with %xx notation.\r\n\t  for (var x = 0; x < this.diffs.length; x++) {\r\n\t    switch (this.diffs[x][0]) {\r\n\t      case DIFF_INSERT:\r\n\t        op = '+';\r\n\t        break;\r\n\t      case DIFF_DELETE:\r\n\t        op = '-';\r\n\t        break;\r\n\t      case DIFF_EQUAL:\r\n\t        op = ' ';\r\n\t        break;\r\n\t    }\r\n\t    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n\t  }\r\n\t  return text.join('').replace(/%20/g, ' ');\r\n\t};\r\n\t\r\n\t\r\n\t// The following export code was added by @ForbesLindesay\r\n\tmodule.exports = diff_match_patch;\r\n\tmodule.exports['diff_match_patch'] = diff_match_patch;\r\n\tmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\n\tmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\n\tmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _text = __webpack_require__(10);\n\t\n\tvar _text2 = _interopRequireDefault(_text);\n\t\n\t__webpack_require__(11);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SuggestionsDirective =\n\t/* @ngInject */\n\tfunction SuggestionsDirective() {\n\t    _classCallCheck(this, SuggestionsDirective);\n\t\n\t    this.restrict = 'E';\n\t    this.replace = true;\n\t    this.templateUrl = 'suggestions-form.tpl.jade';\n\t    this.controller = function (Restangular, $filter) {\n\t        'ngInject';\n\t\n\t        var _this = this;\n\t\n\t        this.open = false;\n\t        this.text = _text2.default;\n\t        this.alert = {\n\t            show: false,\n\t            success: true\n\t        };\n\t\n\t        this.suggestion = {\n\t            type: 1,\n\t            userId: 1,\n\t            createdOn: $filter('date')(new Date(), 'yyyy-MM-d'),\n\t            text: ''\n\t        };\n\t\n\t        this.toggleForm = function () {\n\t            _this.open = !_this.open;\n\t        };\n\t\n\t        this.sentSuggestion = function () {\n\t            Restangular.all('suggestions').post(_this.suggestion).then(function (result) {\n\t                _this.suggestion.text = '';\n\t                _this.alert.show = true;\n\t            });\n\t        };\n\t\n\t        this.closeMessage = function () {\n\t            _this.alert.show = false;\n\t        };\n\t    };\n\t    this.controllerAs = 'ctrl';\n\t    this.bindToController = true;\n\t};\n\t\n\texports.default = function () {\n\t    return new SuggestionsDirective();\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tvar wellspeakText = {\n\t    title: 'WellSpeak',\n\t    source: {\n\t        random: 'Random Sentence',\n\t        custom: 'My Sentence',\n\t        source: 'GRAMMAR RULES',\n\t        placeholder: 'Choose a rule above',\n\t        selectPlaceholder: 'Select rule from the dictionary',\n\t        example: 'xample: '\n\t    },\n\t    recognizing: {\n\t        wait: 'counting result',\n\t        turnOn: 'and start to talk ',\n\t        speakNow: 'SPEAK NOW',\n\t        pronounciation: 'Your Pronounciation',\n\t        clickHere: 'Click Here',\n\t        missed: 'missed',\n\t        wrong: 'wrong'\n\t    },\n\t    sidebar: {\n\t        myProfile: 'My Profile',\n\t        myStat: 'My Statistics',\n\t        settings: 'Settings',\n\t        support: 'Support'\n\t    },\n\t    helperLayout: {\n\t        switcher: 'Random/Manual Sentence switcher',\n\t        pronunciation: ' Sentence for pronunciation appears here ',\n\t        check: 'Pronunciation results appear here ',\n\t        panel: 'Action panel',\n\t        volume: 'Click to listen to example ',\n\t        mic: 'Click to start talk'\n\t    },\n\t    appDisabled: {\n\t        mainText: 'We are sorry, but the service works only in Google Chrome.',\n\t        link: 'Please use Google Chrome to make your pronunciation better.',\n\t        download: 'Download'\n\t    },\n\t    suggestionsForm: {\n\t        leaveComent: 'Leave us a comment',\n\t        button: 'Send your ideas',\n\t        phrase: 'New phrase',\n\t        suggestion: 'Suggestion',\n\t        successMessage: 'Thank you for participation!',\n\t        errorMessage: 'Something went wrong. Please, try later.'\n\t    }\n\t};\n\t\n\texports.default = wellspeakText;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"suggestions-form.tpl.jade\";\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _speech = __webpack_require__(13);\n\t\n\tvar _speech2 = _interopRequireDefault(_speech);\n\t\n\tvar _header = __webpack_require__(86);\n\t\n\tvar _header2 = _interopRequireDefault(_header);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* @ngInject */\n\texports.default = angular.module('app.modules', [_speech2.default]).controller('NavbarController', _header2.default).name;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(14);\n\t\n\tvar _speech = __webpack_require__(20);\n\t\n\tvar _speech2 = _interopRequireDefault(_speech);\n\t\n\tvar _speech3 = __webpack_require__(23);\n\t\n\tvar _speech4 = _interopRequireDefault(_speech3);\n\t\n\tvar _speech5 = __webpack_require__(85);\n\t\n\tvar _speech6 = _interopRequireDefault(_speech5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/* @ngInject */\n\texports.default = angular.module('app.speech', []).config(_speech2.default).controller('SpeachModuleController', _speech4.default).factory('SpeachFactory', _speech6.default).name;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(19);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"static/png/logo.png\";\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"speech.tpl.jade\";\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"speech.src.tpl.jade\";\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"speech.src.random.tpl.jade\";\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"speech.src.custom.tpl.jade\";\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\texports.default = function ($stateProvider) {\n\t    'ngInject';\n\t\n\t    $stateProvider.state('speech', {\n\t        url: '/',\n\t        views: {\n\t            '': {\n\t                templateUrl: 'speech.tpl.jade',\n\t                controller: 'SpeachModuleController',\n\t                controllerAs: 'ctrl'\n\t            },\n\t            'header@speech': {\n\t                templateUrl: 'header.tpl.jade',\n\t                controller: 'NavbarController',\n\t                controllerAs: 'ctrl'\n\t            },\n\t            'source@speech': {\n\t                templateUrl: 'speech.src.tpl.jade'\n\t            }\n\t        }\n\t    });\n\t};\n\t\n\t__webpack_require__(21);\n\t\n\t__webpack_require__(22);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\tvar _speech = __webpack_require__(23);\n\t\n\tvar _speech2 = _interopRequireDefault(_speech);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t;\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"header.tpl.jade\";\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"sidebar.tpl.jade\";\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _text = __webpack_require__(10);\n\t\n\tvar _text2 = _interopRequireDefault(_text);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar SpeachModuleController = function () {\n\t    /* @ngInject */\n\t\n\t    function SpeachModuleController($scope, SpeachFactory) {\n\t        _classCallCheck(this, SpeachModuleController);\n\t\n\t        this.$scope = $scope;\n\t        this.text = _text2.default;\n\t        this.SpeachFactory = SpeachFactory;\n\t        this.helper = false;\n\t        this.explanation = false;\n\t        this.WatsonSpeech = __webpack_require__(24);\n\t        this.loadingResults = false;\n\t        this.source = 'random';\n\t\n\t        this.phrases = [];\n\t        this.activePhraseIndex = null;\n\t\n\t        this.recognizing = false;\n\t        this.listening = false;\n\t\n\t        this.hasResults = false;\n\t        this.userResult = '';\n\t        this.userResultDiffs = {};\n\t\n\t        this.speechDefined = true;\n\t    }\n\t\n\t    _createClass(SpeachModuleController, [{\n\t        key: 'listen',\n\t        value: function listen() {\n\t            var _this = this;\n\t\n\t            var audio = this.WatsonSpeech.TextToSpeech.synthesize({\n\t                text: this.userSource,\n\t                token: this.SpeachFactory.tokenTTS\n\t            });\n\t\n\t            this.listening = true;\n\t            audio.addEventListener('ended', function () {\n\t                _this.listening = false;\n\t                _this.$scope.$apply();\n\t            });\n\t        }\n\t    }, {\n\t        key: 'setFirstRule',\n\t        value: function setFirstRule() {\n\t            this.selectedRule = this.SpeachFactory.rules[0];\n\t            this.changeRule();\n\t        }\n\t    }, {\n\t        key: 'changeRule',\n\t        value: function changeRule() {\n\t            this.cleanResults();\n\t            if (this.selectedRule) {\n\t                this.phrases = [];\n\t                this.getNewPhrase();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getNewPhrase',\n\t        value: function getNewPhrase() {\n\t            var ctrl = this;\n\t            this.SpeachFactory.getNewPhrase(this.selectedRule.Id).then(function (phrase) {\n\t                ctrl.phrases.push(phrase);\n\t                ctrl.activePhraseIndex = ctrl.phrases.length - 1;\n\t            });\n\t        }\n\t    }, {\n\t        key: 'cleanResults',\n\t        value: function cleanResults() {\n\t            this.userResult = '';\n\t            this.hasResults = false;\n\t        }\n\t    }, {\n\t        key: 'goBack',\n\t        value: function goBack() {\n\t            if (this.activePhraseIndex > 0) {\n\t                this.activePhraseIndex = --this.activePhraseIndex;\n\t            }\n\t            this.cleanResults();\n\t        }\n\t    }, {\n\t        key: 'goForward',\n\t        value: function goForward() {\n\t            if (this.activePhraseIndex < this.phrases.length - 1) {\n\t                this.activePhraseIndex = ++this.activePhraseIndex;\n\t            } else {\n\t                this.getNewPhrase();\n\t            }\n\t            this.cleanResults();\n\t        }\n\t    }, {\n\t        key: 'sourceType',\n\t        value: function sourceType(type) {\n\t            this.source = type;\n\t            this.cleanResults();\n\t        }\n\t    }, {\n\t        key: 'isActiveSource',\n\t        value: function isActiveSource(source) {\n\t            return this.source === source;\n\t        }\n\t    }, {\n\t        key: 'setResult',\n\t        value: function setResult(data) {\n\t            if (data && typeof data === 'string') {\n\t                this.hasResults = true;\n\t                this.userResult = data;\n\t            } else {\n\t                this.hasResults = false;\n\t            }\n\t            this.recognizing = false;\n\t            this.loadingResults = false;\n\t            this.$scope.$apply();\n\t        }\n\t    }, {\n\t        key: 'startButton',\n\t        value: function startButton() {\n\t            this.cleanResults();\n\t            if (this.recognizing) {\n\t                this.recognizing = false;\n\t                this.loadingResults = true;\n\t                return;\n\t            }\n\t            this.recognizing = true;\n\t            this.WatsonSpeech.SpeechToText.recognizeMicrophone({\n\t                token: this.SpeachFactory.tokenSTT,\n\t                continuous: false,\n\t                keepMicrophone: navigator.userAgent.indexOf('Firefox') > 0\n\t            }).promise().then(this.setResult.bind(this)).catch(function () {\n\t                console.log('error');\n\t            });\n\t        }\n\t    }, {\n\t        key: 'toggleHelper',\n\t        value: function toggleHelper() {\n\t            this.helper = !this.helper;\n\t        }\n\t    }, {\n\t        key: 'toggleExplanation',\n\t        value: function toggleExplanation() {\n\t            this.explanation = !this.explanation;\n\t        }\n\t    }, {\n\t        key: 'isHappy',\n\t        value: function isHappy() {\n\t            return this.userResultDiffs.percentage >= 96;\n\t        }\n\t    }, {\n\t        key: 'isIndifferent',\n\t        value: function isIndifferent() {\n\t            return this.userResultDiffs.percentage > 76 && this.userResultDiffs.percentage < 95;\n\t        }\n\t    }, {\n\t        key: 'isSad',\n\t        value: function isSad() {\n\t            return this.userResultDiffs.percentage <= 75;\n\t        }\n\t    }, {\n\t        key: 'sourceTemplate',\n\t        get: function get() {\n\t            return 'speech.src.' + this.source + '.tpl.jade';\n\t        }\n\t    }, {\n\t        key: 'rules',\n\t        get: function get() {\n\t            return this.SpeachFactory.rules;\n\t        }\n\t    }, {\n\t        key: 'ruleTypes',\n\t        get: function get() {\n\t            return this.SpeachFactory.ruleTypes;\n\t        }\n\t    }, {\n\t        key: 'ruleExample',\n\t        get: function get() {\n\t            var _this2 = this;\n\t\n\t            return _.find(this.SpeachFactory.rulesExamples, function (example) {\n\t                return example.RuleId === _this2.selectedRule.Id;\n\t            }).ShortExample;\n\t        }\n\t    }, {\n\t        key: 'disabledBack',\n\t        get: function get() {\n\t            return !this.selectedRule || this.activePhraseIndex < 1;\n\t        }\n\t    }, {\n\t        key: 'userSource',\n\t        get: function get() {\n\t            return this.isActiveSource('random') && this.phrases.length ? this.phrases[this.activePhraseIndex].Phrase : this.userSentence;\n\t        }\n\t    }]);\n\t\n\t    return SpeachModuleController;\n\t}();\n\t\n\t;\n\t\n\texports.default = SpeachModuleController;\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * IBM Watson Speech JavaScript SDK\n\t *\n\t * Top-level module includes the version, a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) pollyfill, and both of the speech libraries.\n\t *\n\t * If using a bundler such as browserify, you may optionally include sub-modules directly to reduce the size of the final bundle\n\t *\n\t * @module watson-speech\n\t */\n\t\n\t/**\n\t * Release version\n\t *\n\t * envify automatically rewrites this during the release process\n\t */\n\texports.version = process.env.TRAVIS_BRANCH;\n\t\n\t/**\n\t *\n\t * @see module:watson-speech/speech-to-text\n\t */\n\texports.SpeechToText = __webpack_require__(26);\n\t\n\t/**\n\t *\n\t * @see module:watson-speech/text-to-speech\n\t */\n\texports.TextToSpeech = __webpack_require__(82);\n\t\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t  try {\n\t    cachedSetTimeout = setTimeout;\n\t  } catch (e) {\n\t    cachedSetTimeout = function () {\n\t      throw new Error('setTimeout is not defined');\n\t    }\n\t  }\n\t  try {\n\t    cachedClearTimeout = clearTimeout;\n\t  } catch (e) {\n\t    cachedClearTimeout = function () {\n\t      throw new Error('clearTimeout is not defined');\n\t    }\n\t  }\n\t} ())\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t/**\n\t * IBM Watson Speech to Text JavaScript SDK\n\t *\n\t * The primary methods for interacting with the Speech to Text JS SDK are:\n\t *  * `recognizeMicrophone()` for live microphone input\n\t *  * `recognizeElement()` for transcribing `<audio>` and `<video>` elements\n\t *  * `recognizeFile()` for file `<input>`'s and other data sources\n\t *\n\t * However, the underlying streams and utils that they use are also provided for advanced usage.\n\t *\n\t * @module watson-speech/speech-to-text\n\t */\n\t\n\tmodule.exports = {\n\t\n\t  // \"easy-mode\" API\n\t  /**\n\t   * @see module:watson-speech/speech-to-text/recognize-microphone\n\t   */\n\t  recognizeMicrophone: __webpack_require__(31),\n\t\n\t  /**\n\t   * @see module:watson-speech/speech-to-text/recognize-blob\n\t   */\n\t  recognizeFile: __webpack_require__(77),\n\t\n\t  /**\n\t   * @see module:watson-speech/speech-to-text/get-models\n\t   */\n\t  getModels: __webpack_require__(81),\n\t\n\t\n\t  // individual components to build more customized solutions\n\t  /**\n\t   * @see WebAudioL16Stream\n\t   */\n\t  WebAudioL16Stream: __webpack_require__(67),\n\t\n\t  /**\n\t   * @see RecognizeStream\n\t   */\n\t  RecognizeStream: __webpack_require__(56),\n\t\n\t  /**\n\t   * @see FilePlayer\n\t   */\n\t  FilePlayer: __webpack_require__(79),\n\t\n\t  /**\n\t   * @see FormatStream\n\t   */\n\t  FormatStream: __webpack_require__(68),\n\t\n\t  /**\n\t   * @see TimingStream\n\t   */\n\t  TimingStream: __webpack_require__(80),\n\t\n\t  /**\n\t   * @see WritableElementStream\n\t   */\n\t  WritableElementStream: __webpack_require__(76),\n\t\n\t  // external components exposed for convenience\n\t\n\t  /**\n\t   * @see https://www.npmjs.com/package/get-user-media-promise\n\t   */\n\t  getUserMedia: __webpack_require__(32),\n\t\n\t  /**\n\t   * @see https://www.npmjs.com/package/microphone-stream\n\t   */\n\t  MicrophoneStream: __webpack_require__(33),\n\t\n\t  /**\n\t   * @see https://nodejs.org/api/buffer.html\n\t   */\n\t  Buffer: Buffer\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(28)\n\tvar ieee754 = __webpack_require__(29)\n\tvar isArray = __webpack_require__(30)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this.length = 0\n\t    this.parent = undefined\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t} else {\n\t  // pre-set for values that may exist in the future\n\t  Buffer.prototype.length = undefined\n\t  Buffer.prototype.parent = undefined\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\tvar getUserMedia = __webpack_require__(32);\n\tvar MicrophoneStream = __webpack_require__(33);\n\tvar RecognizeStream = __webpack_require__(56);\n\tvar L16 = __webpack_require__(67);\n\tvar FormatStream = __webpack_require__(68);\n\tvar assign = __webpack_require__(69)();\n\tvar WritableElementStream = __webpack_require__(76);\n\tvar Writable = __webpack_require__(34).Writable;\n\t\n\tvar preservedMicStream;\n\tvar bitBucket = new Writable({\n\t  write: function(chunk, encoding, callback) {\n\t    // when the keepMicrophone option is enabled, unused audio data is sent here so that it isn't buffered by other streams.\n\t    callback();\n\t  },\n\t  objectMode: true, // can still accept strings/buffers\n\t  decodeStrings: false\n\t});\n\t\n\t/**\n\t * @module watson-speech/speech-to-text/recognize-microphone\n\t */\n\t\n\t/**\n\t * Create and return a RecognizeStream sourcing audio from the user's microphone\n\t *\n\t * @param {Object} options - Also passed to {RecognizeStream}, and {FormatStream} when applicable\n\t * @param {String} options.token - Auth Token - see https://github.com/watson-developer-cloud/node-sdk#authorization\n\t * @param {Boolean} [options.format=true] - pipe the text through a {FormatStream} which performs light formatting. Also controls smart_formatting option unless explicitly set.\n\t * @param {Boolean} [options.keepMicrophone=false] - keeps an internal reference to the microphone stream to reuse in subsequent calls (prevents multiple permissions dialogs in firefox)\n\t * @param {String|DOMElement} [options.outputElement] pipe the text to a WriteableElementStream targeting the specified element. Also defaults objectMode to true to enable interim results.\n\t *\n\t * @returns {RecognizeStream|FormatStream}\n\t */\n\tmodule.exports = function recognizeMicrophone(options) {\n\t  if (!options || !options.token) {\n\t    throw new Error('WatsonSpeechToText: missing required parameter: opts.token');\n\t  }\n\t\n\t  // the WritableElementStream works best in objectMode\n\t  if (options.outputElement && options.objectMode !== false) {\n\t    options.objectMode = true;\n\t  }\n\t\n\t  // default format to true (capitals and periods)\n\t  // default smart_formatting to options.format value (dates, currency, etc.)\n\t  options.format = (options.format !== false);\n\t  if (typeof options.smart_formatting === 'undefined') {\n\t    options.smart_formatting = options.format;\n\t  }\n\t\n\t  // we don't want the readable stream to have objectMode on the input even if we're setting it for the output\n\t  var rsOpts = assign({}, options);\n\t  rsOpts.readableObjectMode = options.objectMode;\n\t  rsOpts['content-type'] = 'audio/l16;rate=16000';\n\t  delete rsOpts.objectMode;\n\t\n\t  var recognizeStream = new RecognizeStream(rsOpts);\n\t\n\t  var keepMic = options.keepMicrophone;\n\t  var getMicStream;\n\t  if (keepMic && preservedMicStream) {\n\t    preservedMicStream.unpipe(bitBucket);\n\t    getMicStream = Promise.resolve(preservedMicStream);\n\t  } else {\n\t    getMicStream = getUserMedia({video: false, audio: true}).then(function(mic) {\n\t      var micStream = new MicrophoneStream(mic, {\n\t        objectMode: true,\n\t        bufferSize: options.bufferSize\n\t      });\n\t      if (keepMic) {\n\t        preservedMicStream = micStream;\n\t      }\n\t      return Promise.resolve(micStream);\n\t    });\n\t  }\n\t\n\t  // set up the output first so that we have a place to emit errors\n\t  // if there's trouble with the input stream\n\t  var stream = recognizeStream;\n\t  if (options.format) {\n\t    stream = stream.pipe(new FormatStream(options));\n\t    stream.stop = recognizeStream.stop.bind(recognizeStream);\n\t  }\n\t\n\t  if (options.outputElement) {\n\t    stream.pipe(new WritableElementStream(options));\n\t  }\n\t\n\t  getMicStream.catch(function(err) {\n\t    stream.emit('error', err);\n\t  });\n\t\n\t  getMicStream.then(function(micStream) {\n\t    var l16Stream = new L16({writableObjectMode: true});\n\t\n\t    micStream\n\t      .pipe(l16Stream)\n\t      .pipe(recognizeStream);\n\t\n\t    /**\n\t     * unpipes the mic stream to prevent any more audio from being sent over the wire\n\t     * temporarily re-pipes it to the bitBucket (basically /dev/null)  becuse\n\t     * otherwise it will buffer the audio from in between calls and prepend it to the next one\n\t     *\n\t     * @private\n\t     */\n\t    function end() {\n\t      micStream.unpipe(l16Stream);\n\t      micStream.pipe(bitBucket);\n\t      l16Stream.end();\n\t    }\n\t    // trigger on both stop and end events:\n\t    // stop will not fire when a stream ends due to a timeout or having continuous: false\n\t    // but when stop does fire, we want to honor it immediately\n\t    // end will always fire, but it may take a few moments after stop\n\t    if (keepMic) {\n\t      recognizeStream.on('end', end);\n\t      recognizeStream.on('stop', end);\n\t    } else {\n\t      recognizeStream.on('end', micStream.stop.bind(micStream));\n\t      recognizeStream.on('stop', micStream.stop.bind(micStream));\n\t    }\n\t\n\t  }).catch(recognizeStream.emit.bind(recognizeStream, 'error'));\n\t\n\t\n\t  return stream;\n\t};\n\t\n\t\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// loosely based on example code at https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n\t(function (root) {\n\t  'use strict';\n\t\n\t  /**\n\t   * Error thrown when any required feature is missing (Promises, navigator, getUserMedia)\n\t   * @constructor\n\t   */\n\t  function NotSupportedError() {\n\t    this.name = 'NotSupportedError';\n\t    this.message = 'getUserMedia is not implemented in this browser';\n\t  }\n\t  NotSupportedError.prototype = Error.prototype;\n\t\n\t  /**\n\t   * Fake Promise instance that behaves like a Promise except that it always rejects with a NotSupportedError.\n\t   * Used for situations where there is no global Promise constructor.\n\t   *\n\t   * The message will report that the getUserMedia API is not available.\n\t   * This is technically true because every browser that supports getUserMedia also supports promises.\n\t   **\n\t   * @see http://caniuse.com/#feat=stream\n\t   * @see http://caniuse.com/#feat=promises\n\t   * @constructor\n\t   */\n\t  function FakePromise() {\n\t    // make it chainable like a real promise\n\t    this.then = function() {\n\t      return this;\n\t    };\n\t\n\t    // but always reject with an error\n\t    var err = new NotSupportedError();\n\t    this.catch = function(cb) {\n\t      setTimeout(function () {\n\t        cb(err);\n\t      });\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Wrapper for navigator.mediaDevices.getUserMedia.\n\t   * Always returns a Promise or Promise-like object, even in environments without a global Promise constructor\n\t   *\n\t   * @stream https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n\t   *\n\t   * @param {Object} constraints - must include one or both of audio/video along with optional details for video\n\t   * @param {Boolean} [constraints.audio] - include audio data in the stream\n\t   * @param {Boolean|Object} [constraints.video] - include video data in the stream. May be a boolean or an object with additional constraints, see\n\t   * @returns {Promise<MediaStream>} a promise that resolves to a MediaStream object\n\t     */\n\t  function getUserMedia(constraints) {\n\t    // ensure that Promises are supported and we have a navigator object\n\t    if (typeof Promise === 'undefined') {\n\t      return new FakePromise();\n\t    }\n\t\n\t    // Try the more modern, promise-based MediaDevices API first\n\t    //https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n\t    if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n\t      return navigator.mediaDevices.getUserMedia(constraints);\n\t    }\n\t\n\t    // fall back to the older method second, wrap it in a promise.\n\t    return new Promise(function(resolve, reject) {\n\t      // if navigator doesn't exist, then we can't use the getUserMedia API. (And probably aren't even in a browser.)\n\t      // assuming it does, try getUserMedia and then all of the prefixed versions\n\t      var gum = navigator && navigator.getUserMedia || navigator.webkitGetUserMedia ||  navigator.mozGetUserMedia || navigator.msGetUserMedia;\n\t      if (!gum) {\n\t        return reject(new NotSupportedError())\n\t      }\n\t      gum.call(navigator, constraints, resolve, reject);\n\t    });\n\t  }\n\t\n\t  getUserMedia.NotSupportedError = NotSupportedError;\n\t\n\t  // UMD, loosely based on https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return getUserMedia;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node. Does not work with strict CommonJS, but\n\t    // only CommonJS-like enviroments that support module.exports,\n\t    // like Node.\n\t    module.exports = getUserMedia;\n\t  } else {\n\t    // Browser globals\n\t    // pollyfill the MediaDevices API if it does not exist.\n\t    root.nagivator.mediaDevices = root.navigator.mediaDevices || {};\n\t    root.nagivator.mediaDevices.getUserMedia = root.nagivator.mediaDevices.getUserMedia || getUserMedia;\n\t  }\n\t}(this));\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict';\n\tvar Readable = __webpack_require__(34).Readable;\n\tvar util = __webpack_require__(54);\n\t\n\t/**\n\t * Turns a MediaStream object (from getUserMedia) into a Node.js Readable stream and optionally converts the audio to Buffers\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia\n\t *\n\t * @param {MediaStream} stream https://developer.mozilla.org/en-US/docs/Web/API/MediaStream\n\t * @param {Object} [opts] options\n\t * @param {Boolean} [opts.objectMode=false] Puts the stream into ObjectMode where it emits AudioBuffers instead of Buffers - see https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer\n\t * @param {Number|null} [opts.bufferSize=null] https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n\t * @constructor\n\t */\n\tfunction MicrophoneStream(stream, opts) {\n\t  // \"It is recommended for authors to not specify this buffer size and allow the implementation to pick a good\n\t  // buffer size to balance between latency and audio quality.\"\n\t  // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n\t  // however, webkitAudioContext (safari) requires it to be set'\n\t  // Possible values: null, 256, 512, 1024, 2048, 4096, 8192, 16384\n\t  var bufferSize = (typeof window.AudioContext === 'undefined' ? 4096 : null);\n\t  opts = opts || {};\n\t\n\t  bufferSize = opts.bufferSize || bufferSize;\n\t\n\t  // We can only emit one channel's worth of audio, so only one input. (Who has multiple microphones anyways?)\n\t  var inputChannels = 1;\n\t\n\t  // we shouldn't need any output channels (going back to the browser), but chrome is buggy and won't give us any audio without one\n\t  var outputChannels = 1;\n\t\n\t  Readable.call(this, opts);\n\t\n\t  var self = this;\n\t  var recording = true;\n\t\n\t  /**\n\t   * Convert and emit the raw audio data\n\t   * @see https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode/onaudioprocess\n\t   * @param {AudioProcessingEvent} e https://developer.mozilla.org/en-US/docs/Web/API/AudioProcessingEvent\n\t   */\n\t  function recorderProcess(e) {\n\t    // onaudioprocess can be called at least once after we've stopped\n\t    if (recording) {\n\t      self.push(opts.objectMode ? e.inputBuffer : new Buffer(e.inputBuffer.getChannelData(0)));\n\t    }\n\t  }\n\t\n\t  var AudioContext = window.AudioContext || window.webkitAudioContext;\n\t  var context = new AudioContext();\n\t  var audioInput = context.createMediaStreamSource(stream);\n\t  var recorder = context.createScriptProcessor(bufferSize, inputChannels, outputChannels);\n\t\n\t  recorder.onaudioprocess = recorderProcess;\n\t\n\t  audioInput.connect(recorder);\n\t\n\t  // other half of workaround for chrome bugs\n\t  recorder.connect(context.destination);\n\t\n\t  this.stop = function() {\n\t    if (context.state === 'closed') {\n\t      return;\n\t    }\n\t    try {\n\t      stream.getTracks()[0].stop();\n\t    } catch (ex) {\n\t      // This fails in some older versions of chrome. Nothing we can do about it.\n\t    }\n\t    recorder.disconnect();\n\t    audioInput.disconnect();\n\t    try {\n\t      context.close(); // returns a promise;\n\t    } catch (ex) {\n\t      // this can also fail in older versions of chrome\n\t    }\n\t    recording = false;\n\t    self.push(null);\n\t    self.emit('close');\n\t  };\n\t\n\t  process.nextTick(function() {\n\t    self.emit('format', {\n\t      channels: 1,\n\t      bitDepth: 32,\n\t      sampleRate: context.sampleRate,\n\t      signed: true,\n\t      float: true\n\t    });\n\t  });\n\t}\n\tutil.inherits(MicrophoneStream, Readable);\n\t\n\tMicrophoneStream.prototype._read = function(/* bytes */) {\n\t  // no-op, (flow-control doesn't really work on sound)\n\t};\n\t\n\t/**\n\t * Converts a Buffer back into the raw Float32Array format that browsers use.\n\t * Note: this is just a new DataView for the same underlying buffer -\n\t * the actual audio data is not copied or changed here.\n\t *\n\t * @param {Buffer} chunk node-style buffer of audio data from a 'data' event or read() call\n\t * @return {Float32Array} raw 32-bit float data view of audio data\n\t */\n\tMicrophoneStream.toRaw = function toFloat32(chunk) {\n\t  return new Float32Array(chunk.buffer);\n\t};\n\t\n\tmodule.exports = MicrophoneStream;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer, __webpack_require__(25)))\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tmodule.exports = Stream;\n\t\n\tvar EE = __webpack_require__(35).EventEmitter;\n\tvar inherits = __webpack_require__(36);\n\t\n\tinherits(Stream, EE);\n\tStream.Readable = __webpack_require__(37);\n\tStream.Writable = __webpack_require__(50);\n\tStream.Duplex = __webpack_require__(51);\n\tStream.Transform = __webpack_require__(52);\n\tStream.PassThrough = __webpack_require__(53);\n\t\n\t// Backwards-compat with node 0.4.x\n\tStream.Stream = Stream;\n\t\n\t\n\t\n\t// old-style streams.  Note that the pipe method (the only relevant\n\t// part of this class) is overridden in the Readable class.\n\t\n\tfunction Stream() {\n\t  EE.call(this);\n\t}\n\t\n\tStream.prototype.pipe = function(dest, options) {\n\t  var source = this;\n\t\n\t  function ondata(chunk) {\n\t    if (dest.writable) {\n\t      if (false === dest.write(chunk) && source.pause) {\n\t        source.pause();\n\t      }\n\t    }\n\t  }\n\t\n\t  source.on('data', ondata);\n\t\n\t  function ondrain() {\n\t    if (source.readable && source.resume) {\n\t      source.resume();\n\t    }\n\t  }\n\t\n\t  dest.on('drain', ondrain);\n\t\n\t  // If the 'end' option is not supplied, dest.end() will be called when\n\t  // source gets the 'end' or 'close' events.  Only dest.end() once.\n\t  if (!dest._isStdio && (!options || options.end !== false)) {\n\t    source.on('end', onend);\n\t    source.on('close', onclose);\n\t  }\n\t\n\t  var didOnEnd = false;\n\t  function onend() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    dest.end();\n\t  }\n\t\n\t\n\t  function onclose() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    if (typeof dest.destroy === 'function') dest.destroy();\n\t  }\n\t\n\t  // don't leave dangling pipes when there are errors.\n\t  function onerror(er) {\n\t    cleanup();\n\t    if (EE.listenerCount(this, 'error') === 0) {\n\t      throw er; // Unhandled stream error in pipe.\n\t    }\n\t  }\n\t\n\t  source.on('error', onerror);\n\t  dest.on('error', onerror);\n\t\n\t  // remove all the event listeners that were added.\n\t  function cleanup() {\n\t    source.removeListener('data', ondata);\n\t    dest.removeListener('drain', ondrain);\n\t\n\t    source.removeListener('end', onend);\n\t    source.removeListener('close', onclose);\n\t\n\t    source.removeListener('error', onerror);\n\t    dest.removeListener('error', onerror);\n\t\n\t    source.removeListener('end', cleanup);\n\t    source.removeListener('close', cleanup);\n\t\n\t    dest.removeListener('close', cleanup);\n\t  }\n\t\n\t  source.on('end', cleanup);\n\t  source.on('close', cleanup);\n\t\n\t  dest.on('close', cleanup);\n\t\n\t  dest.emit('pipe', source);\n\t\n\t  // Allow for unix-like usage: A.pipe(B).pipe(C)\n\t  return dest;\n\t};\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){\n\t  try {\n\t    return __webpack_require__(34); // hack to fix a circular dependency issue when used with browserify\n\t  } catch(_){}\n\t}());\n\texports = module.exports = __webpack_require__(38);\n\texports.Stream = Stream || exports;\n\texports.Readable = exports;\n\texports.Writable = __webpack_require__(44);\n\texports.Duplex = __webpack_require__(43);\n\texports.Transform = __webpack_require__(48);\n\texports.PassThrough = __webpack_require__(49);\n\t\n\tif (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {\n\t  module.exports = Stream;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tmodule.exports = Readable;\n\t\n\t/*<replacement>*/\n\tvar processNextTick = __webpack_require__(39);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar isArray = __webpack_require__(30);\n\t/*</replacement>*/\n\t\n\tReadable.ReadableState = ReadableState;\n\t\n\t/*<replacement>*/\n\tvar EE = __webpack_require__(35).EventEmitter;\n\t\n\tvar EElistenerCount = function (emitter, type) {\n\t  return emitter.listeners(type).length;\n\t};\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar Stream;\n\t(function () {\n\t  try {\n\t    Stream = __webpack_require__(34);\n\t  } catch (_) {} finally {\n\t    if (!Stream) Stream = __webpack_require__(35).EventEmitter;\n\t  }\n\t})();\n\t/*</replacement>*/\n\t\n\tvar Buffer = __webpack_require__(27).Buffer;\n\t/*<replacement>*/\n\tvar bufferShim = __webpack_require__(40);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(41);\n\tutil.inherits = __webpack_require__(36);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar debugUtil = __webpack_require__(42);\n\tvar debug = void 0;\n\tif (debugUtil && debugUtil.debuglog) {\n\t  debug = debugUtil.debuglog('stream');\n\t} else {\n\t  debug = function () {};\n\t}\n\t/*</replacement>*/\n\t\n\tvar StringDecoder;\n\t\n\tutil.inherits(Readable, Stream);\n\t\n\tvar hasPrependListener = typeof EE.prototype.prependListener === 'function';\n\t\n\tfunction prependListener(emitter, event, fn) {\n\t  if (hasPrependListener) return emitter.prependListener(event, fn);\n\t\n\t  // This is a brutally ugly hack to make sure that our error handler\n\t  // is attached before any userland ones.  NEVER DO THIS. This is here\n\t  // only because this code needs to continue to work with older versions\n\t  // of Node.js that do not include the prependListener() method. The goal\n\t  // is to eventually remove this hack.\n\t  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n\t}\n\t\n\tvar Duplex;\n\tfunction ReadableState(options, stream) {\n\t  Duplex = Duplex || __webpack_require__(43);\n\t\n\t  options = options || {};\n\t\n\t  // object stream flag. Used to make read(n) ignore n and to\n\t  // make all the buffer merging and length checks go away\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\t\n\t  // the point at which it stops calling _read() to fill the buffer\n\t  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\t\n\t  this.buffer = [];\n\t  this.length = 0;\n\t  this.pipes = null;\n\t  this.pipesCount = 0;\n\t  this.flowing = null;\n\t  this.ended = false;\n\t  this.endEmitted = false;\n\t  this.reading = false;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // whenever we return null, then we set a flag to say\n\t  // that we're awaiting a 'readable' event emission.\n\t  this.needReadable = false;\n\t  this.emittedReadable = false;\n\t  this.readableListening = false;\n\t  this.resumeScheduled = false;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // when piping, we only care about 'readable' events that happen\n\t  // after read()ing all the bytes and not getting any pushback.\n\t  this.ranOut = false;\n\t\n\t  // the number of writers that are awaiting a drain event in .pipe()s\n\t  this.awaitDrain = 0;\n\t\n\t  // if true, a maybeReadMore has been scheduled\n\t  this.readingMore = false;\n\t\n\t  this.decoder = null;\n\t  this.encoding = null;\n\t  if (options.encoding) {\n\t    if (!StringDecoder) StringDecoder = __webpack_require__(47).StringDecoder;\n\t    this.decoder = new StringDecoder(options.encoding);\n\t    this.encoding = options.encoding;\n\t  }\n\t}\n\t\n\tvar Duplex;\n\tfunction Readable(options) {\n\t  Duplex = Duplex || __webpack_require__(43);\n\t\n\t  if (!(this instanceof Readable)) return new Readable(options);\n\t\n\t  this._readableState = new ReadableState(options, this);\n\t\n\t  // legacy\n\t  this.readable = true;\n\t\n\t  if (options && typeof options.read === 'function') this._read = options.read;\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Manually shove something into the read() buffer.\n\t// This returns true if the highWaterMark has not been hit yet,\n\t// similar to how Writable.write() returns true if you should\n\t// write() some more.\n\tReadable.prototype.push = function (chunk, encoding) {\n\t  var state = this._readableState;\n\t\n\t  if (!state.objectMode && typeof chunk === 'string') {\n\t    encoding = encoding || state.defaultEncoding;\n\t    if (encoding !== state.encoding) {\n\t      chunk = bufferShim.from(chunk, encoding);\n\t      encoding = '';\n\t    }\n\t  }\n\t\n\t  return readableAddChunk(this, state, chunk, encoding, false);\n\t};\n\t\n\t// Unshift should *always* be something directly out of read()\n\tReadable.prototype.unshift = function (chunk) {\n\t  var state = this._readableState;\n\t  return readableAddChunk(this, state, chunk, '', true);\n\t};\n\t\n\tReadable.prototype.isPaused = function () {\n\t  return this._readableState.flowing === false;\n\t};\n\t\n\tfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n\t  var er = chunkInvalid(state, chunk);\n\t  if (er) {\n\t    stream.emit('error', er);\n\t  } else if (chunk === null) {\n\t    state.reading = false;\n\t    onEofChunk(stream, state);\n\t  } else if (state.objectMode || chunk && chunk.length > 0) {\n\t    if (state.ended && !addToFront) {\n\t      var e = new Error('stream.push() after EOF');\n\t      stream.emit('error', e);\n\t    } else if (state.endEmitted && addToFront) {\n\t      var _e = new Error('stream.unshift() after end event');\n\t      stream.emit('error', _e);\n\t    } else {\n\t      var skipAdd;\n\t      if (state.decoder && !addToFront && !encoding) {\n\t        chunk = state.decoder.write(chunk);\n\t        skipAdd = !state.objectMode && chunk.length === 0;\n\t      }\n\t\n\t      if (!addToFront) state.reading = false;\n\t\n\t      // Don't add to the buffer if we've decoded to an empty string chunk and\n\t      // we're not in object mode\n\t      if (!skipAdd) {\n\t        // if we want the data now, just emit it.\n\t        if (state.flowing && state.length === 0 && !state.sync) {\n\t          stream.emit('data', chunk);\n\t          stream.read(0);\n\t        } else {\n\t          // update the buffer info.\n\t          state.length += state.objectMode ? 1 : chunk.length;\n\t          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\t\n\t          if (state.needReadable) emitReadable(stream);\n\t        }\n\t      }\n\t\n\t      maybeReadMore(stream, state);\n\t    }\n\t  } else if (!addToFront) {\n\t    state.reading = false;\n\t  }\n\t\n\t  return needMoreData(state);\n\t}\n\t\n\t// if it's past the high water mark, we can push in some more.\n\t// Also, if we have no data yet, we can stand some\n\t// more bytes.  This is to work around cases where hwm=0,\n\t// such as the repl.  Also, if the push() triggered a\n\t// readable event, and the user called read(largeNumber) such that\n\t// needReadable was set, then we ought to push more, so that another\n\t// 'readable' event will be triggered.\n\tfunction needMoreData(state) {\n\t  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n\t}\n\t\n\t// backwards compatibility.\n\tReadable.prototype.setEncoding = function (enc) {\n\t  if (!StringDecoder) StringDecoder = __webpack_require__(47).StringDecoder;\n\t  this._readableState.decoder = new StringDecoder(enc);\n\t  this._readableState.encoding = enc;\n\t  return this;\n\t};\n\t\n\t// Don't raise the hwm > 8MB\n\tvar MAX_HWM = 0x800000;\n\tfunction computeNewHighWaterMark(n) {\n\t  if (n >= MAX_HWM) {\n\t    n = MAX_HWM;\n\t  } else {\n\t    // Get the next highest power of 2\n\t    n--;\n\t    n |= n >>> 1;\n\t    n |= n >>> 2;\n\t    n |= n >>> 4;\n\t    n |= n >>> 8;\n\t    n |= n >>> 16;\n\t    n++;\n\t  }\n\t  return n;\n\t}\n\t\n\tfunction howMuchToRead(n, state) {\n\t  if (state.length === 0 && state.ended) return 0;\n\t\n\t  if (state.objectMode) return n === 0 ? 0 : 1;\n\t\n\t  if (n === null || isNaN(n)) {\n\t    // only flow one buffer at a time\n\t    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\n\t  }\n\t\n\t  if (n <= 0) return 0;\n\t\n\t  // If we're asking for more than the target buffer level,\n\t  // then raise the water mark.  Bump up to the next highest\n\t  // power of 2, to prevent increasing it excessively in tiny\n\t  // amounts.\n\t  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\t\n\t  // don't have that much.  return null, unless we've ended.\n\t  if (n > state.length) {\n\t    if (!state.ended) {\n\t      state.needReadable = true;\n\t      return 0;\n\t    } else {\n\t      return state.length;\n\t    }\n\t  }\n\t\n\t  return n;\n\t}\n\t\n\t// you can override either this method, or the async _read(n) below.\n\tReadable.prototype.read = function (n) {\n\t  debug('read', n);\n\t  var state = this._readableState;\n\t  var nOrig = n;\n\t\n\t  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\n\t\n\t  // if we're doing read(0) to trigger a readable event, but we\n\t  // already have a bunch of data in the buffer, then just trigger\n\t  // the 'readable' event and move on.\n\t  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n\t    debug('read: emitReadable', state.length, state.ended);\n\t    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n\t    return null;\n\t  }\n\t\n\t  n = howMuchToRead(n, state);\n\t\n\t  // if we've ended, and we're now clear, then finish it up.\n\t  if (n === 0 && state.ended) {\n\t    if (state.length === 0) endReadable(this);\n\t    return null;\n\t  }\n\t\n\t  // All the actual chunk generation logic needs to be\n\t  // *below* the call to _read.  The reason is that in certain\n\t  // synthetic stream cases, such as passthrough streams, _read\n\t  // may be a completely synchronous operation which may change\n\t  // the state of the read buffer, providing enough data when\n\t  // before there was *not* enough.\n\t  //\n\t  // So, the steps are:\n\t  // 1. Figure out what the state of things will be after we do\n\t  // a read from the buffer.\n\t  //\n\t  // 2. If that resulting state will trigger a _read, then call _read.\n\t  // Note that this may be asynchronous, or synchronous.  Yes, it is\n\t  // deeply ugly to write APIs this way, but that still doesn't mean\n\t  // that the Readable class should behave improperly, as streams are\n\t  // designed to be sync/async agnostic.\n\t  // Take note if the _read call is sync or async (ie, if the read call\n\t  // has returned yet), so that we know whether or not it's safe to emit\n\t  // 'readable' etc.\n\t  //\n\t  // 3. Actually pull the requested chunks out of the buffer and return.\n\t\n\t  // if we need a readable event, then we need to do some reading.\n\t  var doRead = state.needReadable;\n\t  debug('need readable', doRead);\n\t\n\t  // if we currently have less than the highWaterMark, then also read some\n\t  if (state.length === 0 || state.length - n < state.highWaterMark) {\n\t    doRead = true;\n\t    debug('length less than watermark', doRead);\n\t  }\n\t\n\t  // however, if we've ended, then there's no point, and if we're already\n\t  // reading, then it's unnecessary.\n\t  if (state.ended || state.reading) {\n\t    doRead = false;\n\t    debug('reading or ended', doRead);\n\t  }\n\t\n\t  if (doRead) {\n\t    debug('do read');\n\t    state.reading = true;\n\t    state.sync = true;\n\t    // if the length is currently zero, then we *need* a readable event.\n\t    if (state.length === 0) state.needReadable = true;\n\t    // call internal read method\n\t    this._read(state.highWaterMark);\n\t    state.sync = false;\n\t  }\n\t\n\t  // If _read pushed data synchronously, then `reading` will be false,\n\t  // and we need to re-evaluate how much data we can return to the user.\n\t  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n\t\n\t  var ret;\n\t  if (n > 0) ret = fromList(n, state);else ret = null;\n\t\n\t  if (ret === null) {\n\t    state.needReadable = true;\n\t    n = 0;\n\t  }\n\t\n\t  state.length -= n;\n\t\n\t  // If we have nothing in the buffer, then we want to know\n\t  // as soon as we *do* get something into the buffer.\n\t  if (state.length === 0 && !state.ended) state.needReadable = true;\n\t\n\t  // If we tried to read() past the EOF, then emit end on the next tick.\n\t  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n\t\n\t  if (ret !== null) this.emit('data', ret);\n\t\n\t  return ret;\n\t};\n\t\n\tfunction chunkInvalid(state, chunk) {\n\t  var er = null;\n\t  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  return er;\n\t}\n\t\n\tfunction onEofChunk(stream, state) {\n\t  if (state.ended) return;\n\t  if (state.decoder) {\n\t    var chunk = state.decoder.end();\n\t    if (chunk && chunk.length) {\n\t      state.buffer.push(chunk);\n\t      state.length += state.objectMode ? 1 : chunk.length;\n\t    }\n\t  }\n\t  state.ended = true;\n\t\n\t  // emit 'readable' now to make sure it gets picked up.\n\t  emitReadable(stream);\n\t}\n\t\n\t// Don't emit readable right away in sync mode, because this can trigger\n\t// another read() call => stack overflow.  This way, it might trigger\n\t// a nextTick recursion warning, but that's not so bad.\n\tfunction emitReadable(stream) {\n\t  var state = stream._readableState;\n\t  state.needReadable = false;\n\t  if (!state.emittedReadable) {\n\t    debug('emitReadable', state.flowing);\n\t    state.emittedReadable = true;\n\t    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n\t  }\n\t}\n\t\n\tfunction emitReadable_(stream) {\n\t  debug('emit readable');\n\t  stream.emit('readable');\n\t  flow(stream);\n\t}\n\t\n\t// at this point, the user has presumably seen the 'readable' event,\n\t// and called read() to consume some data.  that may have triggered\n\t// in turn another _read(n) call, in which case reading = true if\n\t// it's in progress.\n\t// However, if we're not ended, or reading, and the length < hwm,\n\t// then go ahead and try to read some more preemptively.\n\tfunction maybeReadMore(stream, state) {\n\t  if (!state.readingMore) {\n\t    state.readingMore = true;\n\t    processNextTick(maybeReadMore_, stream, state);\n\t  }\n\t}\n\t\n\tfunction maybeReadMore_(stream, state) {\n\t  var len = state.length;\n\t  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n\t    debug('maybeReadMore read 0');\n\t    stream.read(0);\n\t    if (len === state.length)\n\t      // didn't get any data, stop spinning.\n\t      break;else len = state.length;\n\t  }\n\t  state.readingMore = false;\n\t}\n\t\n\t// abstract method.  to be overridden in specific implementation classes.\n\t// call cb(er, data) where data is <= n in length.\n\t// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n\t// arbitrary, and perhaps not very meaningful.\n\tReadable.prototype._read = function (n) {\n\t  this.emit('error', new Error('not implemented'));\n\t};\n\t\n\tReadable.prototype.pipe = function (dest, pipeOpts) {\n\t  var src = this;\n\t  var state = this._readableState;\n\t\n\t  switch (state.pipesCount) {\n\t    case 0:\n\t      state.pipes = dest;\n\t      break;\n\t    case 1:\n\t      state.pipes = [state.pipes, dest];\n\t      break;\n\t    default:\n\t      state.pipes.push(dest);\n\t      break;\n\t  }\n\t  state.pipesCount += 1;\n\t  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\t\n\t  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\t\n\t  var endFn = doEnd ? onend : cleanup;\n\t  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\t\n\t  dest.on('unpipe', onunpipe);\n\t  function onunpipe(readable) {\n\t    debug('onunpipe');\n\t    if (readable === src) {\n\t      cleanup();\n\t    }\n\t  }\n\t\n\t  function onend() {\n\t    debug('onend');\n\t    dest.end();\n\t  }\n\t\n\t  // when the dest drains, it reduces the awaitDrain counter\n\t  // on the source.  This would be more elegant with a .once()\n\t  // handler in flow(), but adding and removing repeatedly is\n\t  // too slow.\n\t  var ondrain = pipeOnDrain(src);\n\t  dest.on('drain', ondrain);\n\t\n\t  var cleanedUp = false;\n\t  function cleanup() {\n\t    debug('cleanup');\n\t    // cleanup event handlers once the pipe is broken\n\t    dest.removeListener('close', onclose);\n\t    dest.removeListener('finish', onfinish);\n\t    dest.removeListener('drain', ondrain);\n\t    dest.removeListener('error', onerror);\n\t    dest.removeListener('unpipe', onunpipe);\n\t    src.removeListener('end', onend);\n\t    src.removeListener('end', cleanup);\n\t    src.removeListener('data', ondata);\n\t\n\t    cleanedUp = true;\n\t\n\t    // if the reader is waiting for a drain event from this\n\t    // specific writer, then it would cause it to never start\n\t    // flowing again.\n\t    // So, if this is awaiting a drain, then we just call it now.\n\t    // If we don't know, then assume that we are waiting for one.\n\t    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n\t  }\n\t\n\t  src.on('data', ondata);\n\t  function ondata(chunk) {\n\t    debug('ondata');\n\t    var ret = dest.write(chunk);\n\t    if (false === ret) {\n\t      // If the user unpiped during `dest.write()`, it is possible\n\t      // to get stuck in a permanently paused state if that write\n\t      // also returned false.\n\t      // => Check whether `dest` is still a piping destination.\n\t      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n\t        debug('false write response, pause', src._readableState.awaitDrain);\n\t        src._readableState.awaitDrain++;\n\t      }\n\t      src.pause();\n\t    }\n\t  }\n\t\n\t  // if the dest has an error, then stop piping into it.\n\t  // however, don't suppress the throwing behavior for this.\n\t  function onerror(er) {\n\t    debug('onerror', er);\n\t    unpipe();\n\t    dest.removeListener('error', onerror);\n\t    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n\t  }\n\t\n\t  // Make sure our error handler is attached before userland ones.\n\t  prependListener(dest, 'error', onerror);\n\t\n\t  // Both close and finish should trigger unpipe, but only once.\n\t  function onclose() {\n\t    dest.removeListener('finish', onfinish);\n\t    unpipe();\n\t  }\n\t  dest.once('close', onclose);\n\t  function onfinish() {\n\t    debug('onfinish');\n\t    dest.removeListener('close', onclose);\n\t    unpipe();\n\t  }\n\t  dest.once('finish', onfinish);\n\t\n\t  function unpipe() {\n\t    debug('unpipe');\n\t    src.unpipe(dest);\n\t  }\n\t\n\t  // tell the dest that it's being piped to\n\t  dest.emit('pipe', src);\n\t\n\t  // start the flow if it hasn't been started already.\n\t  if (!state.flowing) {\n\t    debug('pipe resume');\n\t    src.resume();\n\t  }\n\t\n\t  return dest;\n\t};\n\t\n\tfunction pipeOnDrain(src) {\n\t  return function () {\n\t    var state = src._readableState;\n\t    debug('pipeOnDrain', state.awaitDrain);\n\t    if (state.awaitDrain) state.awaitDrain--;\n\t    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n\t      state.flowing = true;\n\t      flow(src);\n\t    }\n\t  };\n\t}\n\t\n\tReadable.prototype.unpipe = function (dest) {\n\t  var state = this._readableState;\n\t\n\t  // if we're not piping anywhere, then do nothing.\n\t  if (state.pipesCount === 0) return this;\n\t\n\t  // just one destination.  most common case.\n\t  if (state.pipesCount === 1) {\n\t    // passed in one, but it's not the right one.\n\t    if (dest && dest !== state.pipes) return this;\n\t\n\t    if (!dest) dest = state.pipes;\n\t\n\t    // got a match.\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t    if (dest) dest.emit('unpipe', this);\n\t    return this;\n\t  }\n\t\n\t  // slow case. multiple pipe destinations.\n\t\n\t  if (!dest) {\n\t    // remove all.\n\t    var dests = state.pipes;\n\t    var len = state.pipesCount;\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t\n\t    for (var _i = 0; _i < len; _i++) {\n\t      dests[_i].emit('unpipe', this);\n\t    }return this;\n\t  }\n\t\n\t  // try to find the right one.\n\t  var i = indexOf(state.pipes, dest);\n\t  if (i === -1) return this;\n\t\n\t  state.pipes.splice(i, 1);\n\t  state.pipesCount -= 1;\n\t  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\t\n\t  dest.emit('unpipe', this);\n\t\n\t  return this;\n\t};\n\t\n\t// set up data events if they are asked for\n\t// Ensure readable listeners eventually get something\n\tReadable.prototype.on = function (ev, fn) {\n\t  var res = Stream.prototype.on.call(this, ev, fn);\n\t\n\t  // If listening to data, and it has not explicitly been paused,\n\t  // then call resume to start the flow of data on the next tick.\n\t  if (ev === 'data' && false !== this._readableState.flowing) {\n\t    this.resume();\n\t  }\n\t\n\t  if (ev === 'readable' && !this._readableState.endEmitted) {\n\t    var state = this._readableState;\n\t    if (!state.readableListening) {\n\t      state.readableListening = true;\n\t      state.emittedReadable = false;\n\t      state.needReadable = true;\n\t      if (!state.reading) {\n\t        processNextTick(nReadingNextTick, this);\n\t      } else if (state.length) {\n\t        emitReadable(this, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  return res;\n\t};\n\tReadable.prototype.addListener = Readable.prototype.on;\n\t\n\tfunction nReadingNextTick(self) {\n\t  debug('readable nexttick read 0');\n\t  self.read(0);\n\t}\n\t\n\t// pause() and resume() are remnants of the legacy readable stream API\n\t// If the user uses them, then switch into old mode.\n\tReadable.prototype.resume = function () {\n\t  var state = this._readableState;\n\t  if (!state.flowing) {\n\t    debug('resume');\n\t    state.flowing = true;\n\t    resume(this, state);\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction resume(stream, state) {\n\t  if (!state.resumeScheduled) {\n\t    state.resumeScheduled = true;\n\t    processNextTick(resume_, stream, state);\n\t  }\n\t}\n\t\n\tfunction resume_(stream, state) {\n\t  if (!state.reading) {\n\t    debug('resume read 0');\n\t    stream.read(0);\n\t  }\n\t\n\t  state.resumeScheduled = false;\n\t  stream.emit('resume');\n\t  flow(stream);\n\t  if (state.flowing && !state.reading) stream.read(0);\n\t}\n\t\n\tReadable.prototype.pause = function () {\n\t  debug('call pause flowing=%j', this._readableState.flowing);\n\t  if (false !== this._readableState.flowing) {\n\t    debug('pause');\n\t    this._readableState.flowing = false;\n\t    this.emit('pause');\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction flow(stream) {\n\t  var state = stream._readableState;\n\t  debug('flow', state.flowing);\n\t  if (state.flowing) {\n\t    do {\n\t      var chunk = stream.read();\n\t    } while (null !== chunk && state.flowing);\n\t  }\n\t}\n\t\n\t// wrap an old-style stream as the async data source.\n\t// This is *not* part of the readable stream interface.\n\t// It is an ugly unfortunate mess of history.\n\tReadable.prototype.wrap = function (stream) {\n\t  var state = this._readableState;\n\t  var paused = false;\n\t\n\t  var self = this;\n\t  stream.on('end', function () {\n\t    debug('wrapped end');\n\t    if (state.decoder && !state.ended) {\n\t      var chunk = state.decoder.end();\n\t      if (chunk && chunk.length) self.push(chunk);\n\t    }\n\t\n\t    self.push(null);\n\t  });\n\t\n\t  stream.on('data', function (chunk) {\n\t    debug('wrapped data');\n\t    if (state.decoder) chunk = state.decoder.write(chunk);\n\t\n\t    // don't skip over falsy values in objectMode\n\t    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\t\n\t    var ret = self.push(chunk);\n\t    if (!ret) {\n\t      paused = true;\n\t      stream.pause();\n\t    }\n\t  });\n\t\n\t  // proxy all the other methods.\n\t  // important when wrapping filters and duplexes.\n\t  for (var i in stream) {\n\t    if (this[i] === undefined && typeof stream[i] === 'function') {\n\t      this[i] = function (method) {\n\t        return function () {\n\t          return stream[method].apply(stream, arguments);\n\t        };\n\t      }(i);\n\t    }\n\t  }\n\t\n\t  // proxy certain important events.\n\t  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n\t  forEach(events, function (ev) {\n\t    stream.on(ev, self.emit.bind(self, ev));\n\t  });\n\t\n\t  // when we try to consume some more bytes, simply unpause the\n\t  // underlying stream.\n\t  self._read = function (n) {\n\t    debug('wrapped _read', n);\n\t    if (paused) {\n\t      paused = false;\n\t      stream.resume();\n\t    }\n\t  };\n\t\n\t  return self;\n\t};\n\t\n\t// exposed for testing purposes only.\n\tReadable._fromList = fromList;\n\t\n\t// Pluck off n bytes from an array of buffers.\n\t// Length is the combined lengths of all the buffers in the list.\n\tfunction fromList(n, state) {\n\t  var list = state.buffer;\n\t  var length = state.length;\n\t  var stringMode = !!state.decoder;\n\t  var objectMode = !!state.objectMode;\n\t  var ret;\n\t\n\t  // nothing in the list, definitely empty.\n\t  if (list.length === 0) return null;\n\t\n\t  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\n\t    // read it all, truncate the array.\n\t    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n\t    list.length = 0;\n\t  } else {\n\t    // read just some of it.\n\t    if (n < list[0].length) {\n\t      // just take a part of the first list item.\n\t      // slice is the same for buffers and strings.\n\t      var buf = list[0];\n\t      ret = buf.slice(0, n);\n\t      list[0] = buf.slice(n);\n\t    } else if (n === list[0].length) {\n\t      // first list is a perfect match\n\t      ret = list.shift();\n\t    } else {\n\t      // complex case.\n\t      // we have enough to cover it, but it spans past the first buffer.\n\t      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);\n\t\n\t      var c = 0;\n\t      for (var i = 0, l = list.length; i < l && c < n; i++) {\n\t        var _buf = list[0];\n\t        var cpy = Math.min(n - c, _buf.length);\n\t\n\t        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);\n\t\n\t        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();\n\t\n\t        c += cpy;\n\t      }\n\t    }\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction endReadable(stream) {\n\t  var state = stream._readableState;\n\t\n\t  // If we get here before consuming all the bytes, then that is a\n\t  // bug in node.  Should never happen.\n\t  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\t\n\t  if (!state.endEmitted) {\n\t    state.ended = true;\n\t    processNextTick(endReadableNT, state, stream);\n\t  }\n\t}\n\t\n\tfunction endReadableNT(state, stream) {\n\t  // Check that we didn't get one last unshift.\n\t  if (!state.endEmitted && state.length === 0) {\n\t    state.endEmitted = true;\n\t    stream.readable = false;\n\t    stream.emit('end');\n\t  }\n\t}\n\t\n\tfunction forEach(xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\t\n\tfunction indexOf(xs, x) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    if (xs[i] === x) return i;\n\t  }\n\t  return -1;\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tif (!process.version ||\n\t    process.version.indexOf('v0.') === 0 ||\n\t    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n\t  module.exports = nextTick;\n\t} else {\n\t  module.exports = process.nextTick;\n\t}\n\t\n\tfunction nextTick(fn, arg1, arg2, arg3) {\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('\"callback\" argument must be a function');\n\t  }\n\t  var len = arguments.length;\n\t  var args, i;\n\t  switch (len) {\n\t  case 0:\n\t  case 1:\n\t    return process.nextTick(fn);\n\t  case 2:\n\t    return process.nextTick(function afterTickOne() {\n\t      fn.call(null, arg1);\n\t    });\n\t  case 3:\n\t    return process.nextTick(function afterTickTwo() {\n\t      fn.call(null, arg1, arg2);\n\t    });\n\t  case 4:\n\t    return process.nextTick(function afterTickThree() {\n\t      fn.call(null, arg1, arg2, arg3);\n\t    });\n\t  default:\n\t    args = new Array(len - 1);\n\t    i = 0;\n\t    while (i < args.length) {\n\t      args[i++] = arguments[i];\n\t    }\n\t    return process.nextTick(function afterTick() {\n\t      fn.apply(null, args);\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar buffer = __webpack_require__(27);\n\tvar Buffer = buffer.Buffer;\n\tvar SlowBuffer = buffer.SlowBuffer;\n\tvar MAX_LEN = buffer.kMaxLength || 2147483647;\n\texports.alloc = function alloc(size, fill, encoding) {\n\t  if (typeof Buffer.alloc === 'function') {\n\t    return Buffer.alloc(size, fill, encoding);\n\t  }\n\t  if (typeof encoding === 'number') {\n\t    throw new TypeError('encoding must not be number');\n\t  }\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('size must be a number');\n\t  }\n\t  if (size > MAX_LEN) {\n\t    throw new RangeError('size is too large');\n\t  }\n\t  var enc = encoding;\n\t  var _fill = fill;\n\t  if (_fill === undefined) {\n\t    enc = undefined;\n\t    _fill = 0;\n\t  }\n\t  var buf = new Buffer(size);\n\t  if (typeof _fill === 'string') {\n\t    var fillBuf = new Buffer(_fill, enc);\n\t    var flen = fillBuf.length;\n\t    var i = -1;\n\t    while (++i < size) {\n\t      buf[i] = fillBuf[i % flen];\n\t    }\n\t  } else {\n\t    buf.fill(_fill);\n\t  }\n\t  return buf;\n\t}\n\texports.allocUnsafe = function allocUnsafe(size) {\n\t  if (typeof Buffer.allocUnsafe === 'function') {\n\t    return Buffer.allocUnsafe(size);\n\t  }\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('size must be a number');\n\t  }\n\t  if (size > MAX_LEN) {\n\t    throw new RangeError('size is too large');\n\t  }\n\t  return new Buffer(size);\n\t}\n\texports.from = function from(value, encodingOrOffset, length) {\n\t  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {\n\t    return Buffer.from(value, encodingOrOffset, length);\n\t  }\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number');\n\t  }\n\t  if (typeof value === 'string') {\n\t    return new Buffer(value, encodingOrOffset);\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    var offset = encodingOrOffset;\n\t    if (arguments.length === 1) {\n\t      return new Buffer(value);\n\t    }\n\t    if (typeof offset === 'undefined') {\n\t      offset = 0;\n\t    }\n\t    var len = length;\n\t    if (typeof len === 'undefined') {\n\t      len = value.byteLength - offset;\n\t    }\n\t    if (offset >= value.byteLength) {\n\t      throw new RangeError('\\'offset\\' is out of bounds');\n\t    }\n\t    if (len > value.byteLength - offset) {\n\t      throw new RangeError('\\'length\\' is out of bounds');\n\t    }\n\t    return new Buffer(value.slice(offset, offset + len));\n\t  }\n\t  if (Buffer.isBuffer(value)) {\n\t    var out = new Buffer(value.length);\n\t    value.copy(out, 0, 0, value.length);\n\t    return out;\n\t  }\n\t  if (value) {\n\t    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {\n\t      return new Buffer(value);\n\t    }\n\t    if (value.type === 'Buffer' && Array.isArray(value.data)) {\n\t      return new Buffer(value.data);\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');\n\t}\n\texports.allocUnsafeSlow = function allocUnsafeSlow(size) {\n\t  if (typeof Buffer.allocUnsafeSlow === 'function') {\n\t    return Buffer.allocUnsafeSlow(size);\n\t  }\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('size must be a number');\n\t  }\n\t  if (size >= MAX_LEN) {\n\t    throw new RangeError('size is too large');\n\t  }\n\t  return new SlowBuffer(size);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\t\n\tfunction isArray(arg) {\n\t  if (Array.isArray) {\n\t    return Array.isArray(arg);\n\t  }\n\t  return objectToString(arg) === '[object Array]';\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = Buffer.isBuffer;\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// a duplex stream is just a stream that is both readable and writable.\n\t// Since JS doesn't have multiple prototypal inheritance, this class\n\t// prototypally inherits from Readable, and then parasitically from\n\t// Writable.\n\t\n\t'use strict';\n\t\n\t/*<replacement>*/\n\t\n\tvar objectKeys = Object.keys || function (obj) {\n\t  var keys = [];\n\t  for (var key in obj) {\n\t    keys.push(key);\n\t  }return keys;\n\t};\n\t/*</replacement>*/\n\t\n\tmodule.exports = Duplex;\n\t\n\t/*<replacement>*/\n\tvar processNextTick = __webpack_require__(39);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(41);\n\tutil.inherits = __webpack_require__(36);\n\t/*</replacement>*/\n\t\n\tvar Readable = __webpack_require__(38);\n\tvar Writable = __webpack_require__(44);\n\t\n\tutil.inherits(Duplex, Readable);\n\t\n\tvar keys = objectKeys(Writable.prototype);\n\tfor (var v = 0; v < keys.length; v++) {\n\t  var method = keys[v];\n\t  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n\t}\n\t\n\tfunction Duplex(options) {\n\t  if (!(this instanceof Duplex)) return new Duplex(options);\n\t\n\t  Readable.call(this, options);\n\t  Writable.call(this, options);\n\t\n\t  if (options && options.readable === false) this.readable = false;\n\t\n\t  if (options && options.writable === false) this.writable = false;\n\t\n\t  this.allowHalfOpen = true;\n\t  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\t\n\t  this.once('end', onend);\n\t}\n\t\n\t// the no-half-open enforcer\n\tfunction onend() {\n\t  // if we allow half-open state, or if the writable side ended,\n\t  // then we're ok.\n\t  if (this.allowHalfOpen || this._writableState.ended) return;\n\t\n\t  // no more data can be written.\n\t  // But allow more writes to happen in this tick.\n\t  processNextTick(onEndNT, this);\n\t}\n\t\n\tfunction onEndNT(self) {\n\t  self.end();\n\t}\n\t\n\tfunction forEach(xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.\n\t// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n\t// the drain event emission and buffering.\n\t\n\t'use strict';\n\t\n\tmodule.exports = Writable;\n\t\n\t/*<replacement>*/\n\tvar processNextTick = __webpack_require__(39);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n\t/*</replacement>*/\n\t\n\tWritable.WritableState = WritableState;\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(41);\n\tutil.inherits = __webpack_require__(36);\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar internalUtil = {\n\t  deprecate: __webpack_require__(46)\n\t};\n\t/*</replacement>*/\n\t\n\t/*<replacement>*/\n\tvar Stream;\n\t(function () {\n\t  try {\n\t    Stream = __webpack_require__(34);\n\t  } catch (_) {} finally {\n\t    if (!Stream) Stream = __webpack_require__(35).EventEmitter;\n\t  }\n\t})();\n\t/*</replacement>*/\n\t\n\tvar Buffer = __webpack_require__(27).Buffer;\n\t/*<replacement>*/\n\tvar bufferShim = __webpack_require__(40);\n\t/*</replacement>*/\n\t\n\tutil.inherits(Writable, Stream);\n\t\n\tfunction nop() {}\n\t\n\tfunction WriteReq(chunk, encoding, cb) {\n\t  this.chunk = chunk;\n\t  this.encoding = encoding;\n\t  this.callback = cb;\n\t  this.next = null;\n\t}\n\t\n\tvar Duplex;\n\tfunction WritableState(options, stream) {\n\t  Duplex = Duplex || __webpack_require__(43);\n\t\n\t  options = options || {};\n\t\n\t  // object stream flag to indicate whether or not this stream\n\t  // contains buffers or objects.\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\t\n\t  // the point at which write() starts returning false\n\t  // Note: 0 is a valid value, means that we always return false if\n\t  // the entire buffer is not flushed immediately on write()\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\t\n\t  this.needDrain = false;\n\t  // at the start of calling end()\n\t  this.ending = false;\n\t  // when end() has been called, and returned\n\t  this.ended = false;\n\t  // when 'finish' is emitted\n\t  this.finished = false;\n\t\n\t  // should we decode strings into buffers before passing to _write?\n\t  // this is here so that some node-core streams can optimize string\n\t  // handling at a lower level.\n\t  var noDecode = options.decodeStrings === false;\n\t  this.decodeStrings = !noDecode;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // not an actual buffer we keep track of, but a measurement\n\t  // of how much we're waiting to get pushed to some underlying\n\t  // socket or file.\n\t  this.length = 0;\n\t\n\t  // a flag to see when we're in the middle of a write.\n\t  this.writing = false;\n\t\n\t  // when true all writes will be buffered until .uncork() call\n\t  this.corked = 0;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // a flag to know if we're processing previously buffered items, which\n\t  // may call the _write() callback in the same tick, so that we don't\n\t  // end up in an overlapped onwrite situation.\n\t  this.bufferProcessing = false;\n\t\n\t  // the callback that's passed to _write(chunk,cb)\n\t  this.onwrite = function (er) {\n\t    onwrite(stream, er);\n\t  };\n\t\n\t  // the callback that the user supplies to write(chunk,encoding,cb)\n\t  this.writecb = null;\n\t\n\t  // the amount that is being written when _write is called.\n\t  this.writelen = 0;\n\t\n\t  this.bufferedRequest = null;\n\t  this.lastBufferedRequest = null;\n\t\n\t  // number of pending user-supplied write callbacks\n\t  // this must be 0 before 'finish' can be emitted\n\t  this.pendingcb = 0;\n\t\n\t  // emit prefinish if the only thing we're waiting for is _write cbs\n\t  // This is relevant for synchronous Transform streams\n\t  this.prefinished = false;\n\t\n\t  // True if the error was already emitted and should not be thrown again\n\t  this.errorEmitted = false;\n\t\n\t  // count buffered requests\n\t  this.bufferedRequestCount = 0;\n\t\n\t  // allocate the first CorkedRequest, there is always\n\t  // one allocated and free to use, and we maintain at most two\n\t  this.corkedRequestsFree = new CorkedRequest(this);\n\t}\n\t\n\tWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n\t  var current = this.bufferedRequest;\n\t  var out = [];\n\t  while (current) {\n\t    out.push(current);\n\t    current = current.next;\n\t  }\n\t  return out;\n\t};\n\t\n\t(function () {\n\t  try {\n\t    Object.defineProperty(WritableState.prototype, 'buffer', {\n\t      get: internalUtil.deprecate(function () {\n\t        return this.getBuffer();\n\t      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n\t    });\n\t  } catch (_) {}\n\t})();\n\t\n\tvar Duplex;\n\tfunction Writable(options) {\n\t  Duplex = Duplex || __webpack_require__(43);\n\t\n\t  // Writable ctor is applied to Duplexes, though they're not\n\t  // instanceof Writable, they're instanceof Readable.\n\t  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\t\n\t  this._writableState = new WritableState(options, this);\n\t\n\t  // legacy.\n\t  this.writable = true;\n\t\n\t  if (options) {\n\t    if (typeof options.write === 'function') this._write = options.write;\n\t\n\t    if (typeof options.writev === 'function') this._writev = options.writev;\n\t  }\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Otherwise people can pipe Writable streams, which is just wrong.\n\tWritable.prototype.pipe = function () {\n\t  this.emit('error', new Error('Cannot pipe, not readable'));\n\t};\n\t\n\tfunction writeAfterEnd(stream, cb) {\n\t  var er = new Error('write after end');\n\t  // TODO: defer error events consistently everywhere, not just the cb\n\t  stream.emit('error', er);\n\t  processNextTick(cb, er);\n\t}\n\t\n\t// If we get something that is not a buffer, string, null, or undefined,\n\t// and we're not in objectMode, then that's an error.\n\t// Otherwise stream chunks are all considered to be of length=1, and the\n\t// watermarks determine how many objects to keep in the buffer, rather than\n\t// how many bytes or characters.\n\tfunction validChunk(stream, state, chunk, cb) {\n\t  var valid = true;\n\t  var er = false;\n\t  // Always throw error if a null is written\n\t  // if we are not in object mode then throw\n\t  // if it is not a buffer, string, or undefined.\n\t  if (chunk === null) {\n\t    er = new TypeError('May not write null values to stream');\n\t  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  if (er) {\n\t    stream.emit('error', er);\n\t    processNextTick(cb, er);\n\t    valid = false;\n\t  }\n\t  return valid;\n\t}\n\t\n\tWritable.prototype.write = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t  var ret = false;\n\t\n\t  if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\t\n\t  if (typeof cb !== 'function') cb = nop;\n\t\n\t  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n\t    state.pendingcb++;\n\t    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\tWritable.prototype.cork = function () {\n\t  var state = this._writableState;\n\t\n\t  state.corked++;\n\t};\n\t\n\tWritable.prototype.uncork = function () {\n\t  var state = this._writableState;\n\t\n\t  if (state.corked) {\n\t    state.corked--;\n\t\n\t    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n\t  }\n\t};\n\t\n\tWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n\t  // node::ParseEncoding() requires lower case.\n\t  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n\t  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n\t  this._writableState.defaultEncoding = encoding;\n\t  return this;\n\t};\n\t\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n\t    chunk = bufferShim.from(chunk, encoding);\n\t  }\n\t  return chunk;\n\t}\n\t\n\t// if we're already writing something, then just put this\n\t// in the queue, and wait our turn.  Otherwise, call _write\n\t// If we return false, then we need a drain event, so set that flag.\n\tfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n\t  chunk = decodeChunk(state, chunk, encoding);\n\t\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n\t  var len = state.objectMode ? 1 : chunk.length;\n\t\n\t  state.length += len;\n\t\n\t  var ret = state.length < state.highWaterMark;\n\t  // we must ensure that previous needDrain will not be reset to false.\n\t  if (!ret) state.needDrain = true;\n\t\n\t  if (state.writing || state.corked) {\n\t    var last = state.lastBufferedRequest;\n\t    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n\t    if (last) {\n\t      last.next = state.lastBufferedRequest;\n\t    } else {\n\t      state.bufferedRequest = state.lastBufferedRequest;\n\t    }\n\t    state.bufferedRequestCount += 1;\n\t  } else {\n\t    doWrite(stream, state, false, len, chunk, encoding, cb);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n\t  state.writelen = len;\n\t  state.writecb = cb;\n\t  state.writing = true;\n\t  state.sync = true;\n\t  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n\t  state.sync = false;\n\t}\n\t\n\tfunction onwriteError(stream, state, sync, er, cb) {\n\t  --state.pendingcb;\n\t  if (sync) processNextTick(cb, er);else cb(er);\n\t\n\t  stream._writableState.errorEmitted = true;\n\t  stream.emit('error', er);\n\t}\n\t\n\tfunction onwriteStateUpdate(state) {\n\t  state.writing = false;\n\t  state.writecb = null;\n\t  state.length -= state.writelen;\n\t  state.writelen = 0;\n\t}\n\t\n\tfunction onwrite(stream, er) {\n\t  var state = stream._writableState;\n\t  var sync = state.sync;\n\t  var cb = state.writecb;\n\t\n\t  onwriteStateUpdate(state);\n\t\n\t  if (er) onwriteError(stream, state, sync, er, cb);else {\n\t    // Check if we're actually ready to finish, but don't emit yet\n\t    var finished = needFinish(state);\n\t\n\t    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n\t      clearBuffer(stream, state);\n\t    }\n\t\n\t    if (sync) {\n\t      /*<replacement>*/\n\t      asyncWrite(afterWrite, stream, state, finished, cb);\n\t      /*</replacement>*/\n\t    } else {\n\t        afterWrite(stream, state, finished, cb);\n\t      }\n\t  }\n\t}\n\t\n\tfunction afterWrite(stream, state, finished, cb) {\n\t  if (!finished) onwriteDrain(stream, state);\n\t  state.pendingcb--;\n\t  cb();\n\t  finishMaybe(stream, state);\n\t}\n\t\n\t// Must force callback to be called on nextTick, so that we don't\n\t// emit 'drain' before the write() consumer gets the 'false' return\n\t// value, and has a chance to attach a 'drain' listener.\n\tfunction onwriteDrain(stream, state) {\n\t  if (state.length === 0 && state.needDrain) {\n\t    state.needDrain = false;\n\t    stream.emit('drain');\n\t  }\n\t}\n\t\n\t// if there's something in the buffer waiting, then process it\n\tfunction clearBuffer(stream, state) {\n\t  state.bufferProcessing = true;\n\t  var entry = state.bufferedRequest;\n\t\n\t  if (stream._writev && entry && entry.next) {\n\t    // Fast case, write everything using _writev()\n\t    var l = state.bufferedRequestCount;\n\t    var buffer = new Array(l);\n\t    var holder = state.corkedRequestsFree;\n\t    holder.entry = entry;\n\t\n\t    var count = 0;\n\t    while (entry) {\n\t      buffer[count] = entry;\n\t      entry = entry.next;\n\t      count += 1;\n\t    }\n\t\n\t    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\t\n\t    // doWrite is almost always async, defer these to save a bit of time\n\t    // as the hot path ends with doWrite\n\t    state.pendingcb++;\n\t    state.lastBufferedRequest = null;\n\t    if (holder.next) {\n\t      state.corkedRequestsFree = holder.next;\n\t      holder.next = null;\n\t    } else {\n\t      state.corkedRequestsFree = new CorkedRequest(state);\n\t    }\n\t  } else {\n\t    // Slow case, write chunks one-by-one\n\t    while (entry) {\n\t      var chunk = entry.chunk;\n\t      var encoding = entry.encoding;\n\t      var cb = entry.callback;\n\t      var len = state.objectMode ? 1 : chunk.length;\n\t\n\t      doWrite(stream, state, false, len, chunk, encoding, cb);\n\t      entry = entry.next;\n\t      // if we didn't call the onwrite immediately, then\n\t      // it means that we need to wait until it does.\n\t      // also, that means that the chunk and cb are currently\n\t      // being processed, so move the buffer counter past them.\n\t      if (state.writing) {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (entry === null) state.lastBufferedRequest = null;\n\t  }\n\t\n\t  state.bufferedRequestCount = 0;\n\t  state.bufferedRequest = entry;\n\t  state.bufferProcessing = false;\n\t}\n\t\n\tWritable.prototype._write = function (chunk, encoding, cb) {\n\t  cb(new Error('not implemented'));\n\t};\n\t\n\tWritable.prototype._writev = null;\n\t\n\tWritable.prototype.end = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t\n\t  if (typeof chunk === 'function') {\n\t    cb = chunk;\n\t    chunk = null;\n\t    encoding = null;\n\t  } else if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\t\n\t  // .end() fully uncorks\n\t  if (state.corked) {\n\t    state.corked = 1;\n\t    this.uncork();\n\t  }\n\t\n\t  // ignore unnecessary end() calls.\n\t  if (!state.ending && !state.finished) endWritable(this, state, cb);\n\t};\n\t\n\tfunction needFinish(state) {\n\t  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n\t}\n\t\n\tfunction prefinish(stream, state) {\n\t  if (!state.prefinished) {\n\t    state.prefinished = true;\n\t    stream.emit('prefinish');\n\t  }\n\t}\n\t\n\tfunction finishMaybe(stream, state) {\n\t  var need = needFinish(state);\n\t  if (need) {\n\t    if (state.pendingcb === 0) {\n\t      prefinish(stream, state);\n\t      state.finished = true;\n\t      stream.emit('finish');\n\t    } else {\n\t      prefinish(stream, state);\n\t    }\n\t  }\n\t  return need;\n\t}\n\t\n\tfunction endWritable(stream, state, cb) {\n\t  state.ending = true;\n\t  finishMaybe(stream, state);\n\t  if (cb) {\n\t    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n\t  }\n\t  state.ended = true;\n\t  stream.writable = false;\n\t}\n\t\n\t// It seems a linked list but it is not\n\t// there will be only 2 of these for each stream\n\tfunction CorkedRequest(state) {\n\t  var _this = this;\n\t\n\t  this.next = null;\n\t  this.entry = null;\n\t\n\t  this.finish = function (err) {\n\t    var entry = _this.entry;\n\t    _this.entry = null;\n\t    while (entry) {\n\t      var cb = entry.callback;\n\t      state.pendingcb--;\n\t      cb(err);\n\t      entry = entry.next;\n\t    }\n\t    if (state.corkedRequestsFree) {\n\t      state.corkedRequestsFree.next = _this;\n\t    } else {\n\t      state.corkedRequestsFree = _this;\n\t    }\n\t  };\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25), __webpack_require__(45).setImmediate))\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(25).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(45).setImmediate, __webpack_require__(45).clearImmediate))\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = deprecate;\n\t\n\t/**\n\t * Mark that a method should not be used.\n\t * Returns a modified function which warns once by default.\n\t *\n\t * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n\t *\n\t * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n\t * will throw an Error when invoked.\n\t *\n\t * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n\t * will invoke `console.trace()` instead of `console.error()`.\n\t *\n\t * @param {Function} fn - the function to deprecate\n\t * @param {String} msg - the string to print to the console when `fn` is invoked\n\t * @returns {Function} a new \"deprecated\" version of `fn`\n\t * @api public\n\t */\n\t\n\tfunction deprecate (fn, msg) {\n\t  if (config('noDeprecation')) {\n\t    return fn;\n\t  }\n\t\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (config('throwDeprecation')) {\n\t        throw new Error(msg);\n\t      } else if (config('traceDeprecation')) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.warn(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\t\n\t  return deprecated;\n\t}\n\t\n\t/**\n\t * Checks `localStorage` for boolean values for the given `name`.\n\t *\n\t * @param {String} name\n\t * @returns {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction config (name) {\n\t  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n\t  try {\n\t    if (!global.localStorage) return false;\n\t  } catch (_) {\n\t    return false;\n\t  }\n\t  var val = global.localStorage[name];\n\t  if (null == val) return false;\n\t  return String(val).toLowerCase() === 'true';\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar Buffer = __webpack_require__(27).Buffer;\n\t\n\tvar isBufferEncoding = Buffer.isEncoding\n\t  || function(encoding) {\n\t       switch (encoding && encoding.toLowerCase()) {\n\t         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n\t         default: return false;\n\t       }\n\t     }\n\t\n\t\n\tfunction assertEncoding(encoding) {\n\t  if (encoding && !isBufferEncoding(encoding)) {\n\t    throw new Error('Unknown encoding: ' + encoding);\n\t  }\n\t}\n\t\n\t// StringDecoder provides an interface for efficiently splitting a series of\n\t// buffers into a series of JS strings without breaking apart multi-byte\n\t// characters. CESU-8 is handled as part of the UTF-8 encoding.\n\t//\n\t// @TODO Handling all encodings inside a single object makes it very difficult\n\t// to reason about this code, so it should be split up in the future.\n\t// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n\t// points as used by CESU-8.\n\tvar StringDecoder = exports.StringDecoder = function(encoding) {\n\t  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n\t  assertEncoding(encoding);\n\t  switch (this.encoding) {\n\t    case 'utf8':\n\t      // CESU-8 represents each of Surrogate Pair by 3-bytes\n\t      this.surrogateSize = 3;\n\t      break;\n\t    case 'ucs2':\n\t    case 'utf16le':\n\t      // UTF-16 represents each of Surrogate Pair by 2-bytes\n\t      this.surrogateSize = 2;\n\t      this.detectIncompleteChar = utf16DetectIncompleteChar;\n\t      break;\n\t    case 'base64':\n\t      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n\t      this.surrogateSize = 3;\n\t      this.detectIncompleteChar = base64DetectIncompleteChar;\n\t      break;\n\t    default:\n\t      this.write = passThroughWrite;\n\t      return;\n\t  }\n\t\n\t  // Enough space to store all bytes of a single character. UTF-8 needs 4\n\t  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\t  this.charBuffer = new Buffer(6);\n\t  // Number of bytes received for the current incomplete multi-byte character.\n\t  this.charReceived = 0;\n\t  // Number of bytes expected for the current incomplete multi-byte character.\n\t  this.charLength = 0;\n\t};\n\t\n\t\n\t// write decodes the given buffer and returns it as JS string that is\n\t// guaranteed to not contain any partial multi-byte characters. Any partial\n\t// character found at the end of the buffer is buffered up, and will be\n\t// returned when calling write again with the remaining bytes.\n\t//\n\t// Note: Converting a Buffer containing an orphan surrogate to a String\n\t// currently works, but converting a String to a Buffer (via `new Buffer`, or\n\t// Buffer#write) will replace incomplete surrogates with the unicode\n\t// replacement character. See https://codereview.chromium.org/121173009/ .\n\tStringDecoder.prototype.write = function(buffer) {\n\t  var charStr = '';\n\t  // if our last write ended with an incomplete multibyte character\n\t  while (this.charLength) {\n\t    // determine how many remaining bytes this buffer has to offer for this char\n\t    var available = (buffer.length >= this.charLength - this.charReceived) ?\n\t        this.charLength - this.charReceived :\n\t        buffer.length;\n\t\n\t    // add the new bytes to the char buffer\n\t    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n\t    this.charReceived += available;\n\t\n\t    if (this.charReceived < this.charLength) {\n\t      // still not enough chars in this buffer? wait for more ...\n\t      return '';\n\t    }\n\t\n\t    // remove bytes belonging to the current character from the buffer\n\t    buffer = buffer.slice(available, buffer.length);\n\t\n\t    // get the character that was split\n\t    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\t\n\t    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t    var charCode = charStr.charCodeAt(charStr.length - 1);\n\t    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t      this.charLength += this.surrogateSize;\n\t      charStr = '';\n\t      continue;\n\t    }\n\t    this.charReceived = this.charLength = 0;\n\t\n\t    // if there are no more bytes in this buffer, just emit our char\n\t    if (buffer.length === 0) {\n\t      return charStr;\n\t    }\n\t    break;\n\t  }\n\t\n\t  // determine and set charLength / charReceived\n\t  this.detectIncompleteChar(buffer);\n\t\n\t  var end = buffer.length;\n\t  if (this.charLength) {\n\t    // buffer the incomplete character bytes we got\n\t    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n\t    end -= this.charReceived;\n\t  }\n\t\n\t  charStr += buffer.toString(this.encoding, 0, end);\n\t\n\t  var end = charStr.length - 1;\n\t  var charCode = charStr.charCodeAt(end);\n\t  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t    var size = this.surrogateSize;\n\t    this.charLength += size;\n\t    this.charReceived += size;\n\t    this.charBuffer.copy(this.charBuffer, size, 0, size);\n\t    buffer.copy(this.charBuffer, 0, 0, size);\n\t    return charStr.substring(0, end);\n\t  }\n\t\n\t  // or just emit the charStr\n\t  return charStr;\n\t};\n\t\n\t// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n\t// the end of the given buffer. If so, it sets this.charLength to the byte\n\t// length that character, and sets this.charReceived to the number of bytes\n\t// that are available for this character.\n\tStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n\t  // determine how many bytes we have to check at the end of this buffer\n\t  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\t\n\t  // Figure out if one of the last i bytes of our buffer announces an\n\t  // incomplete char.\n\t  for (; i > 0; i--) {\n\t    var c = buffer[buffer.length - i];\n\t\n\t    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\t\n\t    // 110XXXXX\n\t    if (i == 1 && c >> 5 == 0x06) {\n\t      this.charLength = 2;\n\t      break;\n\t    }\n\t\n\t    // 1110XXXX\n\t    if (i <= 2 && c >> 4 == 0x0E) {\n\t      this.charLength = 3;\n\t      break;\n\t    }\n\t\n\t    // 11110XXX\n\t    if (i <= 3 && c >> 3 == 0x1E) {\n\t      this.charLength = 4;\n\t      break;\n\t    }\n\t  }\n\t  this.charReceived = i;\n\t};\n\t\n\tStringDecoder.prototype.end = function(buffer) {\n\t  var res = '';\n\t  if (buffer && buffer.length)\n\t    res = this.write(buffer);\n\t\n\t  if (this.charReceived) {\n\t    var cr = this.charReceived;\n\t    var buf = this.charBuffer;\n\t    var enc = this.encoding;\n\t    res += buf.slice(0, cr).toString(enc);\n\t  }\n\t\n\t  return res;\n\t};\n\t\n\tfunction passThroughWrite(buffer) {\n\t  return buffer.toString(this.encoding);\n\t}\n\t\n\tfunction utf16DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 2;\n\t  this.charLength = this.charReceived ? 2 : 0;\n\t}\n\t\n\tfunction base64DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 3;\n\t  this.charLength = this.charReceived ? 3 : 0;\n\t}\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// a transform stream is a readable/writable stream where you do\n\t// something with the data.  Sometimes it's called a \"filter\",\n\t// but that's not a great name for it, since that implies a thing where\n\t// some bits pass through, and others are simply ignored.  (That would\n\t// be a valid example of a transform, of course.)\n\t//\n\t// While the output is causally related to the input, it's not a\n\t// necessarily symmetric or synchronous transformation.  For example,\n\t// a zlib stream might take multiple plain-text writes(), and then\n\t// emit a single compressed chunk some time in the future.\n\t//\n\t// Here's how this works:\n\t//\n\t// The Transform stream has all the aspects of the readable and writable\n\t// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n\t// internally, and returns false if there's a lot of pending writes\n\t// buffered up.  When you call read(), that calls _read(n) until\n\t// there's enough pending readable data buffered up.\n\t//\n\t// In a transform stream, the written data is placed in a buffer.  When\n\t// _read(n) is called, it transforms the queued up data, calling the\n\t// buffered _write cb's as it consumes chunks.  If consuming a single\n\t// written chunk would result in multiple output chunks, then the first\n\t// outputted bit calls the readcb, and subsequent chunks just go into\n\t// the read buffer, and will cause it to emit 'readable' if necessary.\n\t//\n\t// This way, back-pressure is actually determined by the reading side,\n\t// since _read has to be called to start processing a new chunk.  However,\n\t// a pathological inflate type of transform can cause excessive buffering\n\t// here.  For example, imagine a stream where every byte of input is\n\t// interpreted as an integer from 0-255, and then results in that many\n\t// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n\t// 1kb of data being output.  In this case, you could write a very small\n\t// amount of input, and end up with a very large amount of output.  In\n\t// such a pathological inflating mechanism, there'd be no way to tell\n\t// the system to stop doing the transform.  A single 4MB write could\n\t// cause the system to run out of memory.\n\t//\n\t// However, even in such a pathological case, only a single written chunk\n\t// would be consumed, and then the rest would wait (un-transformed) until\n\t// the results of the previous transformed chunk were consumed.\n\t\n\t'use strict';\n\t\n\tmodule.exports = Transform;\n\t\n\tvar Duplex = __webpack_require__(43);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(41);\n\tutil.inherits = __webpack_require__(36);\n\t/*</replacement>*/\n\t\n\tutil.inherits(Transform, Duplex);\n\t\n\tfunction TransformState(stream) {\n\t  this.afterTransform = function (er, data) {\n\t    return afterTransform(stream, er, data);\n\t  };\n\t\n\t  this.needTransform = false;\n\t  this.transforming = false;\n\t  this.writecb = null;\n\t  this.writechunk = null;\n\t  this.writeencoding = null;\n\t}\n\t\n\tfunction afterTransform(stream, er, data) {\n\t  var ts = stream._transformState;\n\t  ts.transforming = false;\n\t\n\t  var cb = ts.writecb;\n\t\n\t  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\t\n\t  ts.writechunk = null;\n\t  ts.writecb = null;\n\t\n\t  if (data !== null && data !== undefined) stream.push(data);\n\t\n\t  cb(er);\n\t\n\t  var rs = stream._readableState;\n\t  rs.reading = false;\n\t  if (rs.needReadable || rs.length < rs.highWaterMark) {\n\t    stream._read(rs.highWaterMark);\n\t  }\n\t}\n\t\n\tfunction Transform(options) {\n\t  if (!(this instanceof Transform)) return new Transform(options);\n\t\n\t  Duplex.call(this, options);\n\t\n\t  this._transformState = new TransformState(this);\n\t\n\t  // when the writable side finishes, then flush out anything remaining.\n\t  var stream = this;\n\t\n\t  // start out asking for a readable event once data is transformed.\n\t  this._readableState.needReadable = true;\n\t\n\t  // we have implemented the _read method, and done the other things\n\t  // that Readable wants before the first _read call, so unset the\n\t  // sync guard flag.\n\t  this._readableState.sync = false;\n\t\n\t  if (options) {\n\t    if (typeof options.transform === 'function') this._transform = options.transform;\n\t\n\t    if (typeof options.flush === 'function') this._flush = options.flush;\n\t  }\n\t\n\t  this.once('prefinish', function () {\n\t    if (typeof this._flush === 'function') this._flush(function (er) {\n\t      done(stream, er);\n\t    });else done(stream);\n\t  });\n\t}\n\t\n\tTransform.prototype.push = function (chunk, encoding) {\n\t  this._transformState.needTransform = false;\n\t  return Duplex.prototype.push.call(this, chunk, encoding);\n\t};\n\t\n\t// This is the part where you do stuff!\n\t// override this function in implementation classes.\n\t// 'chunk' is an input chunk.\n\t//\n\t// Call `push(newChunk)` to pass along transformed output\n\t// to the readable side.  You may call 'push' zero or more times.\n\t//\n\t// Call `cb(err)` when you are done with this chunk.  If you pass\n\t// an error, then that'll put the hurt on the whole operation.  If you\n\t// never call cb(), then you'll never get another chunk.\n\tTransform.prototype._transform = function (chunk, encoding, cb) {\n\t  throw new Error('Not implemented');\n\t};\n\t\n\tTransform.prototype._write = function (chunk, encoding, cb) {\n\t  var ts = this._transformState;\n\t  ts.writecb = cb;\n\t  ts.writechunk = chunk;\n\t  ts.writeencoding = encoding;\n\t  if (!ts.transforming) {\n\t    var rs = this._readableState;\n\t    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n\t  }\n\t};\n\t\n\t// Doesn't matter what the args are here.\n\t// _transform does all the work.\n\t// That we got here means that the readable side wants more data.\n\tTransform.prototype._read = function (n) {\n\t  var ts = this._transformState;\n\t\n\t  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n\t    ts.transforming = true;\n\t    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n\t  } else {\n\t    // mark that we need a transform, so that any data that comes in\n\t    // will get processed, now that we've asked for it.\n\t    ts.needTransform = true;\n\t  }\n\t};\n\t\n\tfunction done(stream, er) {\n\t  if (er) return stream.emit('error', er);\n\t\n\t  // if there's nothing in the write buffer, then that means\n\t  // that nothing more will ever be provided\n\t  var ws = stream._writableState;\n\t  var ts = stream._transformState;\n\t\n\t  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\t\n\t  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\t\n\t  return stream.push(null);\n\t}\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// a passthrough stream.\n\t// basically just the most minimal sort of Transform stream.\n\t// Every written chunk gets output as-is.\n\t\n\t'use strict';\n\t\n\tmodule.exports = PassThrough;\n\t\n\tvar Transform = __webpack_require__(48);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(41);\n\tutil.inherits = __webpack_require__(36);\n\t/*</replacement>*/\n\t\n\tutil.inherits(PassThrough, Transform);\n\t\n\tfunction PassThrough(options) {\n\t  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\t\n\t  Transform.call(this, options);\n\t}\n\t\n\tPassThrough.prototype._transform = function (chunk, encoding, cb) {\n\t  cb(null, chunk);\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(44)\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(43)\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(48)\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(49)\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar formatRegExp = /%[sdj%]/g;\n\texports.format = function(f) {\n\t  if (!isString(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\t\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect(x);\n\t    }\n\t  }\n\t  return str;\n\t};\n\t\n\t\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\texports.deprecate = function(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global.process)) {\n\t    return function() {\n\t      return exports.deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\t\n\t  if (process.noDeprecation === true) {\n\t    return fn;\n\t  }\n\t\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (process.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (process.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\t\n\t  return deprecated;\n\t};\n\t\n\t\n\tvar debugs = {};\n\tvar debugEnviron;\n\texports.debuglog = function(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = process.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = process.pid;\n\t      debugs[set] = function() {\n\t        var msg = exports.format.apply(exports, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t};\n\t\n\t\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    exports._extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\texports.inspect = inspect;\n\t\n\t\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\t\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\t\n\t\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect.styles[styleType];\n\t\n\t  if (style) {\n\t    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\t\n\t\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\t\n\t\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\t\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\t\n\t  return hash;\n\t}\n\t\n\t\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== exports.inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\t\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\t\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\t\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\t\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\t\n\t  var base = '', array = false, braces = ['{', '}'];\n\t\n\t  // Make Array say that they are Array\n\t  if (isArray(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\t\n\t  // Make functions say that they are functions\n\t  if (isFunction(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\t\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\t\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\t\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\t\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\t\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\t\n\t  ctx.seen.push(value);\n\t\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\t\n\t  ctx.seen.pop();\n\t\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\t\n\t\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\t\n\t\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\t\n\t\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\t\n\t\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\t\n\t  return name + ': ' + str;\n\t}\n\t\n\t\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var numLinesEst = 0;\n\t  var length = output.reduce(function(prev, cur) {\n\t    numLinesEst++;\n\t    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\t\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\t\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\t\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray(ar) {\n\t  return Array.isArray(ar);\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return isObject(re) && objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return isObject(d) && objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return isObject(e) &&\n\t      (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = __webpack_require__(55);\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t\n\tfunction pad(n) {\n\t  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n\t}\n\t\n\t\n\tvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n\t              'Oct', 'Nov', 'Dec'];\n\t\n\t// 26 Feb 16:19:34\n\tfunction timestamp() {\n\t  var d = new Date();\n\t  var time = [pad(d.getHours()),\n\t              pad(d.getMinutes()),\n\t              pad(d.getSeconds())].join(':');\n\t  return [d.getDate(), months[d.getMonth()], time].join(' ');\n\t}\n\t\n\t\n\t// log is just a thin wrapper to console.log that prepends a timestamp\n\texports.log = function() {\n\t  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n\t};\n\t\n\t\n\t/**\n\t * Inherit the prototype methods from one constructor into another.\n\t *\n\t * The Function.prototype.inherits from lang.js rewritten as a standalone\n\t * function (not on Function.prototype). NOTE: If this file is to be loaded\n\t * during bootstrapping this function needs to be rewritten using some native\n\t * functions as prototype setup using normal JavaScript does not work as\n\t * expected during bootstrapping (see mirror.js in r114903).\n\t *\n\t * @param {function} ctor Constructor function which needs to inherit the\n\t *     prototype.\n\t * @param {function} superCtor Constructor function to inherit prototype from.\n\t */\n\texports.inherits = __webpack_require__(36);\n\t\n\texports._extend = function(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject(add)) return origin;\n\t\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t};\n\t\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(25)))\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function isBuffer(arg) {\n\t  return arg && typeof arg === 'object'\n\t    && typeof arg.copy === 'function'\n\t    && typeof arg.fill === 'function'\n\t    && typeof arg.readUInt8 === 'function';\n\t}\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * Copyright 2014 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t\n\tvar Duplex = __webpack_require__(34).Duplex;\n\tvar util = __webpack_require__(54);\n\tvar pick = __webpack_require__(57);\n\tvar W3CWebSocket = __webpack_require__(59).w3cwebsocket;\n\tvar contentType = __webpack_require__(62);\n\tvar defaults = __webpack_require__(63);\n\tvar qs = __webpack_require__(65);\n\t\n\tvar OPENING_MESSAGE_PARAMS_ALLOWED = ['continuous', 'max_alternatives', 'timestamps', 'word_confidence', 'inactivity_timeout',\n\t  'content-type', 'interim_results', 'keywords', 'keywords_threshold', 'word_alternatives_threshold', 'profanity_filter', 'smart_formatting'];\n\t\n\tvar QUERY_PARAMS_ALLOWED = ['model', 'watson-token']; // , 'X-Watson-Learning-Opt-Out' - should be allowed but currently isn't due to a service bug\n\t\n\t\n\t/**\n\t * pipe()-able Node.js Readable/Writeable stream - accepts binary audio and emits text/objects in it's `data` events.\n\t *\n\t * Uses WebSockets under the hood. For audio with no recognizable speech, no `data` events are emitted.\n\t *\n\t * By default, only finalized text is emitted in the data events, however in `readableObjectMode` (usually just `objectMode` when using a helper method).\n\t *\n\t *  An interim result looks like this:\n\t ```js\n\t { alternatives:\n\t   [ { timestamps:\n\t        [ [ 'it', 20.9, 21.04 ],\n\t          [ 'is', 21.04, 21.17 ],\n\t          [ 'a', 21.17, 21.25 ],\n\t          [ 'site', 21.25, 21.56 ],\n\t          [ 'that', 21.56, 21.7 ],\n\t          [ 'hardly', 21.7, 22.06 ],\n\t          [ 'anyone', 22.06, 22.49 ],\n\t          [ 'can', 22.49, 22.67 ],\n\t          [ 'behold', 22.67, 23.13 ],\n\t          [ 'without', 23.13, 23.46 ],\n\t          [ 'some', 23.46, 23.67 ],\n\t          [ 'sort', 23.67, 23.91 ],\n\t          [ 'of', 23.91, 24 ],\n\t          [ 'unwanted', 24, 24.58 ],\n\t          [ 'emotion', 24.58, 25.1 ] ],\n\t       transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotion ' } ],\n\t  final: false,\n\t  result_index: 3 }\n\t ```\n\t\n\t While a final result looks like this (some features only appear in final results):\n\t ```js\n\t  { alternatives:\n\t     [ { word_confidence:\n\t          [ [ 'it', 1 ],\n\t            [ 'is', 0.956286624429304 ],\n\t            [ 'a', 0.8105753725270362 ],\n\t            [ 'site', 1 ],\n\t            [ 'that', 1 ],\n\t            [ 'hardly', 1 ],\n\t            [ 'anyone', 1 ],\n\t            [ 'can', 1 ],\n\t            [ 'behold', 0.5273598005406737 ],\n\t            [ 'without', 1 ],\n\t            [ 'some', 1 ],\n\t            [ 'sort', 1 ],\n\t            [ 'of', 1 ],\n\t            [ 'unwanted', 1 ],\n\t            [ 'emotion', 0.49401837076320887 ] ],\n\t         confidence: 0.881,\n\t         transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotion ',\n\t         timestamps:\n\t          [ [ 'it', 20.9, 21.04 ],\n\t            [ 'is', 21.04, 21.17 ],\n\t            [ 'a', 21.17, 21.25 ],\n\t            [ 'site', 21.25, 21.56 ],\n\t            [ 'that', 21.56, 21.7 ],\n\t            [ 'hardly', 21.7, 22.06 ],\n\t            [ 'anyone', 22.06, 22.49 ],\n\t            [ 'can', 22.49, 22.67 ],\n\t            [ 'behold', 22.67, 23.13 ],\n\t            [ 'without', 23.13, 23.46 ],\n\t            [ 'some', 23.46, 23.67 ],\n\t            [ 'sort', 23.67, 23.91 ],\n\t            [ 'of', 23.91, 24 ],\n\t            [ 'unwanted', 24, 24.58 ],\n\t            [ 'emotion', 24.58, 25.1 ] ] },\n\t       { transcript: 'it is a sight that hardly anyone can behold without some sort of unwanted emotion ' },\n\t       { transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotions ' } ],\n\t    final: true,\n\t    result_index: 3 }\n\t ```\n\t\n\t *\n\t * @param {Object} options\n\t * @param {String} [options.model='en-US_BroadbandModel'] - voice model to use. Microphone streaming only supports broadband models.\n\t * @param {String} [options.url='wss://stream.watsonplatform.net/speech-to-text/api'] base URL for service\n\t * @param {String} [options.content-type='audio/wav'] - content type of audio; can be automatically determined from file header in most cases. only wav, flac, and ogg/opus are supported\n\t * @param {Boolean} [options.interim_results=true] - Send back non-final previews of each \"sentence\" as it is being processed. These results are ignored in text mode.\n\t * @param {Boolean} [options.continuous=true] - set to false to automatically stop the transcription after the first \"sentence\"\n\t * @param {Boolean} [options.word_confidence=false] - include confidence scores with results. Defaults to true when in objectMode.\n\t * @param {Boolean} [options.timestamps=false] - include timestamps with results. Defaults to true when in objectMode.\n\t * @param {Number} [options.max_alternatives=1] - maximum number of alternative transcriptions to include. Defaults to 3 when in objectMode.\n\t * @param {Array<String>} [options.keywords] - a list of keywords to search for in the audio\n\t * @param {Number} [options.keywords_threshold] - Number between 0 and 1 representing the minimum confidence before including a keyword in the results. Required when options.keywords is set\n\t * @param {Number} [options.word_alternatives_threshold] - Number between 0 and 1 representing the minimum confidence before including an alternative word in the results. Must be set to enable word alternatives,\n\t * @param {Boolean} [options.profanity_filter=false] - set to true to filter out profanity and replace the words with *'s\n\t * @param {Number} [options.inactivity_timeout=30] - how many seconds of silence before automatically closing the stream (even if continuous is true). use -1 for infinity\n\t * @param {Boolean} [options.readableObjectMode=false] - emit `result` objects instead of string Buffers for the `data` events. Changes several other defaults.\n\t * @param {Number} [options.X-WDC-PL-OPT-OUT=0] - set to 1 to opt-out of allowing Watson to use this request to improve it's services\n\t * @param {Boolean} [options.smart_formatting=false] - formats numeric values such as dates, times, currency, etc.\n\t *\n\t * @constructor\n\t */\n\tfunction RecognizeStream(options) {\n\t  Duplex.call(this, options);\n\t  this.options = options;\n\t  this.listening = false;\n\t  this.initialized = false;\n\t  this.finished = false;\n\t  var self = this;\n\t\n\t  /**\n\t   * listening for `results` events should put the stream in flowing mode just like `data` events\n\t   *\n\t   * @param {String} event\n\t   */\n\t  function flowForResults(event) {\n\t    if (event === 'results' || event === 'result') {\n\t      self.removeListener('newListener', flowForResults);\n\t      process.nextTick(function() {\n\t        self.on('data', function() {\n\t        }); // todo: is there a better way to put a stream in flowing mode?\n\t      });\n\t      if (!options.silent) {\n\t        // todo: move this to the node.js wrapper\n\t        // eslint-disable-next-line no-console\n\t        console.log(new Error('Watson Speech to Text RecognizeStream: the ' + event + ' event is deprecated and will be removed from a future release. ' +\n\t          'Please set {objectMode: true} and listen for the data event instead. ' +\n\t          'Pass {silent: true} to disable this message.'));\n\t      }\n\t    }\n\t  }\n\t  this.on('newListener', flowForResults);\n\t}\n\tutil.inherits(RecognizeStream, Duplex);\n\t\n\t\n\tRecognizeStream.prototype.initialize = function() {\n\t  var options = this.options;\n\t\n\t  // todo: apply these corrections to other methods (?)\n\t  if (options.token && !options['watson-token']) {\n\t    options['watson-token'] = options.token;\n\t  }\n\t  if (options.content_type && !options['content-type']) {\n\t    options['content-type'] = options.content_type;\n\t  }\n\t  if (options['X-WDC-PL-OPT-OUT'] && !options['X-Watson-Learning-Opt-Out']) {\n\t    options['X-Watson-Learning-Opt-Out'] = options['X-WDC-PL-OPT-OUT'];\n\t  }\n\t\n\t  var queryParams = util._extend({model: 'en-US_BroadbandModel'}, pick(options, QUERY_PARAMS_ALLOWED));\n\t  var queryString = qs.stringify(queryParams);\n\t  var url = (options.url || 'wss://stream.watsonplatform.net/speech-to-text/api').replace(/^http/, 'ws') + '/v1/recognize?' + queryString;\n\t\n\t  // turn off all the extras if we're just outputting text\n\t  var textModeDefaults = {\n\t    action: 'start',\n\t    'content-type': 'audio/wav',\n\t    continuous: true,\n\t    inactivity_timeout: 30,\n\t    interim_results: true,\n\t    word_confidence: false,\n\t    timestamps: false,\n\t    max_alternatives: 1\n\t  };\n\t\n\t  // but turn everything on if we're in objectMode and the end user can consume it\n\t  var objectModeDefaults = {\n\t    action: 'start',\n\t    'content-type': 'audio/wav',\n\t    continuous: true,\n\t    inactivity_timeout: 30,\n\t    interim_results: true,\n\t    word_confidence: false,\n\t    timestamps: false,\n\t    max_alternatives: 1\n\t  };\n\t\n\t  var openingMessage = defaults(\n\t    pick(options, OPENING_MESSAGE_PARAMS_ALLOWED),\n\t    (options.objectMode || options.readableObjectMode) ? objectModeDefaults : textModeDefaults\n\t  );\n\t\n\t  var self = this;\n\t\n\t  // node params: requestUrl, protocols, origin, headers, extraRequestOptions\n\t  // browser params: requestUrl, protocols (all others ignored)\n\t  var socket = this.socket = new W3CWebSocket(url, null, null, options.headers, null);\n\t\n\t  // when the input stops, let the service know that we're done\n\t  self.on('finish', self.finish.bind(self));\n\t\n\t  socket.onerror = function(error) {\n\t    self.listening = false;\n\t    self.emit('error', error);\n\t  };\n\t\n\t\n\t  this.socket.onopen = function() {\n\t    self.sendJSON(openingMessage);\n\t    self.emit('connect');\n\t  };\n\t\n\t  this.socket.onclose = function(e) {\n\t    if (self.listening) {\n\t      self.listening = false;\n\t      self.push(null);\n\t    }\n\t    /**\n\t     * @event RecognizeStream#close\n\t     * @param {Number} reasonCode\n\t     * @param {String} description\n\t     */\n\t    self.emit('close', e.code, e.reason);\n\t    /**\n\t     * @event RecognizeStream#connection-close\n\t     * @param {Number} reasonCode\n\t     * @param {String} description\n\t     * @deprecated\n\t     */\n\t    self.emit('connection-close', e.code, e.reason);\n\t  };\n\t\n\t  /**\n\t   * @event RecognizeStream#error\n\t   * @param {String} msg custom error message\n\t   * @param {*} [frame] unprocessed frame (should have a .data property with either string or binary data)\n\t   * @param {Error} [err]\n\t   */\n\t  function emitError(msg, frame, err) {\n\t    if (err) {\n\t      err.message = msg + ' ' + err.message;\n\t    } else {\n\t      err = new Error(msg);\n\t    }\n\t    err.raw = frame;\n\t    self.emit('error', err);\n\t  }\n\t\n\t  socket.onmessage = function(frame) {\n\t    if (typeof frame.data !== 'string') {\n\t      return emitError('Unexpected binary data received from server', frame);\n\t    }\n\t\n\t    var data;\n\t    try {\n\t      data = JSON.parse(frame.data);\n\t    } catch (jsonEx) {\n\t      return emitError('Invalid JSON received from service:', frame, jsonEx);\n\t    }\n\t\n\t    /**\n\t     * @event RecognizeStream#receive-json\n\t     * @param {Object} msg - the raw JSON received from Watson - sometimes useful for debugging\n\t     */\n\t    self.emit('receive-json', data);\n\t\n\t    if (data.error) {\n\t      emitError(data.error, frame);\n\t    } else if (data.state === 'listening') {\n\t      // this is emitted both when the server is ready for audio, and after we send the close message to indicate that it's done processing\n\t      if (self.listening) {\n\t        self.listening = false;\n\t        self.push(null);\n\t        socket.close();\n\t      } else {\n\t        self.listening = true;\n\t        self.emit('listening');\n\t      }\n\t    } else if (data.results) {\n\t      /**\n\t       * Object with array of interim or final results, possibly including confidence scores, alternatives, and word timing. May have no results at all for empty audio files.\n\t       * @event RecognizeStream#results\n\t       * @param {Object} results\n\t       * @deprecated - use objectMode and listen for the 'data' event instead\n\t       */\n\t      self.emit('results', data.results);\n\t\n\t      // note: currently there is always either 0 or 1 entries in the results array. However, this may change in the future.\n\t      data.results.forEach(function(result) {\n\t        result.index = data.result_index;\n\t        /**\n\t         * Object with interim or final results, possibly including confidence scores, alternatives, and word timing.\n\t         * @event RecognizeStream#results\n\t         * @param {Object} results\n\t         * @deprecated - use objectMode and listen for the 'data' event instead\n\t         */\n\t        self.emit('result', result);\n\t        if (options.objectMode || options.readableObjectMode) {\n\t          /**\n\t           * Object with interim or final results, possibly including confidence scores, alternatives, and word timing.\n\t           * @event RecognizeStream#data\n\t           * @param {Object} data\n\t           */\n\t          self.push(result);\n\t        } else if (result.final && result.alternatives) {\n\t          /**\n\t           * Finalized text\n\t           * @event RecognizeStream#data\n\t           * @param {String} transcript\n\t           */\n\t          self.push(result.alternatives[0].transcript, 'utf8');\n\t        }\n\t      });\n\t    } else {\n\t      emitError('Unrecognised message from server', frame);\n\t    }\n\t  };\n\t\n\t  this.initialized = true;\n\t};\n\t\n\tRecognizeStream.prototype.sendJSON = function sendJSON(msg) {\n\t  /**\n\t   * @event RecognizeStream#send-json\n\t   * @param {Object} msg - the raw JSON sent to Watson - sometimes useful for debugging\n\t   */\n\t  this.emit('send-json', msg);\n\t  return this.socket.send(JSON.stringify(msg));\n\t};\n\t\n\tRecognizeStream.prototype.sendData = function sendData(data) {\n\t  this.emit('send-data', data);\n\t  return this.socket.send(data);\n\t};\n\t\n\tRecognizeStream.prototype._read = function(/* size*/) {\n\t  // there's no easy way to control reads from the underlying library\n\t  // so, the best we can do here is a no-op\n\t};\n\t\n\tRecognizeStream.prototype._write = function(chunk, encoding, callback) {\n\t  var self = this;\n\t  if (self.finished) {\n\t    // can't send any more data after the stop message (although this shouldn't happen normally...)\n\t    return;\n\t  }\n\t  if (self.listening) {\n\t    self.sendData(chunk);\n\t    this.afterSend(callback);\n\t  } else {\n\t    if (!this.initialized) {\n\t      if (!this.options['content-type']) {\n\t        this.options['content-type'] = RecognizeStream.getContentType(chunk);\n\t      }\n\t      this.initialize();\n\t    }\n\t    this.once('listening', function() {\n\t      self.sendData(chunk);\n\t      self.afterSend(callback);\n\t    });\n\t  }\n\t};\n\t\n\t// flow control - don't ask for more data until we've finished what we have\n\t// todo: see if this can be improved\n\tRecognizeStream.prototype.afterSend = function afterSend(next) {\n\t  if (this.socket.bufferedAmount <= this._writableState.highWaterMark || 0) {\n\t    next(); // eslint-disable-line callback-return\n\t  } else {\n\t    setTimeout(this.afterSend.bind(this, next), 10);\n\t  }\n\t};\n\t\n\tRecognizeStream.prototype.stop = function() {\n\t  this.emit('stop');\n\t  this.finish();\n\t};\n\t\n\tRecognizeStream.prototype.finish = function finish() {\n\t  // this is called both when the source stream finishes, and when .stop() is fired, but we only want to send the stop message once.\n\t  if (this.finished) {\n\t    return;\n\t  }\n\t  this.finished = true;\n\t  var self = this;\n\t  var closingMessage = {action: 'stop'};\n\t  if (self.socket && self.socket.readyState !== self.socket.CLOSED && self.socket.readyState !== self.socket.CLOSING) {\n\t    self.sendJSON(closingMessage);\n\t  } else {\n\t    this.once('connect', function() {\n\t      self.sendJSON(closingMessage);\n\t    });\n\t  }\n\t};\n\t\n\tRecognizeStream.prototype.promise = __webpack_require__(66);\n\t\n\t\n\tRecognizeStream.getContentType = function(buffer) {\n\t  return contentType(buffer.slice(0, 4).toString());\n\t};\n\t\n\t\n\tmodule.exports = RecognizeStream;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * object.pick <https://github.com/jonschlinkert/object.pick>\n\t *\n\t * Copyright (c) 2014-2015 Jon Schlinkert, contributors.\n\t * Licensed under the MIT License\n\t */\n\t\n\t'use strict';\n\t\n\tvar isObject = __webpack_require__(58);\n\t\n\tmodule.exports = function pick(obj, keys) {\n\t  if (!isObject(obj) && typeof obj !== 'function') {\n\t    return {};\n\t  }\n\t\n\t  var res = {};\n\t  if (typeof keys === 'string') {\n\t    if (keys in obj) {\n\t      res[keys] = obj[keys];\n\t    }\n\t    return res;\n\t  }\n\t\n\t  var len = keys.length;\n\t  var idx = -1;\n\t\n\t  while (++idx < len) {\n\t    var key = keys[idx];\n\t    if (key in obj) {\n\t      res[key] = obj[key];\n\t    }\n\t  }\n\t  return res;\n\t};\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * isobject <https://github.com/jonschlinkert/isobject>\n\t *\n\t * Copyright (c) 2014-2015, Jon Schlinkert.\n\t * Licensed under the MIT License.\n\t */\n\t\n\t'use strict';\n\t\n\tvar isArray = __webpack_require__(30);\n\t\n\tmodule.exports = function isObject(val) {\n\t  return val != null && typeof val === 'object' && isArray(val) === false;\n\t};\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar _global = (function() { return this; })();\n\tvar nativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\tvar websocket_version = __webpack_require__(60);\n\t\n\t\n\t/**\n\t * Expose a W3C WebSocket class with just one or two arguments.\n\t */\n\tfunction W3CWebSocket(uri, protocols) {\n\t\tvar native_instance;\n\t\n\t\tif (protocols) {\n\t\t\tnative_instance = new nativeWebSocket(uri, protocols);\n\t\t}\n\t\telse {\n\t\t\tnative_instance = new nativeWebSocket(uri);\n\t\t}\n\t\n\t\t/**\n\t\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t\t * class). Since it is an Object it will be returned as it is when creating an\n\t\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t\t *\n\t\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t\t */\n\t\treturn native_instance;\n\t}\n\t\n\t\n\t/**\n\t * Module exports.\n\t */\n\tmodule.exports = {\n\t    'w3cwebsocket' : nativeWebSocket ? W3CWebSocket : null,\n\t    'version'      : websocket_version\n\t};\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(61).version;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"_args\": [\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"websocket\",\n\t\t\t\t\t\"raw\": \"websocket@^1.0.22\",\n\t\t\t\t\t\"rawSpec\": \"^1.0.22\",\n\t\t\t\t\t\"scope\": null,\n\t\t\t\t\t\"spec\": \">=1.0.22 <2.0.0\",\n\t\t\t\t\t\"type\": \"range\"\n\t\t\t\t},\n\t\t\t\t\"/Users/nboyko/Sites/wellspeak/node_modules/watson-speech\"\n\t\t\t]\n\t\t],\n\t\t\"_from\": \"websocket@>=1.0.22 <2.0.0\",\n\t\t\"_id\": \"websocket@1.0.23\",\n\t\t\"_inCache\": true,\n\t\t\"_installable\": true,\n\t\t\"_location\": \"/websocket\",\n\t\t\"_nodeVersion\": \"0.10.45\",\n\t\t\"_npmOperationalInternal\": {\n\t\t\t\"host\": \"packages-16-east.internal.npmjs.com\",\n\t\t\t\"tmp\": \"tmp/websocket-1.0.23.tgz_1463625793005_0.4532310354989022\"\n\t\t},\n\t\t\"_npmUser\": {\n\t\t\t\"email\": \"brian@worlize.com\",\n\t\t\t\"name\": \"theturtle32\"\n\t\t},\n\t\t\"_npmVersion\": \"2.15.1\",\n\t\t\"_phantomChildren\": {},\n\t\t\"_requested\": {\n\t\t\t\"name\": \"websocket\",\n\t\t\t\"raw\": \"websocket@^1.0.22\",\n\t\t\t\"rawSpec\": \"^1.0.22\",\n\t\t\t\"scope\": null,\n\t\t\t\"spec\": \">=1.0.22 <2.0.0\",\n\t\t\t\"type\": \"range\"\n\t\t},\n\t\t\"_requiredBy\": [\n\t\t\t\"/watson-speech\"\n\t\t],\n\t\t\"_resolved\": \"https://registry.npmjs.org/websocket/-/websocket-1.0.23.tgz\",\n\t\t\"_shasum\": \"20de8ec4a7126b09465578cd5dbb29a9c296aac6\",\n\t\t\"_shrinkwrap\": null,\n\t\t\"_spec\": \"websocket@^1.0.22\",\n\t\t\"_where\": \"/Users/nboyko/Sites/wellspeak/node_modules/watson-speech\",\n\t\t\"author\": {\n\t\t\t\"email\": \"brian@worlize.com\",\n\t\t\t\"name\": \"Brian McKelvey\",\n\t\t\t\"url\": \"https://www.worlize.com/\"\n\t\t},\n\t\t\"browser\": \"lib/browser.js\",\n\t\t\"bugs\": {\n\t\t\t\"url\": \"https://github.com/theturtle32/WebSocket-Node/issues\"\n\t\t},\n\t\t\"config\": {\n\t\t\t\"verbose\": false\n\t\t},\n\t\t\"contributors\": [\n\t\t\t{\n\t\t\t\t\"email\": \"ibc@aliax.net\",\n\t\t\t\t\"name\": \"Iaki Baz Castillo\",\n\t\t\t\t\"url\": \"http://dev.sipdoc.net\"\n\t\t\t}\n\t\t],\n\t\t\"dependencies\": {\n\t\t\t\"debug\": \"^2.2.0\",\n\t\t\t\"nan\": \"^2.3.3\",\n\t\t\t\"typedarray-to-buffer\": \"^3.1.2\",\n\t\t\t\"yaeti\": \"^0.0.4\"\n\t\t},\n\t\t\"description\": \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\n\t\t\"devDependencies\": {\n\t\t\t\"buffer-equal\": \"^0.0.1\",\n\t\t\t\"faucet\": \"^0.0.1\",\n\t\t\t\"gulp\": \"git+https://github.com/gulpjs/gulp.git#4.0\",\n\t\t\t\"gulp-jshint\": \"^1.11.2\",\n\t\t\t\"jshint-stylish\": \"^1.0.2\",\n\t\t\t\"tape\": \"^4.0.1\"\n\t\t},\n\t\t\"directories\": {\n\t\t\t\"lib\": \"./lib\"\n\t\t},\n\t\t\"dist\": {\n\t\t\t\"shasum\": \"20de8ec4a7126b09465578cd5dbb29a9c296aac6\",\n\t\t\t\"tarball\": \"https://registry.npmjs.org/websocket/-/websocket-1.0.23.tgz\"\n\t\t},\n\t\t\"engines\": {\n\t\t\t\"node\": \">=0.8.0\"\n\t\t},\n\t\t\"gitHead\": \"ba2fa7e9676c456bcfb12ad160655319af66faed\",\n\t\t\"homepage\": \"https://github.com/theturtle32/WebSocket-Node\",\n\t\t\"keywords\": [\n\t\t\t\"websocket\",\n\t\t\t\"websockets\",\n\t\t\t\"socket\",\n\t\t\t\"networking\",\n\t\t\t\"comet\",\n\t\t\t\"push\",\n\t\t\t\"RFC-6455\",\n\t\t\t\"realtime\",\n\t\t\t\"server\",\n\t\t\t\"client\"\n\t\t],\n\t\t\"license\": \"Apache-2.0\",\n\t\t\"main\": \"index\",\n\t\t\"maintainers\": [\n\t\t\t{\n\t\t\t\t\"email\": \"brian@worlize.com\",\n\t\t\t\t\"name\": \"theturtle32\"\n\t\t\t}\n\t\t],\n\t\t\"name\": \"websocket\",\n\t\t\"optionalDependencies\": {},\n\t\t\"readme\": \"ERROR: No README data found!\",\n\t\t\"repository\": {\n\t\t\t\"type\": \"git\",\n\t\t\t\"url\": \"git+https://github.com/theturtle32/WebSocket-Node.git\"\n\t\t},\n\t\t\"scripts\": {\n\t\t\t\"gulp\": \"gulp\",\n\t\t\t\"install\": \"(node-gyp rebuild 2> builderror.log) || (exit 0)\",\n\t\t\t\"test\": \"faucet test/unit\"\n\t\t},\n\t\t\"version\": \"1.0.23\"\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// these are the only content-types currently supported by the speech-to-tet service\n\tvar contentTypes = {\n\t  fLaC: 'audio/flac',\n\t  RIFF: 'audio/wav',\n\t  OggS: 'audio/ogg; codecs=opus'\n\t};\n\t\n\t/**\n\t * Takes the beginning of an audio file and returns the associated content-type / mime type\n\t *\n\t * @param {String} header first 4 characters of the file as a UTF-8 string\n\t * @returns {String|undefined} - the contentType of undefined\n\t */\n\tmodule.exports = function contentType(header) {\n\t  return contentTypes[header];\n\t};\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar clone = __webpack_require__(64);\n\t\n\tmodule.exports = function(options, defaults) {\n\t  options = options || {};\n\t\n\t  Object.keys(defaults).forEach(function(key) {\n\t    if (typeof options[key] === 'undefined') {\n\t      options[key] = clone(defaults[key]);\n\t    }\n\t  });\n\t\n\t  return options;\n\t};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n\t'use strict';\n\t\n\t/**\n\t * Clones (copies) an Object using deep copying.\n\t *\n\t * This function supports circular references by default, but if you are certain\n\t * there are no circular references in your object, you can save some CPU time\n\t * by calling clone(obj, false).\n\t *\n\t * Caution: if `circular` is false and `parent` contains circular references,\n\t * your program may enter an infinite loop and crash.\n\t *\n\t * @param `parent` - the object to be cloned\n\t * @param `circular` - set to true if the object to be cloned may contain\n\t *    circular references. (optional - true by default)\n\t * @param `depth` - set to a number if the object is only to be cloned to\n\t *    a particular depth. (optional - defaults to Infinity)\n\t * @param `prototype` - sets the prototype to be used when cloning an object.\n\t *    (optional - defaults to parent prototype).\n\t*/\n\tfunction clone(parent, circular, depth, prototype) {\n\t  var filter;\n\t  if (typeof circular === 'object') {\n\t    depth = circular.depth;\n\t    prototype = circular.prototype;\n\t    filter = circular.filter;\n\t    circular = circular.circular\n\t  }\n\t  // maintain two arrays for circular references, where corresponding parents\n\t  // and children have the same index\n\t  var allParents = [];\n\t  var allChildren = [];\n\t\n\t  var useBuffer = typeof Buffer != 'undefined';\n\t\n\t  if (typeof circular == 'undefined')\n\t    circular = true;\n\t\n\t  if (typeof depth == 'undefined')\n\t    depth = Infinity;\n\t\n\t  // recurse this function so we don't reset allParents and allChildren\n\t  function _clone(parent, depth) {\n\t    // cloning null always returns null\n\t    if (parent === null)\n\t      return null;\n\t\n\t    if (depth == 0)\n\t      return parent;\n\t\n\t    var child;\n\t    var proto;\n\t    if (typeof parent != 'object') {\n\t      return parent;\n\t    }\n\t\n\t    if (clone.__isArray(parent)) {\n\t      child = [];\n\t    } else if (clone.__isRegExp(parent)) {\n\t      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\t      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\t    } else if (clone.__isDate(parent)) {\n\t      child = new Date(parent.getTime());\n\t    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\t      child = new Buffer(parent.length);\n\t      parent.copy(child);\n\t      return child;\n\t    } else {\n\t      if (typeof prototype == 'undefined') {\n\t        proto = Object.getPrototypeOf(parent);\n\t        child = Object.create(proto);\n\t      }\n\t      else {\n\t        child = Object.create(prototype);\n\t        proto = prototype;\n\t      }\n\t    }\n\t\n\t    if (circular) {\n\t      var index = allParents.indexOf(parent);\n\t\n\t      if (index != -1) {\n\t        return allChildren[index];\n\t      }\n\t      allParents.push(parent);\n\t      allChildren.push(child);\n\t    }\n\t\n\t    for (var i in parent) {\n\t      var attrs;\n\t      if (proto) {\n\t        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\t      }\n\t\n\t      if (attrs && attrs.set == null) {\n\t        continue;\n\t      }\n\t      child[i] = _clone(parent[i], depth - 1);\n\t    }\n\t\n\t    return child;\n\t  }\n\t\n\t  return _clone(parent, depth);\n\t}\n\t\n\t/**\n\t * Simple flat clone using prototype, accepts only objects, usefull for property\n\t * override on FLAT configuration object (no nested props).\n\t *\n\t * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\t * works.\n\t */\n\tclone.clonePrototype = function clonePrototype(parent) {\n\t  if (parent === null)\n\t    return null;\n\t\n\t  var c = function () {};\n\t  c.prototype = parent;\n\t  return new c();\n\t};\n\t\n\t// private utility functions\n\t\n\tfunction __objToStr(o) {\n\t  return Object.prototype.toString.call(o);\n\t};\n\tclone.__objToStr = __objToStr;\n\t\n\tfunction __isDate(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\t};\n\tclone.__isDate = __isDate;\n\t\n\tfunction __isArray(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\t};\n\tclone.__isArray = __isArray;\n\t\n\tfunction __isRegExp(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\t};\n\tclone.__isRegExp = __isRegExp;\n\t\n\tfunction __getRegExpFlags(re) {\n\t  var flags = '';\n\t  if (re.global) flags += 'g';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.multiline) flags += 'm';\n\t  return flags;\n\t};\n\tclone.__getRegExpFlags = __getRegExpFlags;\n\t\n\treturn clone;\n\t})();\n\t\n\tif (typeof module === 'object' && module.exports) {\n\t  module.exports = clone;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify query params, Watson-style\n\t *\n\t * Why? The server that processes auth tokens currently only accepts the *exact* string, even if it's invalid for a URL.\n\t * Properly url-encoding percent characters causes it to reject the token.\n\t * So, this is a custom qs.stringify function that properly encodes everything except watson-token, passing it along verbatim\n\t *\n\t * @param {Object} queryParams\n\t * @return {String}\n\t */\n\texports.stringify = function stringify(queryParams) {\n\t  return Object.keys(queryParams).map(function(key) {\n\t    return key + '=' + (key === 'watson-token' ? queryParams[key] : encodeURIComponent(queryParams[key])); // the server chokes if the token is correctly url-encoded\n\t  }).join('&');\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t/**\n\t * Helper method that can be bound to a stream - it sets the output to utf-8, captures all of the results, and returns a promise that resolves to the final text.\n\t * Essentially a smaller version of concat-stream wrapped in a promise\n\t *\n\t * @param {Stream} [stream=] optional stream param for when not bound to an existing stream instance\n\t * @return {Promise}\n\t */\n\tmodule.exports = function promise(stream) {\n\t  stream = stream || this;\n\t  return new Promise(function(resolve, reject) {\n\t    var results = [];\n\t    stream.on('data', function(result) {\n\t      results.push(result);\n\t    }).on('end', function() {\n\t      resolve(Buffer.isBuffer(results[0]) ? Buffer.concat(results).toString() : results);\n\t    }).on('error', reject);\n\t  });\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';\n\tvar Transform = __webpack_require__(34).Transform;\n\tvar util = __webpack_require__(54);\n\tvar defaults = __webpack_require__(63);\n\t\n\tvar TARGET_SAMPLE_RATE = 16000;\n\t/**\n\t * Transforms Buffers or AudioBuffers into a binary stream of l16 (raw wav) audio, downsampling in the process.\n\t *\n\t * The watson speech-to-text service works on 1600khz and internally downsamples audio received at higher samplerates.\n\t * WebAudio is usually 48000khz, so downsampling here reduces bandwidth usage by 2/3.\n\t *\n\t * Format event + stream can be combined with https://www.npmjs.com/package/wav to generate a wav file with a proper header\n\t *\n\t * Todo: support multi-channel audio (for use with <audio>/<video> elements) - will require interleaving audio channels\n\t *\n\t * @param {Object} options\n\t * @constructor\n\t */\n\tfunction WebAudioL16Stream(options) {\n\t  options = this.options = defaults(options, {\n\t    sourceSampleRate: 48000,\n\t    downsample: true\n\t  });\n\t\n\t  Transform.call(this, options);\n\t\n\t  this.bufferUnusedSamples = [];\n\t\n\t  if (options.objectMode || options.writableObjectMode) {\n\t    this._transform = this.handleFirstAudioBuffer;\n\t  } else {\n\t    this._transform = this.transformBuffer;\n\t    process.nextTick(this.emitFormat.bind(this));\n\t  }\n\t\n\t}\n\tutil.inherits(WebAudioL16Stream, Transform);\n\t\n\t\n\tWebAudioL16Stream.prototype.emitFormat = function emitFormat() {\n\t  this.emit('format', {\n\t    channels: 1,\n\t    bitDepth: 16,\n\t    sampleRate: this.options.downsample ? TARGET_SAMPLE_RATE : this.options.sourceSampleRate,\n\t    signed: true,\n\t    float: false\n\t  });\n\t};\n\t\n\t/**\n\t * Downsamples WebAudio to 16 kHz.\n\t *\n\t * Browsers can downsample WebAudio natively with OfflineAudioContext's but it was designed for non-streaming use and\n\t * requires a new context for each AudioBuffer. Firefox can handle this, but chrome (v47) crashes after a few minutes.\n\t * So, we'll do it in JS for now.\n\t *\n\t * This really belongs in it's own stream, but there's no way to create new AudioBuffer instances from JS, so its\n\t * fairly coupled to the wav conversion code.\n\t *\n\t * @param  {AudioBuffer} bufferNewSamples Microphone/MediaElement audio chunk\n\t * @return {Float32Array} 'audio/l16' chunk\n\t */\n\tWebAudioL16Stream.prototype.downsample = function downsample(bufferNewSamples) {\n\t  var buffer = null,\n\t    newSamples = bufferNewSamples.length,\n\t    unusedSamples = this.bufferUnusedSamples.length,\n\t    i,\n\t    offset;\n\t\n\t  if (unusedSamples > 0) {\n\t    buffer = new Float32Array(unusedSamples + newSamples);\n\t    for (i = 0; i < unusedSamples; ++i) {\n\t      buffer[i] = this.bufferUnusedSamples[i];\n\t    }\n\t    for (i = 0; i < newSamples; ++i) {\n\t      buffer[unusedSamples + i] = bufferNewSamples[i];\n\t    }\n\t  } else {\n\t    buffer = bufferNewSamples;\n\t  }\n\t\n\t  // downsampling variables\n\t  var filter = [\n\t      -0.037935, -0.00089024, 0.040173, 0.019989, 0.0047792, -0.058675, -0.056487,\n\t      -0.0040653, 0.14527, 0.26927, 0.33913, 0.26927, 0.14527, -0.0040653, -0.056487,\n\t      -0.058675, 0.0047792, 0.019989, 0.040173, -0.00089024, -0.037935\n\t    ],\n\t    samplingRateRatio = this.options.sourceSampleRate / TARGET_SAMPLE_RATE,\n\t    nOutputSamples = Math.floor((buffer.length - filter.length) / (samplingRateRatio)) + 1,\n\t    outputBuffer = new Float32Array(nOutputSamples);\n\t\n\t  for (i = 0; i + filter.length - 1 < buffer.length; i++) {\n\t    offset = Math.round(samplingRateRatio * i);\n\t    var sample = 0;\n\t    for (var j = 0; j < filter.length; ++j) {\n\t      sample += buffer[offset + j] * filter[j];\n\t    }\n\t    outputBuffer[i] = sample;\n\t  }\n\t\n\t  var indexSampleAfterLastUsed = Math.round(samplingRateRatio * i);\n\t  var remaining = buffer.length - indexSampleAfterLastUsed;\n\t  if (remaining > 0) {\n\t    this.bufferUnusedSamples = new Float32Array(remaining);\n\t    for (i = 0; i < remaining; ++i) {\n\t      this.bufferUnusedSamples[i] = buffer[indexSampleAfterLastUsed + i];\n\t    }\n\t  } else {\n\t    this.bufferUnusedSamples = new Float32Array(0);\n\t  }\n\t\n\t  return outputBuffer;\n\t};\n\t\n\t/**\n\t * Accepts a Float32Array of audio data and converts it to a Buffer of l16 audio data (raw wav)\n\t *\n\t * Explanation for the math: The raw values captured from the Web Audio API are\n\t * in 32-bit Floating Point, between -1 and 1 (per the specification).\n\t * The values for 16-bit PCM range between -32768 and +32767 (16-bit signed integer).\n\t * Filter & combine samples to reduce frequency, then multiply to by 0x7FFF (32767) to convert.\n\t * Store in little endian.\n\t *\n\t * @param {Float32Array} input\n\t * @returns {Buffer}\n\t */\n\tWebAudioL16Stream.prototype.floatTo16BitPCM = function(input){\n\t  var output = new DataView(new ArrayBuffer(input.length * 2)); // length is in bytes (8-bit), so *2 to get 16-bit length\n\t  for (var i = 0; i < input.length; i++){\n\t    var multiplier = input[i] < 0 ? 0x8000 : 0x7FFF; // 16-bit signed range is -32768 to 32767\n\t    output.setInt16(i * 2, (input[i] * multiplier) | 0, true); // index, value, little edian\n\t  }\n\t  return new Buffer(output.buffer);\n\t};\n\t\n\t/**\n\t * Does some one-time setup to grab sampleRate and emit format, then sets _transform to the actual audio buffer handler and calls it.\n\t * @param {AudioBuffer} audioBuffer\n\t * @param {String} encoding\n\t * @param {Function} next\n\t */\n\tWebAudioL16Stream.prototype.handleFirstAudioBuffer = function handleFirstAudioBuffer(audioBuffer, encoding, next) {\n\t  this.options.sourceSampleRate = audioBuffer.sampleRate;\n\t  this.emitFormat();\n\t  this._transform = this.transformAudioBuffer;\n\t  this._transform(audioBuffer, encoding, next);\n\t};\n\t\n\t/**\n\t * Accepts an AudioBuffer (for objectMode), then downsamples to 16000 and converts to a 16-bit pcm\n\t *\n\t * @param {AudioBuffer} audioBuffer\n\t * @param {String} encoding\n\t * @param {Function} next\n\t */\n\tWebAudioL16Stream.prototype.transformAudioBuffer = function(audioBuffer, encoding, next) {\n\t  var source = audioBuffer.getChannelData(0);\n\t  if (this.options.downsample) {\n\t    source = this.downsample(source);\n\t  }\n\t  this.push(this.floatTo16BitPCM(source));\n\t  next();\n\t};\n\t\n\t/**\n\t * Accepts a Buffer (for binary mode), then downsamples to 16000 and converts to a 16-bit pcm\n\t *\n\t * @param {Buffer} nodebuffer\n\t * @param {String} encoding\n\t * @param {Function} next\n\t */\n\tWebAudioL16Stream.prototype.transformBuffer = function(nodebuffer, encoding, next) {\n\t  var source = new Float32Array(nodebuffer.buffer);\n\t  if (this.options.downsample) {\n\t    source = this.downsample(source);\n\t  }\n\t  this.push(this.floatTo16BitPCM(source));\n\t  next();\n\t};\n\t// new Float32Array(nodebuffer.buffer)\n\t\n\t\n\tmodule.exports = WebAudioL16Stream;\n\t\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25), __webpack_require__(27).Buffer))\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Transform = __webpack_require__(34).Transform;\n\tvar util = __webpack_require__(54);\n\tvar clone = __webpack_require__(64);\n\tvar defaults = __webpack_require__(63);\n\t\n\t/**\n\t * Applies some basic formating to transcriptions:\n\t *  - Capitalize the first word of each sentence\n\t *  - Add a period to the end\n\t *  - Fix any \"cruft\" in the transcription\n\t *  - etc.\n\t *\n\t * @param {Object} opts\n\t * @param {String} opts.model - some models / languages need special handling\n\t * @param {String} [opts.hesitation='\\u2026'] - what to put down for a \"hesitation\" event, defaults to an ellipsis (...)\n\t * @param {Boolean} [options.objectMode=false] - emit `result` objects instead of string Buffers for the `data` events.\n\t * @constructor\n\t */\n\tfunction FormatStream(opts) {\n\t  this.options = defaults(opts, {\n\t    model: '', // some models should have all spaces removed\n\t    hesitation: '\\u2026', // ellipsis\n\t    decodeStrings: false // false = don't convert strings to buffers before passing to _write\n\t  });\n\t  Transform.call(this, this.options);\n\t\n\t  this.isJaCn = ((this.options.model.substring(0,5) === 'ja-JP') || (this.options.model.substring(0,5) === 'zh-CN'));\n\t  this._transform = this.options.objectMode ? this.formatResult : this.formatString;\n\t}\n\tutil.inherits(FormatStream, Transform);\n\t\n\tvar reHesitation = /%HESITATION\\s/g; // when the service tetects a \"hesitation\" pause, it literally puts the string \"%HESITATION\" into the transcription\n\tvar reRepeatedCharacter = /(.)\\1{2,}/g; // detect the same character repeated three or more times and remove it\n\tvar reDUnderscoreWords = /D_[^\\s]+/g; // replace D_(anything)\n\t\n\t/**\n\t * Formats one or more words, removing special symbols, junk, and spacing for some languages\n\t * @param {String} text\n\t * @param {Boolean} isFinal\n\t * @returns {String}\n\t */\n\tFormatStream.prototype.clean = function clean(text) {\n\t  // clean out \"junk\"\n\t  text = text.trim().replace(reHesitation, this.options.hesitation)\n\t    .replace(reRepeatedCharacter, '')\n\t    .replace(reDUnderscoreWords,'');\n\t\n\t  // short-circuit if there's no actual text (avoids getting multiple periods after a pause)\n\t  if (!text) {\n\t    return text;\n\t  }\n\t\n\t  // remove spaces for Japanese and Chinese\n\t  if (this.isJaCn) {\n\t    text = text.replace(/ /g,'');\n\t  }\n\t\n\t  return text;\n\t};\n\t\n\t/**\n\t * Capitalizes the first word of a sentence\n\t * @param {String} text\n\t * @returns {string}\n\t */\n\tFormatStream.prototype.capitalize = function capitalize(text) {\n\t  // capitalize first word, returns '' in the case of an empty word\n\t  return text.charAt(0).toUpperCase() + text.substring(1);\n\t};\n\t\n\t/**\n\t * puts a period on the end of a sentence\n\t * @param {String} text\n\t * @returns {string}\n\t */\n\tFormatStream.prototype.period = function period(text) {\n\t  return text + (this.isJaCn ? '' : '. ');\n\t};\n\t\n\tFormatStream.prototype.formatString = function(chunk, encoding, next) {\n\t  this.push(this.period(this.capitalize(this.clean(chunk.toString()))));\n\t  next();\n\t};\n\t\n\t/**\n\t * Creates a new result with all transcriptions formatted\n\t *\n\t * @param {Object} result\n\t * @param {String} encoding\n\t * @param {Function} next\n\t */\n\tFormatStream.prototype.formatResult = function formatResult(result, encoding, next) {\n\t  result = clone(result);\n\t  result.alternatives = result.alternatives.map(function(alt) {\n\t    alt.transcript = this.capitalize(this.clean(alt.transcript));\n\t    if (result.final) {\n\t      alt.transcript = this.period(alt.transcript);\n\t    }\n\t    if (alt.timestamps) {\n\t      alt.timestamps = alt.timestamps.map(function(ts, i, arr) {\n\t        // timestamps is an array of arrays, each sub-array is in the form [\"word\", startTime, endTime]'\n\t        ts[0] = this.clean(ts[0]);\n\t        if (i === 0) {\n\t          ts[0] = this.capitalize(ts[0]);\n\t        }\n\t        if (i === arr.length - 1 && result.final) {\n\t          ts[0] = this.period(ts[0]);\n\t        }\n\t        return ts;\n\t      }, this);\n\t      // todo: remove any timestamps without a word (due to cleaning out junk words)\n\t    }\n\t    return alt;\n\t  }, this);\n\t  this.push(result);\n\t  next();\n\t};\n\t\n\tFormatStream.prototype.promise = __webpack_require__(66);\n\t\n\tmodule.exports = FormatStream;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar implementation = __webpack_require__(70);\n\t\n\tvar lacksProperEnumerationOrder = function () {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\t\t// v8, specifically in node 4.x, has a bug with incorrect property enumeration order\n\t\t// note: this does not detect the bug unless there's 20 characters\n\t\tvar str = 'abcdefghijklmnopqrst';\n\t\tvar letters = str.split('');\n\t\tvar map = {};\n\t\tfor (var i = 0; i < letters.length; ++i) {\n\t\t\tmap[letters[i]] = letters[i];\n\t\t}\n\t\tvar obj = Object.assign({}, map);\n\t\tvar actual = '';\n\t\tfor (var k in obj) {\n\t\t\tactual += k;\n\t\t}\n\t\treturn str !== actual;\n\t};\n\t\n\tvar assignHasPendingExceptions = function () {\n\t\tif (!Object.assign || !Object.preventExtensions) {\n\t\t\treturn false;\n\t\t}\n\t\t// Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n\t\t// which is 72% slower than our shim, and Firefox 40's native implementation.\n\t\tvar thrower = Object.preventExtensions({ 1: 2 });\n\t\ttry {\n\t\t\tObject.assign(thrower, 'xy');\n\t\t} catch (e) {\n\t\t\treturn thrower[1] === 'y';\n\t\t}\n\t\treturn false;\n\t};\n\t\n\tmodule.exports = function getPolyfill() {\n\t\tif (!Object.assign) {\n\t\t\treturn implementation;\n\t\t}\n\t\tif (lacksProperEnumerationOrder()) {\n\t\t\treturn implementation;\n\t\t}\n\t\tif (assignHasPendingExceptions()) {\n\t\t\treturn implementation;\n\t\t}\n\t\treturn Object.assign;\n\t};\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// modified from https://github.com/es-shims/es6-shim\n\tvar keys = __webpack_require__(71);\n\tvar bind = __webpack_require__(73);\n\tvar canBeObject = function (obj) {\n\t\treturn typeof obj !== 'undefined' && obj !== null;\n\t};\n\tvar hasSymbols = __webpack_require__(75)();\n\tvar toObject = Object;\n\tvar push = bind.call(Function.call, Array.prototype.push);\n\tvar propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);\n\tvar originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;\n\t\n\tmodule.exports = function assign(target, source1) {\n\t\tif (!canBeObject(target)) { throw new TypeError('target must be an object'); }\n\t\tvar objTarget = toObject(target);\n\t\tvar s, source, i, props, syms, value, key;\n\t\tfor (s = 1; s < arguments.length; ++s) {\n\t\t\tsource = toObject(arguments[s]);\n\t\t\tprops = keys(source);\n\t\t\tvar getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);\n\t\t\tif (getSymbols) {\n\t\t\t\tsyms = getSymbols(source);\n\t\t\t\tfor (i = 0; i < syms.length; ++i) {\n\t\t\t\t\tkey = syms[i];\n\t\t\t\t\tif (propIsEnumerable(source, key)) {\n\t\t\t\t\t\tpush(props, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < props.length; ++i) {\n\t\t\t\tkey = props[i];\n\t\t\t\tvalue = source[key];\n\t\t\t\tif (propIsEnumerable(source, key)) {\n\t\t\t\t\tobjTarget[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn objTarget;\n\t};\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar slice = Array.prototype.slice;\n\tvar isArgs = __webpack_require__(72);\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\t\n\tvar keysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\t\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\t\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\t\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\t\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n\t\n\tkeysShim.shim = function shimObjectKeys() {\n\t\tif (Object.keys) {\n\t\t\tvar keysWorksWithArguments = (function () {\n\t\t\t\t// Safari 5.0 bug\n\t\t\t\treturn (Object.keys(arguments) || '').length === 2;\n\t\t\t}(1, 2));\n\t\t\tif (!keysWorksWithArguments) {\n\t\t\t\tvar originalKeys = Object.keys;\n\t\t\t\tObject.keys = function keys(object) {\n\t\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn originalKeys(object);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tObject.keys = keysShim;\n\t\t}\n\t\treturn Object.keys || keysShim;\n\t};\n\t\n\tmodule.exports = keysShim;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar toStr = Object.prototype.toString;\n\t\n\tmodule.exports = function isArguments(value) {\n\t\tvar str = toStr.call(value);\n\t\tvar isArgs = str === '[object Arguments]';\n\t\tif (!isArgs) {\n\t\t\tisArgs = str !== '[object Array]' &&\n\t\t\t\tvalue !== null &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\ttypeof value.length === 'number' &&\n\t\t\t\tvalue.length >= 0 &&\n\t\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t\t}\n\t\treturn isArgs;\n\t};\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar implementation = __webpack_require__(74);\n\t\n\tmodule.exports = Function.prototype.bind || implementation;\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\tvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\n\tvar slice = Array.prototype.slice;\n\tvar toStr = Object.prototype.toString;\n\tvar funcType = '[object Function]';\n\t\n\tmodule.exports = function bind(that) {\n\t    var target = this;\n\t    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n\t        throw new TypeError(ERROR_MESSAGE + target);\n\t    }\n\t    var args = slice.call(arguments, 1);\n\t\n\t    var bound;\n\t    var binder = function () {\n\t        if (this instanceof bound) {\n\t            var result = target.apply(\n\t                this,\n\t                args.concat(slice.call(arguments))\n\t            );\n\t            if (Object(result) === result) {\n\t                return result;\n\t            }\n\t            return this;\n\t        } else {\n\t            return target.apply(\n\t                that,\n\t                args.concat(slice.call(arguments))\n\t            );\n\t        }\n\t    };\n\t\n\t    var boundLength = Math.max(0, target.length - args.length);\n\t    var boundArgs = [];\n\t    for (var i = 0; i < boundLength; i++) {\n\t        boundArgs.push('$' + i);\n\t    }\n\t\n\t    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\t\n\t    if (target.prototype) {\n\t        var Empty = function Empty() {};\n\t        Empty.prototype = target.prototype;\n\t        bound.prototype = new Empty();\n\t        Empty.prototype = null;\n\t    }\n\t\n\t    return bound;\n\t};\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar keys = __webpack_require__(71);\n\t\n\tmodule.exports = function hasSymbols() {\n\t\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\t\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\t\n\t\tvar obj = {};\n\t\tvar sym = Symbol('test');\n\t\tvar symObj = Object(sym);\n\t\tif (typeof sym === 'string') { return false; }\n\t\n\t\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\t\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\t\n\t\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t\t// if (sym instanceof Symbol) { return false; }\n\t\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t\t// if (!(symObj instanceof Symbol)) { return false; }\n\t\n\t\tvar symVal = 42;\n\t\tobj[sym] = symVal;\n\t\tfor (sym in obj) { return false; }\n\t\tif (keys(obj).length !== 0) { return false; }\n\t\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\t\n\t\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\t\n\t\tvar syms = Object.getOwnPropertySymbols(obj);\n\t\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\t\n\t\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\t\n\t\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t\t}\n\t\n\t\treturn true;\n\t};\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Writable = __webpack_require__(34).Writable;\n\tvar util = __webpack_require__(54);\n\tvar defaults = __webpack_require__(63);\n\t\n\t/**\n\t * Writable stream that accepts results in either object or string mode and outputs the text to a supplied html element\n\t *\n\t * Can show interim results when in objectMode\n\t *\n\t * @param {Object} options\n\t * @param {String|DOMElement} options.outputElement\n\t * @param {String} [options.property] what property of the element should the text be set to. Defaults to `value` for `<input>`s and `<textarea>`s, `textContent` for everything else\n\t * @param {Boolean} [options.clear=true] delete any previous text\n\t * @constructor\n\t */\n\tfunction WritableElementStream(options) {\n\t  this.options = options = defaults(options, {\n\t    decodeStrings: false,  // false = don't convert strings to buffers before passing to _write (only applies in string mode)\n\t    property: null,\n\t    clear: true\n\t  });\n\t\n\t  this.el = typeof options.outputElement === 'string' ? document.querySelector(options.outputElement) : options.outputElement;\n\t\n\t  if (!this.el) {\n\t    throw new Error('Watson Speech to Text WritableElementStream: missing outputElement');\n\t  }\n\t\n\t  Writable.call(this, options);\n\t\n\t  // for most elements we set the textContent, but for form elements, the value property is probably the expected target\n\t  var propMap = {\n\t    INPUT: 'value',\n\t    TEXTAREA: 'value'\n\t  };\n\t  this.prop = options.property || propMap[this.el.nodeName] || 'textContent';\n\t\n\t  if (options.clear) {\n\t    this.el[this.prop] = '';\n\t  }\n\t\n\t  if (options.objectMode) {\n\t    this.finalizedText = this.el[this.prop];\n\t    this._write = this.writeObject;\n\t  } else {\n\t    this._write = this.writeString;\n\t  }\n\t}\n\tutil.inherits(WritableElementStream, Writable);\n\t\n\t\n\tWritableElementStream.prototype.writeString = function writeString(text, encoding, next) {\n\t  this.el[this.prop] += text;\n\t  next();\n\t};\n\t\n\tWritableElementStream.prototype.writeObject = function writeObject(result, encoding, next) {\n\t  if (result.final) {\n\t    this.finalizedText += result.alternatives[0].transcript;\n\t    this.el[this.prop] = this.finalizedText;\n\t  } else {\n\t    this.el[this.prop] = this.finalizedText + result.alternatives[0].transcript;\n\t  }\n\t  next();\n\t};\n\t\n\tmodule.exports = WritableElementStream;\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\tvar BlobStream = __webpack_require__(78);\n\tvar RecognizeStream = __webpack_require__(56);\n\tvar FilePlayer = __webpack_require__(79);\n\tvar FormatStream = __webpack_require__(68);\n\tvar TimingStream = __webpack_require__(80);\n\tvar assign = __webpack_require__(69)();\n\tvar WritableElementStream = __webpack_require__(76);\n\t\n\t/**\n\t * @module watson-speech/speech-to-text/recognize-file\n\t */\n\t\n\t/**\n\t * Create and return a RecognizeStream from a File or Blob\n\t * (e.g. from a file <input>, a dtagdrop targe, or an ajax request)\n\t *\n\t * @param {Object} options - Also passed to {MediaElementAudioStream} and to {RecognizeStream}\n\t * @param {String} options.token - Auth Token - see https://github.com/watson-developer-cloud/node-sdk#authorization\n\t * @param {Blob|File} options.data - the raw audio data as a Blob or File instance\n\t * @param {Boolean} [options.play=false] - If a file is set, play it locally as it's being uploaded\n\t * @param {Boolena} [options.format=true] - pipe the text through a {FormatStream} which performs light formatting. Also controls smart_formatting option unless explicitly set.\n\t * @param {Boolena} [options.realtime=options.play] - pipe the text through a {TimingStream} which slows the output down to real-time to match the audio playback.\n\t * @param {String|DOMElement} [options.outputElement] pipe the text to a WriteableElementStream targeting the specified element. Also defaults objectMode to true to enable interim results.\n\t *\n\t * @returns {RecognizeStream|FormatStream|TimingStream}\n\t */\n\tmodule.exports = function recognizeFile(options) { // eslint-disable-line complexity\n\t  if (!options || !options.token) {\n\t    throw new Error('WatsonSpeechToText: missing required parameter: opts.token');\n\t  }\n\t\n\t  // the WritableElementStream works best in objectMode\n\t  if (options.outputElement && options.objectMode !== false) {\n\t    options.objectMode = true;\n\t  }\n\t\n\t  // default format to true (capitals and periods)\n\t  // default smart_formatting to options.format value (dates, currency, etc.)\n\t  options.format = (options.format !== false);\n\t  if (typeof options.smart_formatting === 'undefined') {\n\t    options.smart_formatting = options.format;\n\t  }\n\t\n\t  var realtime = options.realtime || typeof options.realtime === 'undefined' && options.play;\n\t\n\t  // the timing stream requires timestamps to work, so enable them automatically\n\t  if (realtime) {\n\t    options.timestamps = true;\n\t  }\n\t\n\t  // we don't want the readable stream to have objectMode on the input even if we're setting it for the output\n\t  // unless were in realtime mode - in which case the timing stream requires objectMode input.\n\t  var rsOpts = assign({}, options);\n\t  rsOpts.readableObjectMode = options.objectMode || realtime;\n\t  delete rsOpts.objectMode;\n\t\n\t\n\t  var recognizeStream = new RecognizeStream(rsOpts);\n\t  var stream = new BlobStream(options.data).pipe(recognizeStream);\n\t\n\t  if (options.format) {\n\t    stream = stream.pipe(new FormatStream(options));\n\t  }\n\t  if (realtime) {\n\t    stream = stream.pipe(new TimingStream(options));\n\t    stream.on('stop', recognizeStream.stop.bind(recognizeStream));\n\t  } else {\n\t    stream.stop = recognizeStream.stop.bind(recognizeStream);\n\t  }\n\t\n\t  if (options.play) {\n\t    FilePlayer.playFile(options.data).then(function(player) {\n\t      recognizeStream.on('stop', player.stop.bind(player));\n\t    }).catch(function(err) {\n\t      stream.emit('playback-error', err);\n\t    });\n\t  }\n\t\n\t  if (options.outputElement) {\n\t    stream.pipe(new WritableElementStream(options));\n\t  }\n\t\n\t  return stream;\n\t};\n\t\n\t\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, Buffer) {'use strict';\n\t\n\tvar Readable = __webpack_require__(34).Readable;\n\t// When required from browserify, Buffer is also an Uint8Array, which is important for ejson.\n\tvar inherits = __webpack_require__(36);\n\tvar FileReader = global.FileReader;\n\tvar Uint8Array = global.Uint8Array;\n\t\n\t/**\n\t * Read W3C Blob & File objects as a Node stream.\n\t * @param {Blob} blob\n\t * @constructor\n\t */\n\tfunction ReadableBlobStream(blob, opts)\n\t{\n\t        if (!(this instanceof ReadableBlobStream)) {\n\t          return new ReadableBlobStream(blob, opts);\n\t        }\n\t\n\t        opts = opts || {};\n\t        opts.objectMode = false;\n\t        Readable.call(this, opts);\n\t\n\t        if (!blob)\n\t        {\n\t                throw Error('Missing argument \"blob\"');\n\t        }\n\t\n\t        if (typeof blob.slice !== 'function')\n\t        {\n\t                throw Error('Given argument \"blob\" is not really a Blob/File or your environment does not support .slice()');\n\t        }\n\t\n\t        if (!FileReader)\n\t        {\n\t                throw Error('Your environment does not support FileReader');\n\t        }\n\t\n\t        if (!Uint8Array)\n\t        {\n\t                throw Error('Your environment does not support Uint8Array');\n\t        }\n\t\n\t        this.totalSize = blob.size;\n\t        this._blob = blob;\n\t        this._nextByteStart = 0;\n\t}\n\tmodule.exports = ReadableBlobStream;\n\tinherits(ReadableBlobStream, Readable);\n\t\n\tfunction uint8ArrayToBuffer(buf)\n\t{\n\t        if (typeof Buffer._augment === 'function')\n\t        {\n\t                buf = Buffer._augment(buf);\n\t\n\t                if (!(buf instanceof Uint8Array))\n\t                {\n\t                        throw Error('Assertion error, buf should be an Uint8Array');\n\t                }\n\t        }\n\t        else\n\t        {\n\t                buf = new Buffer(buf);\n\t        }\n\t\n\t        return buf;\n\t}\n\t\n\tfunction bufferToUint8Array(buf)\n\t{\n\t        buf = new Uint8Array(buf);\n\t        if (typeof Buffer._augment === 'function')\n\t        {\n\t                buf = Buffer._augment(buf);\n\t                // buf is now both an Uint8Array and an Buffer\n\t        }\n\t\n\t        if (!(buf instanceof Uint8Array))  // this is the check ejson uses\n\t        {\n\t                // this is the check ejson uses\n\t                throw Error('Assertion error, buf should be an Uint8Array');\n\t        }\n\t\n\t        return buf;\n\t}\n\t\n\tReadableBlobStream.prototype.read = function()\n\t{\n\t        var buf = ReadableBlobStream.super_.prototype.read.apply(this, arguments);\n\t\n\t        // make sure it is a Uint8Array in case browserify's Buffer\n\t        // stops using Uint8Array\n\t        if (Buffer.isBuffer(buf) && !(buf instanceof Uint8Array))\n\t        {\n\t                buf = bufferToUint8Array(buf);\n\t        }\n\t\n\t        return buf;\n\t};\n\t\n\tReadableBlobStream.prototype._read = function(chunkSize)\n\t{\n\t        var size = this._blob.size;\n\t        var start, end;\n\t\n\t        start = this._nextByteStart;\n\t        end = Math.min(start + chunkSize, size); // exclusive\n\t        this._nextByteStart = end;\n\t\n\t        if (start >= this._blob.size)\n\t        {\n\t                return void this.push(null);\n\t        }\n\t\n\t        var chunk = this._blob.slice(start, end);\n\t        var reader = new FileReader();\n\t\n\t        reader.onload = function()\n\t        {\n\t                // reader.result is an ArrayBuffer\n\t                var buf = new Uint8Array(reader.result);\n\t                buf = uint8ArrayToBuffer(buf);\n\t\n\t                this.push(buf);\n\t        }.bind(this);\n\t\n\t        reader.onerror = function()\n\t        {\n\t                this.emit('error', reader.error);\n\t        }.bind(this);\n\t\n\t        reader.readAsArrayBuffer(chunk);\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(27).Buffer))\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar getContentTypeFromHeader = __webpack_require__(62);\n\t\n\t/**\n\t * Reads the first few bytes of a binary file and resolves to the content-type if recognized & supported\n\t * @param {File|Blob} file\n\t * @returns {Promise}\n\t */\n\tfunction getContentTypeFromFile(file) {\n\t  return new Promise(function(resolve, reject) {\n\t    var blobToText = new Blob([file]).slice(0, 4);\n\t    var r = new FileReader();\n\t    r.readAsText(blobToText);\n\t    r.onload = function() {\n\t      var ct = getContentTypeFromHeader(r.result);\n\t      if (ct) {\n\t        resolve(ct);\n\t      } else {\n\t        var err = new Error('Unable to determine content type from file header; only wav, flac, and ogg/opus are supported.');\n\t        err.name = 'UNRECOGNIZED_FORMAT';\n\t        reject(err);\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\t/**\n\t * Plays audio from File/Blob instances\n\t * @param {File|Blob} file\n\t * @param {String} contentType\n\t * @constructor\n\t */\n\tfunction FilePlayer(file, contentType) {\n\t  var audio = this.audio = new Audio();\n\t  if (audio.canPlayType(contentType)) {\n\t    audio.src = URL.createObjectURL(new Blob([file], {type: contentType}));\n\t    audio.play();\n\t  } else {\n\t    // if we emit an error, it prevents the promise from returning the actual result\n\t    // however, most browsers do not support flac, so this is a reasonably scenario\n\t    var err = new Error('Current browser is unable to play back ' + contentType);\n\t    err.name = 'UNSUPPORTED_FORMAT';\n\t    err.contentType = contentType;\n\t    throw err;\n\t  }\n\t  /**\n\t   * Stops the audio\n\t   */\n\t  this.stop = function stop() {\n\t    audio.pause();\n\t    audio.currentTime = 0;\n\t  };\n\t}\n\t\n\t/**\n\t * Determines the file's content-type and then resolves to a FilePlayer instance\n\t * @param {File|Blob} file\n\t * @returns {Promise.<FilePlayer>}\n\t */\n\tfunction playFile(file) {\n\t  return getContentTypeFromFile(file).then(function(contentType) {\n\t    return new FilePlayer(file, contentType);\n\t  });\n\t}\n\t\n\tmodule.exports = FilePlayer;\n\tmodule.exports.getContentType = getContentTypeFromFile;\n\tmodule.exports.playFile = playFile;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\tvar Duplex = __webpack_require__(34).Duplex;\n\tvar util = __webpack_require__(54);\n\tvar clone = __webpack_require__(64);\n\tvar defaults = __webpack_require__(63);\n\t\n\t/**\n\t * Slows results down to no faster than real time.\n\t *\n\t * Useful when running recognizeFile because the text can otherwise appear before the words are spoken\n\t *\n\t * @param {Object} [opts]\n\t * @param {*} [opts.emitAtt=TimingStream.START] - set to TimingStream.END to only emit text that has been completely spoken.\n\t * @param {Number} [opts.delay=0] - Additional delay (in seconds) to apply before emitting words, useful for precise syncing to audio tracks. May be negative\n\t * @constructor\n\t */\n\tfunction TimingStream(opts) {\n\t  this.options = defaults(opts, {\n\t    emitAt: TimingStream.START,\n\t    delay: 0,\n\t    allowHalfOpen: true, // keep the readable side open after the source closes\n\t    writableObjectMode: true\n\t  });\n\t  Duplex.call(this, opts);\n\t\n\t  this.startTime = Date.now();\n\t  // buffer to store future results\n\t  this.final = [];\n\t  this.interim = [];\n\t  this.nextTick = null;\n\t  this.sourceEnded = false;\n\t\n\t  var self = this;\n\t  this.on('pipe', function(source) {\n\t    source.on('end', function() {\n\t      self.sourceEnded = true; // todo: see if there's anything built-in that does this for us\n\t      self.checkForEnd();\n\t    });\n\t  });\n\t}\n\tutil.inherits(TimingStream, Duplex);\n\t\n\tTimingStream.START = 1;\n\tTimingStream.END = 2;\n\t\n\tTimingStream.prototype._write = function(result, encoding, next) {\n\t  if (result instanceof Buffer) {\n\t    return this.emit('error', new Error('TimingStream requires the source to be in objectMode'));\n\t  }\n\t  this.handleResult(result);\n\t  next();\n\t};\n\t\n\tTimingStream.prototype._read = function(/* size*/) {\n\t  // ignore - we'll emit results once the time has come\n\t};\n\t\n\tTimingStream.prototype.cutoff = function cutoff() {\n\t  return (Date.now() - this.startTime) / 1000 - this.options.delay;\n\t};\n\t\n\tTimingStream.prototype.withinRange = function(result, cutoff) {\n\t  return result.alternatives.some(function(alt) {\n\t    // timestamp structure is [\"word\", startTime, endTime]\n\t    // if the first timestamp ends before the cutoff, then it's at least partially within range\n\t    var timestamp = alt.timestamps[0];\n\t    return !!timestamp && timestamp[this.options.emitAt] <= cutoff;\n\t  }, this);\n\t};\n\t\n\tTimingStream.prototype.completelyWithinRange = function(result, cutoff) {\n\t  return result.alternatives.every(function(alt) {\n\t    // timestamp structure is [\"word\", startTime, endTime]\n\t    // if the last timestamp ends before the cutoff, then it's completely within range\n\t    var timestamp = alt.timestamps[alt.timestamps.length - 1];\n\t    return timestamp[this.options.emitAt] <= cutoff;\n\t  }, this);\n\t};\n\t\n\t/**\n\t * Clones the given result and then crops out any words that occur later than the current cutoff\n\t * @param {Object} result\n\t * @param {Number} cutoff timestamp (in seconds)\n\t * @returns {Object}\n\t */\n\tDuplex.prototype.crop = function crop(result, cutoff) {\n\t  result = clone(result);\n\t  result.alternatives = result.alternatives.map(function(alt) {\n\t    var timestamps = [];\n\t    for (var i = 0, timestamp; i < alt.timestamps.length; i++) {\n\t      timestamp = alt.timestamps[i];\n\t      if (timestamp[this.options.emitAt] <= cutoff) {\n\t        timestamps.push(timestamp);\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    alt.timestamps = timestamps;\n\t    alt.transcript = timestamps.map(function(ts) {\n\t      return ts[0];\n\t    }).join(' ');\n\t    return alt;\n\t  }, this);\n\t  // \"final\" signifies both that the text won't change, and that we're at the end of a sentence. Only one of those is true here.\n\t  result.final = false;\n\t  return result;\n\t};\n\t\n\t/**\n\t * Returns one of:\n\t *  - undefined if the next result is completely later than the current cutoff\n\t *  - a cropped clone of the next result if it's later than the current cutoff && in objectMode\n\t *  - the original next result object (removing it from the array) if it's completely earlier than the current cutoff (or we're in string mode with emitAt set to start)\n\t *\n\t * @param {Object} results\n\t * @param {Number} cutoff\n\t * @returns {Object|undefined}\n\t */\n\tTimingStream.prototype.getCurrentResult = function getCurrentResult(results, cutoff) {\n\t  if (results.length && this.withinRange(results[0], cutoff)) {\n\t    var completeResult = this.completelyWithinRange(results[0], cutoff);\n\t    if (this.options.objectMode || this.options.readableObjectMode) {\n\t      // object mode: emit either a complete result or a cropped result\n\t      return completeResult ? results.shift() : this.crop(results[0], cutoff);\n\t    } else if (completeResult || this.options.emitAt === TimingStream.START) {\n\t      // string mode: emit either a complete result or nothing\n\t      return results.shift();\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Tick emits any buffered words that have a timestamp before the current time, then calls scheduleNextTick()\n\t */\n\tTimingStream.prototype.tick = function tick() {\n\t  var cutoff = this.cutoff();\n\t\n\t  clearTimeout(this.nextTick);\n\t  var result = this.getCurrentResult(this.final, cutoff);\n\t\n\t  if (!result) {\n\t    result = this.getCurrentResult(this.interim, cutoff);\n\t  }\n\t\n\t  if (result) {\n\t    if (this.options.objectMode || this.options.readableObjectMode) {\n\t      this.push(result);\n\t    } else {\n\t      this.push(result.alternatives[0].transcript);\n\t    }\n\t    if (result.final) {\n\t      this.nextTick = setTimeout(this.tick.bind(this), 0); // in case we are multiple results behind - don't schedule until we are out of final results that are due now\n\t      return;\n\t    }\n\t  }\n\t\n\t  this.scheduleNextTick(cutoff);\n\t};\n\t\n\t/**\n\t * Schedules next tick if possible. Requires previous stream to emit recognize objects (objectMode or readableObjectMode)\n\t *\n\t * triggers the 'close' and 'end' events if the buffer is empty and no further results are expected\n\t *\n\t * @param {Number} cutoff\n\t *\n\t */\n\tTimingStream.prototype.scheduleNextTick = function scheduleNextTick(cutoff) {\n\t\n\t  // prefer final results over interim - when final results are added, any older interim ones are automatically deleted.\n\t  var nextResult = this.final[0] || this.interim[0];\n\t  if (nextResult) {\n\t    // loop through the timestamps until we find one that comes after the current cutoff (there should always be one)\n\t    var timestamps = nextResult.alternatives[0].timestamps;\n\t    for (var i = 0; i < timestamps.length; i++) {\n\t      var wordOffset = timestamps[i][this.options.emitAt];\n\t      if (wordOffset > cutoff) {\n\t        var nextTime = this.startTime + (wordOffset * 1000);\n\t        this.nextTick = setTimeout(this.tick.bind(this), nextTime - Date.now());\n\t        return;\n\t      }\n\t    }\n\t    throw new Error('No future words found'); // this shouldn't happen ever - getCurrentResult should automatically delete the result from the buffer if all of it's words are consumed\n\t  } else {\n\t    // clear the next tick\n\t    this.nextTick = null;\n\t    this.checkForEnd();\n\t  }\n\t};\n\t\n\t/**\n\t * Triggers the 'close' and 'end' events if both pre-conditions are true:\n\t *  - the previous stream must have already emitted it's 'end' event\n\t *  - there must be no next tick scheduled, indicating that there are no results buffered for later delivery\n\t */\n\tTimingStream.prototype.checkForEnd = function() {\n\t  if (this.sourceEnded && !this.nextTick) {\n\t    this.emit('close');\n\t    this.push(null);\n\t  }\n\t};\n\t\n\t/**\n\t * Returns true if the result is missing it's timestamps\n\t * @param {Object} result\n\t * @returns {Boolean}\n\t */\n\tfunction noTimestamps(result) {\n\t  var alt = result.alternatives && result.alternatives[0];\n\t  return !!(alt && alt.transcript.trim() && !alt.timestamps || !alt.timestamps.length);\n\t}\n\t\n\t/**\n\t * Creates a new result with all transcriptions formatted\n\t *\n\t * @param {Object} result\n\t */\n\tTimingStream.prototype.handleResult = function handleResult(result) {\n\t  if (noTimestamps(result)) {\n\t    this.emit('error', new Error('TimingStream requires timestamps'));\n\t    return;\n\t  }\n\t\n\t  // additional alternatives do not include timestamps, so we can't process and emit them correctly\n\t  if (result.alternatives.length > 1) {\n\t    result.alternatives.length = 1;\n\t  }\n\t\n\t  // loop through the buffer and delete any interim results with the same or lower index\n\t  while (this.interim.length && this.interim[0].index <= result.index) {\n\t    this.interim.shift();\n\t  }\n\t\n\t  if (result.final) {\n\t    // then add it to the final results array\n\t    this.final.push(result);\n\t  } else {\n\t    this.interim.push(result);\n\t  }\n\t\n\t  this.tick();\n\t};\n\t\n\tTimingStream.prototype.promise = __webpack_require__(66);\n\t\n\t// when stop is called, immediately stop emitting results\n\tTimingStream.prototype.stop = function stop() {\n\t  this.emit('stop');\n\t  clearTimeout(this.nextTick);\n\t  this.handleResult = function noop(){}; // RecognizeStream.stop() closes the connection gracefully, so we will usually see one more result\n\t  this.checkForEnd(); // in case the RecognizeStream already ended\n\t};\n\t\n\tmodule.exports = TimingStream;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).Buffer))\n\n/***/ },\n/* 81 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t'use strict';\n\t\n\t/**\n\t * @module watson-speech/speech-to-text/get-models\n\t */\n\t\n\t/**\n\t Returns a promise that resolves to an array of objects representing the available voice models.  Example:\n\t\n\t ```js\n\t [{\n\t    \"url\": \"https://stream.watsonplatform.net/speech-to-text/api/v1/models/en-UK_BroadbandModel\",\n\t    \"rate\": 16000,\n\t    \"name\": \"en-UK_BroadbandModel\",\n\t    \"language\": \"en-UK\",\n\t    \"description\": \"UK English broadband model.\"\n\t },\n\t //...\n\t ]\n\t ```\n\t Requires fetch, pollyfill available at https://github.com/github/fetch\n\t\n\t * @todo define format in @returns statement\n\t * @param {Object} options\n\t * @param {String} options.token auth token\n\t * @returns {Promise.<T>}\n\t */\n\tmodule.exports = function getModels(options) {\n\t  if (!options || !options.token) {\n\t    throw new Error('Watson SpeechToText: missing required parameter: options.token');\n\t  }\n\t  var reqOpts = {\n\t    credentials: 'omit',\n\t    headers: {\n\t      accept: 'application/json'\n\t    }\n\t  };\n\t  return fetch('https://stream.watsonplatform.net/speech-to-text/api/v1/models?watson-token=' + options.token, reqOpts)\n\t    .then(function(response){\n\t      return response.json();\n\t    }).then(function(obj) {\n\t      return obj.models;\n\t    });\n\t};\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t'use strict';\n\t\n\t/**\n\t * @module watson-speech/text-to-speech\n\t */\n\t\n\t/**\n\t * @see module:watson-speech/text-to-speech/synthesize\n\t */\n\texports.synthesize = __webpack_require__(83);\n\t\n\t\n\t/**\n\t * @see module:watson-speech/text-to-speech/get-voices\n\t */\n\texports.getVoices = __webpack_require__(84);\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t'use strict';\n\tvar pick = __webpack_require__(57);\n\tvar qs = __webpack_require__(65);\n\t\n\tvar QUERY_PARAMS_ALLOWED = ['voice', 'X-WDC-PL-OPT-OUT', 'text', 'watson-token'];\n\t\n\t/**\n\t * @module watson-speech/text-to-speech/synthesize\n\t */\n\t\n\t/**\n\t * Synthesize and play the supplied text over the computers speakers.\n\t *\n\t * Creates and returns a HTML5 `<audio>` element\n\t *\n\t * @param {Object} options\n\t * @param {String} options.token auth token\n\t * @param {String} options.text text to speak\n\t * @param {String} [options.voice=en-US_MichaelVoice] what voice to use - call getVoices() for a complete list.\n\t * @param {Number} [options.X-WDC-PL-OPT-OUT=0] set to 1 to opt-out of allowing Watson to use this request to improve it's services\n\t * @param {Boolean} [options.autoPlay=true] automatically play the audio\n\t * @param {DOMAudioElement} [options.element] <audio> element - will be used instead of creating a new one if provided\n\t * @returns {Audio}\n\t * @see module:watson-speech/text-to-speech/get-voices\n\t */\n\tmodule.exports = function synthesize(options) {\n\t  if (!options || !options.token) {\n\t    throw new Error('Watson TextToSpeech: missing required parameter: options.token');\n\t  }\n\t  options['watson-token'] = options.token;\n\t  delete options.token;\n\t  var audio = options.element || new Audio();\n\t  audio.crossOrigin = true;\n\t  audio.src = 'https://stream.watsonplatform.net/text-to-speech/api/v1/synthesize?' + qs.stringify(pick(options, QUERY_PARAMS_ALLOWED));\n\t  if (options.autoPlay !== false) {\n\t    audio.play();\n\t  }\n\t  return audio;\n\t};\n\t\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright 2015 IBM Corp. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t'use strict';\n\t\n\t/**\n\t * @module watson-speech/text-to-speech/get-voices\n\t */\n\t\n\t/**\n\t Returns a promise that resolves to an array of objects representing the available voices.  Example:\n\t\n\t ```js\n\t [{\n\t    \"name\": \"en-US_MichaelVoice\",\n\t    \"language\": \"en-US\",\n\t    \"customizable\": true,\n\t    \"gender\": \"male\",\n\t    \"url\": \"https://stream.watsonplatform.net/text-to-speech/api/v1/voices/en-US_MichaelVoice\",\n\t    \"description\": \"Michael: American English male voice.\"\n\t },\n\t //...\n\t ]\n\t ```\n\t Requires fetch, pollyfill available at https://github.com/github/fetch\n\t\n\t * @todo define format in @returns statement\n\t * @param {Object} options\n\t * @param {String} options.token auth token\n\t * @returns {Promise.<T>}\n\t */\n\tmodule.exports = function getVoices(options) {\n\t  if (!options || !options.token) {\n\t    throw new Error('Watson TextToSpeech: missing required parameter: options.token');\n\t  }\n\t  var reqOpts = {\n\t    credentials: 'omit',\n\t    headers: {\n\t      accept: 'application/json'\n\t    }\n\t  };\n\t  return fetch('https://stream.watsonplatform.net/text-to-speech/api/v1/voices?watson-token=' + options.token, reqOpts)\n\t    .then(function(response){\n\t      return response.json();\n\t    }).then(function(obj) {\n\t      return obj.voices;\n\t    });\n\t};\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction SpeachFactory($q, Restangular, $http, $filter) {\n\t    'ngInject';\n\t\n\t    var service = {\n\t        rules: [],\n\t        ruleTypes: [],\n\t        rulesExamples: [],\n\t        tokenSTT: '',\n\t        tokenTTS: '',\n\t        collection: []\n\t    };\n\t\n\t    Restangular.one('authorization').get().then(function (result) {\n\t        service.tokenSTT = result[0];\n\t        service.tokenTTS = result[1];\n\t    });\n\t\n\t    Restangular.all('ruleTypes').getList().then(function (ruleTypes) {\n\t        service.ruleTypes = ruleTypes;\n\t        Restangular.all('rules').getList().then(function (rules) {\n\t            _.each(rules, function (rule) {\n\t                var ruleType = _.find(ruleTypes, function (ruleType) {\n\t                    return ruleType.Id === rule.RuleTypeId;\n\t                });\n\t\n\t                rule.RuleTypeName = ruleType.RuleTypeName;\n\t                rule.Displayposition = ruleType.Displayposition;\n\t            });\n\t            service.rules = $filter('orderBy')(rules, ['Position', 'Displayposition']);\n\t        });\n\t    });\n\t\n\t    Restangular.one('rulesExamples', 2).getList().then(function (result) {\n\t        service.rulesExamples = result;\n\t    });\n\t\n\t    service.getNewPhrase = function (ruleId) {\n\t        return Restangular.one('rulePhrase', ruleId).get();\n\t    };\n\t\n\t    service.getText = function (file) {\n\t        return Restangular.one('rulePhrase', ruleId).get();\n\t    };\n\t\n\t    return service;\n\t}\n\t\n\texports.default = SpeachFactory;\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _text = __webpack_require__(10);\n\t\n\tvar _text2 = _interopRequireDefault(_text);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NavbarController = function () {\n\t    /* @ngInject */\n\t\n\t    function NavbarController() {\n\t        _classCallCheck(this, NavbarController);\n\t\n\t        this.text = _text2.default;\n\t        this.sidebar = false;\n\t    }\n\t\n\t    _createClass(NavbarController, [{\n\t        key: 'toggleSidebar',\n\t        value: function toggleSidebar() {\n\t            this.sidebar = !this.sidebar;\n\t        }\n\t    }]);\n\t\n\t    return NavbarController;\n\t}();\n\t\n\texports.default = NavbarController;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** js/app.bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 91fa6240a5e12b29c466\n **/","import '../assets/media/images/favicon.png';\nimport '../assets/media/images/logo-fb.png';\nimport config from './configs/app.config';\nimport common from './common';\nimport modules from './modules';\n\nconst app = angular.module('app', [\n    'ui.router',\n    'ngAnimate',\n    'restangular',\n    common,\n    modules\n])\n.config(config)\n.name;\n\n\nangular.element (document).ready (() => {\n    angular.bootstrap (document, [\n        app\n    ]);\n});\n\n(function (d, w, c) {\n    (w[c] = w[c] || []).push(function() {\n        try {\n            w.yaCounter23830300 = new Ya.Metrika({\n                id:23830300,\n                clickmap:true,\n                trackLinks:true,\n                accurateTrackBounce:true,\n                webvisor:true,\n                trackHash:true\n            });\n        } catch(e) { }\n    });\n\n    var n = d.getElementsByTagName(\"script\")[0],\n        s = d.createElement(\"script\"),\n        f = function () { n.parentNode.insertBefore(s, n); };\n    s.type = \"text/javascript\";\n    s.async = true;\n    s.src = \"https://mc.yandex.ru/metrika/watch.js\";\n\n    if (w.opera == \"[object Opera]\") {\n        d.addEventListener(\"DOMContentLoaded\", f, false);\n    } else { f(); }\n})(document, window, \"yandex_metrika_callbacks\");\n\n(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\nm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\nga('create', 'UA-47736010-1', 'auto');\nga('send', 'pageview');\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/app.js\n **/","module.exports = __webpack_public_path__ + \"static/png/favicon.png\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/assets/media/images/favicon.png\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"static/png/logo-fb.png\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/assets/media/images/logo-fb.png\n ** module id = 2\n ** module chunks = 0\n **/","'use strict'\r\n\r\n/**\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Computes the difference between two texts to create a patch.\r\n * Applies the patch onto another text, allowing for errors.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nfunction diff_match_patch() {\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  this.Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  this.Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  this.Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  this.Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  this.Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  this.Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  this.Match_MaxBits = 32;\r\n}\r\n\r\n\r\n//  DIFF FUNCTIONS\r\n\r\n\r\n/**\r\n * The data structure representing a diff is an array of tuples:\r\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n */\r\nvar DIFF_DELETE = -1;\r\nvar DIFF_INSERT = 1;\r\nvar DIFF_EQUAL = 0;\r\n\r\n/** @typedef {{0: number, 1: string}} */\r\ndiff_match_patch.Diff;\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Simplifies the problem by stripping\r\n * any common prefix or suffix off the texts before diffing.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n *     then don't run a line-level diff first to identify the changed areas.\r\n *     Defaults to true, which does a faster, slightly less optimal diff.\r\n * @param {number} opt_deadline Optional time when the diff should be complete\r\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n *     instead.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n    opt_deadline) {\r\n  // Set a deadline by which time the diff must be complete.\r\n  if (typeof opt_deadline == 'undefined') {\r\n    if (this.Diff_Timeout <= 0) {\r\n      opt_deadline = Number.MAX_VALUE;\r\n    } else {\r\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n    }\r\n  }\r\n  var deadline = opt_deadline;\r\n\r\n  // Check for null inputs.\r\n  if (text1 == null || text2 == null) {\r\n    throw new Error('Null input. (diff_main)');\r\n  }\r\n\r\n  // Check for equality (speedup).\r\n  if (text1 == text2) {\r\n    if (text1) {\r\n      return [[DIFF_EQUAL, text1]];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  if (typeof opt_checklines == 'undefined') {\r\n    opt_checklines = true;\r\n  }\r\n  var checklines = opt_checklines;\r\n\r\n  // Trim off common prefix (speedup).\r\n  var commonlength = this.diff_commonPrefix(text1, text2);\r\n  var commonprefix = text1.substring(0, commonlength);\r\n  text1 = text1.substring(commonlength);\r\n  text2 = text2.substring(commonlength);\r\n\r\n  // Trim off common suffix (speedup).\r\n  commonlength = this.diff_commonSuffix(text1, text2);\r\n  var commonsuffix = text1.substring(text1.length - commonlength);\r\n  text1 = text1.substring(0, text1.length - commonlength);\r\n  text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n  // Compute the diff on the middle block.\r\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n  // Restore the prefix and suffix.\r\n  if (commonprefix) {\r\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n  }\r\n  if (commonsuffix) {\r\n    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n  }\r\n  this.diff_cleanupMerge(diffs);\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Assumes that the texts do not\r\n * have any common prefix or suffix.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n *     line-level diff first to identify the changed areas.\r\n *     If true, then run a faster, slightly less optimal diff.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n    deadline) {\r\n  var diffs;\r\n\r\n  if (!text1) {\r\n    // Just add some text (speedup).\r\n    return [[DIFF_INSERT, text2]];\r\n  }\r\n\r\n  if (!text2) {\r\n    // Just delete some text (speedup).\r\n    return [[DIFF_DELETE, text1]];\r\n  }\r\n\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  var i = longtext.indexOf(shorttext);\r\n  if (i != -1) {\r\n    // Shorter text is inside the longer text (speedup).\r\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n             [DIFF_EQUAL, shorttext],\r\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n    // Swap insertions for deletions if diff is reversed.\r\n    if (text1.length > text2.length) {\r\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  if (shorttext.length == 1) {\r\n    // Single character string.\r\n    // After the previous speedup, the character can't be an equality.\r\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n  }\r\n\r\n  // Check to see if the problem can be split in two.\r\n  var hm = this.diff_halfMatch_(text1, text2);\r\n  if (hm) {\r\n    // A half-match was found, sort out the return data.\r\n    var text1_a = hm[0];\r\n    var text1_b = hm[1];\r\n    var text2_a = hm[2];\r\n    var text2_b = hm[3];\r\n    var mid_common = hm[4];\r\n    // Send both pairs off for separate processing.\r\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n    // Merge the results.\r\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n  }\r\n\r\n  if (checklines && text1.length > 100 && text2.length > 100) {\r\n    return this.diff_lineMode_(text1, text2, deadline);\r\n  }\r\n\r\n  return this.diff_bisect_(text1, text2, deadline);\r\n};\r\n\r\n\r\n/**\r\n * Do a quick line-level diff on both strings, then rediff the parts for\r\n * greater accuracy.\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n  // Scan the text on a line-by-line basis first.\r\n  var a = this.diff_linesToChars_(text1, text2);\r\n  text1 = a.chars1;\r\n  text2 = a.chars2;\r\n  var linearray = a.lineArray;\r\n\r\n  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n  // Convert the diff back to original text.\r\n  this.diff_charsToLines_(diffs, linearray);\r\n  // Eliminate freak matches (e.g. blank lines)\r\n  this.diff_cleanupSemantic(diffs);\r\n\r\n  // Rediff any replacement blocks, this time character-by-character.\r\n  // Add a dummy entry at the end.\r\n  diffs.push([DIFF_EQUAL, '']);\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete >= 1 && count_insert >= 1) {\r\n          // Delete the offending records and add the merged ones.\r\n          diffs.splice(pointer - count_delete - count_insert,\r\n                       count_delete + count_insert);\r\n          pointer = pointer - count_delete - count_insert;\r\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n          for (var j = a.length - 1; j >= 0; j--) {\r\n            diffs.splice(pointer, 0, a[j]);\r\n          }\r\n          pointer = pointer + a.length;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n    pointer++;\r\n  }\r\n  diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the 'middle snake' of a diff, split the problem in two\r\n * and return the recursively constructed diff.\r\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n  var v_offset = max_d;\r\n  var v_length = 2 * max_d;\r\n  var v1 = new Array(v_length);\r\n  var v2 = new Array(v_length);\r\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n  // integers and undefined.\r\n  for (var x = 0; x < v_length; x++) {\r\n    v1[x] = -1;\r\n    v2[x] = -1;\r\n  }\r\n  v1[v_offset + 1] = 0;\r\n  v2[v_offset + 1] = 0;\r\n  var delta = text1_length - text2_length;\r\n  // If the total number of characters is odd, then the front path will collide\r\n  // with the reverse path.\r\n  var front = (delta % 2 != 0);\r\n  // Offsets for start and end of k loop.\r\n  // Prevents mapping of space beyond the grid.\r\n  var k1start = 0;\r\n  var k1end = 0;\r\n  var k2start = 0;\r\n  var k2end = 0;\r\n  for (var d = 0; d < max_d; d++) {\r\n    // Bail out if deadline is reached.\r\n    if ((new Date()).getTime() > deadline) {\r\n      break;\r\n    }\r\n\r\n    // Walk the front path one step.\r\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n      var k1_offset = v_offset + k1;\r\n      var x1;\r\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n        x1 = v1[k1_offset + 1];\r\n      } else {\r\n        x1 = v1[k1_offset - 1] + 1;\r\n      }\r\n      var y1 = x1 - k1;\r\n      while (x1 < text1_length && y1 < text2_length &&\r\n             text1.charAt(x1) == text2.charAt(y1)) {\r\n        x1++;\r\n        y1++;\r\n      }\r\n      v1[k1_offset] = x1;\r\n      if (x1 > text1_length) {\r\n        // Ran off the right of the graph.\r\n        k1end += 2;\r\n      } else if (y1 > text2_length) {\r\n        // Ran off the bottom of the graph.\r\n        k1start += 2;\r\n      } else if (front) {\r\n        var k2_offset = v_offset + delta - k1;\r\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n          // Mirror x2 onto top-left coordinate system.\r\n          var x2 = text1_length - v2[k2_offset];\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Walk the reverse path one step.\r\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n      var k2_offset = v_offset + k2;\r\n      var x2;\r\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n        x2 = v2[k2_offset + 1];\r\n      } else {\r\n        x2 = v2[k2_offset - 1] + 1;\r\n      }\r\n      var y2 = x2 - k2;\r\n      while (x2 < text1_length && y2 < text2_length &&\r\n             text1.charAt(text1_length - x2 - 1) ==\r\n             text2.charAt(text2_length - y2 - 1)) {\r\n        x2++;\r\n        y2++;\r\n      }\r\n      v2[k2_offset] = x2;\r\n      if (x2 > text1_length) {\r\n        // Ran off the left of the graph.\r\n        k2end += 2;\r\n      } else if (y2 > text2_length) {\r\n        // Ran off the top of the graph.\r\n        k2start += 2;\r\n      } else if (!front) {\r\n        var k1_offset = v_offset + delta - k2;\r\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n          var x1 = v1[k1_offset];\r\n          var y1 = v_offset + x1 - k1_offset;\r\n          // Mirror x2 onto top-left coordinate system.\r\n          x2 = text1_length - x2;\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Diff took too long and hit the deadline or\r\n  // number of diffs equals number of characters, no commonality at all.\r\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n};\r\n\r\n\r\n/**\r\n * Given the location of the 'middle snake', split the diff in two parts\r\n * and recurse.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} x Index of split point in text1.\r\n * @param {number} y Index of split point in text2.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n    deadline) {\r\n  var text1a = text1.substring(0, x);\r\n  var text2a = text2.substring(0, y);\r\n  var text1b = text1.substring(x);\r\n  var text2b = text2.substring(y);\r\n\r\n  // Compute both diffs serially.\r\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n  return diffs.concat(diffsb);\r\n};\r\n\r\n\r\n/**\r\n * Split two texts into an array of strings.  Reduce the texts to a string of\r\n * hashes where each Unicode character represents one line.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n *     An object containing the encoded text1, the encoded text2 and\r\n *     the array of unique strings.\r\n *     The zeroth element of the array of unique strings is intentionally blank.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n  // '\\x00' is a valid character, but various debuggers don't like it.\r\n  // So we'll insert a junk entry to avoid generating a null character.\r\n  lineArray[0] = '';\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  function diff_linesToCharsMunge_(text) {\r\n    var chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    var lineStart = 0;\r\n    var lineEnd = -1;\r\n    // Keeping our own length variable is faster than looking it up.\r\n    var lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      var line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  var chars1 = diff_linesToCharsMunge_(text1);\r\n  var chars2 = diff_linesToCharsMunge_(text2);\r\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n};\r\n\r\n\r\n/**\r\n * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n * text.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {!Array.<string>} lineArray Array of unique strings.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var chars = diffs[x][1];\r\n    var text = [];\r\n    for (var y = 0; y < chars.length; y++) {\r\n      text[y] = lineArray[chars.charCodeAt(y)];\r\n    }\r\n    diffs[x][1] = text.join('');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Determine the common prefix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the start of each\r\n *     string.\r\n */\r\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerstart = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(pointerstart, pointermid) ==\r\n        text2.substring(pointerstart, pointermid)) {\r\n      pointermin = pointermid;\r\n      pointerstart = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine the common suffix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of each string.\r\n */\r\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 ||\r\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerend = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n      pointermin = pointermid;\r\n      pointerend = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the suffix of one string is the prefix of another.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of the first\r\n *     string and the start of the second string.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  // Eliminate the null case.\r\n  if (text1_length == 0 || text2_length == 0) {\r\n    return 0;\r\n  }\r\n  // Truncate the longer string.\r\n  if (text1_length > text2_length) {\r\n    text1 = text1.substring(text1_length - text2_length);\r\n  } else if (text1_length < text2_length) {\r\n    text2 = text2.substring(0, text1_length);\r\n  }\r\n  var text_length = Math.min(text1_length, text2_length);\r\n  // Quick check for the worst case.\r\n  if (text1 == text2) {\r\n    return text_length;\r\n  }\r\n\r\n  // Start by looking for a single character match\r\n  // and increase length until no match is found.\r\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n  var best = 0;\r\n  var length = 1;\r\n  while (true) {\r\n    var pattern = text1.substring(text_length - length);\r\n    var found = text2.indexOf(pattern);\r\n    if (found == -1) {\r\n      return best;\r\n    }\r\n    length += found;\r\n    if (found == 0 || text1.substring(text_length - length) ==\r\n        text2.substring(0, length)) {\r\n      best = length;\r\n      length++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Do the two texts share a substring which is at least half the length of the\r\n * longer text?\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {Array.<string>} Five element Array, containing the prefix of\r\n *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n *     text2 and the common middle.  Or null if there was no match.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n  if (this.Diff_Timeout <= 0) {\r\n    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n    return null;\r\n  }\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n    return null;  // Pointless.\r\n  }\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  function diff_halfMatchI_(longtext, shorttext, i) {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    var j = -1;\r\n    var best_common = '';\r\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                               shorttext.substring(j));\r\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                               shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // First check if the second quarter is the seed for a half-match.\r\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 4));\r\n  // Check again based on the third quarter.\r\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 2));\r\n  var hm;\r\n  if (!hm1 && !hm2) {\r\n    return null;\r\n  } else if (!hm2) {\r\n    hm = hm1;\r\n  } else if (!hm1) {\r\n    hm = hm2;\r\n  } else {\r\n    // Both matched.  Select the longest.\r\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n  }\r\n\r\n  // A half-match was found, sort out the return data.\r\n  var text1_a, text1_b, text2_a, text2_b;\r\n  if (text1.length > text2.length) {\r\n    text1_a = hm[0];\r\n    text1_b = hm[1];\r\n    text2_a = hm[2];\r\n    text2_b = hm[3];\r\n  } else {\r\n    text2_a = hm[0];\r\n    text2_b = hm[1];\r\n    text1_a = hm[2];\r\n    text1_b = hm[3];\r\n  }\r\n  var mid_common = hm[4];\r\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n};\r\n\r\n\r\n/**\r\n * Reduce the number of edits by eliminating semantically trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Number of characters that changed prior to the equality.\r\n  var length_insertions1 = 0;\r\n  var length_deletions1 = 0;\r\n  // Number of characters that changed after the equality.\r\n  var length_insertions2 = 0;\r\n  var length_deletions2 = 0;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      equalities[equalitiesLength++] = pointer;\r\n      length_insertions1 = length_insertions2;\r\n      length_deletions1 = length_deletions2;\r\n      length_insertions2 = 0;\r\n      length_deletions2 = 0;\r\n      lastequality = diffs[pointer][1];\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_INSERT) {\r\n        length_insertions2 += diffs[pointer][1].length;\r\n      } else {\r\n        length_deletions2 += diffs[pointer][1].length;\r\n      }\r\n      // Eliminate an equality that is smaller or equal to the edits on both\r\n      // sides of it.\r\n      if (lastequality && (lastequality.length <=\r\n          Math.max(length_insertions1, length_deletions1)) &&\r\n          (lastequality.length <= Math.max(length_insertions2,\r\n                                           length_deletions2))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        // Throw away the equality we just deleted.\r\n        equalitiesLength--;\r\n        // Throw away the previous equality (it needs to be reevaluated).\r\n        equalitiesLength--;\r\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n        length_insertions1 = 0;  // Reset the counters.\r\n        length_deletions1 = 0;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = null;\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  // Normalize the diff.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n  this.diff_cleanupSemanticLossless(diffs);\r\n\r\n  // Find any overlaps between deletions and insertions.\r\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n  //   -> <del>abc</del>xxx<ins>def</ins>\r\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n  //   -> <ins>def</ins>xxx<del>abc</del>\r\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n  pointer = 1;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n        diffs[pointer][0] == DIFF_INSERT) {\r\n      var deletion = diffs[pointer - 1][1];\r\n      var insertion = diffs[pointer][1];\r\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n      if (overlap_length1 >= overlap_length2) {\r\n        if (overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2) {\r\n          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n          diffs[pointer - 1][1] =\r\n              deletion.substring(0, deletion.length - overlap_length1);\r\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n          pointer++;\r\n        }\r\n      } else {\r\n        if (overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2) {\r\n          // Reverse overlap found.\r\n          // Insert an equality and swap and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n          diffs[pointer - 1][0] = DIFF_INSERT;\r\n          diffs[pointer - 1][1] =\r\n              insertion.substring(0, insertion.length - overlap_length2);\r\n          diffs[pointer + 1][0] = DIFF_DELETE;\r\n          diffs[pointer + 1][1] =\r\n              deletion.substring(overlap_length2);\r\n          pointer++;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Look for single edits surrounded on both sides by equalities\r\n * which can be shifted sideways to align the edit to a word boundary.\r\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n  /**\r\n   * Given two strings, compute a score representing whether the internal\r\n   * boundary falls on logical boundaries.\r\n   * Scores range from 6 (best) to 0 (worst).\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} one First string.\r\n   * @param {string} two Second string.\r\n   * @return {number} The score.\r\n   * @private\r\n   */\r\n  function diff_cleanupSemanticScore_(one, two) {\r\n    if (!one || !two) {\r\n      // Edges are the best.\r\n      return 6;\r\n    }\r\n\r\n    // Each port of this function behaves slightly differently due to\r\n    // subtle differences in each language's definition of things like\r\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n    // the choice has been made to use each language's native features\r\n    // rather than force total conformity.\r\n    var char1 = one.charAt(one.length - 1);\r\n    var char2 = two.charAt(0);\r\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var whitespace1 = nonAlphaNumeric1 &&\r\n        char1.match(diff_match_patch.whitespaceRegex_);\r\n    var whitespace2 = nonAlphaNumeric2 &&\r\n        char2.match(diff_match_patch.whitespaceRegex_);\r\n    var lineBreak1 = whitespace1 &&\r\n        char1.match(diff_match_patch.linebreakRegex_);\r\n    var lineBreak2 = whitespace2 &&\r\n        char2.match(diff_match_patch.linebreakRegex_);\r\n    var blankLine1 = lineBreak1 &&\r\n        one.match(diff_match_patch.blanklineEndRegex_);\r\n    var blankLine2 = lineBreak2 &&\r\n        two.match(diff_match_patch.blanklineStartRegex_);\r\n\r\n    if (blankLine1 || blankLine2) {\r\n      // Five points for blank lines.\r\n      return 5;\r\n    } else if (lineBreak1 || lineBreak2) {\r\n      // Four points for line breaks.\r\n      return 4;\r\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n      // Three points for end of sentences.\r\n      return 3;\r\n    } else if (whitespace1 || whitespace2) {\r\n      // Two points for whitespace.\r\n      return 2;\r\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n      // One point for non-alphanumeric.\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  var pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      var equality1 = diffs[pointer - 1][1];\r\n      var edit = diffs[pointer][1];\r\n      var equality2 = diffs[pointer + 1][1];\r\n\r\n      // First, shift the edit as far left as possible.\r\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n      if (commonOffset) {\r\n        var commonString = edit.substring(edit.length - commonOffset);\r\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n        equality2 = commonString + equality2;\r\n      }\r\n\r\n      // Second, step character by character right, looking for the best fit.\r\n      var bestEquality1 = equality1;\r\n      var bestEdit = edit;\r\n      var bestEquality2 = equality2;\r\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n      while (edit.charAt(0) === equality2.charAt(0)) {\r\n        equality1 += edit.charAt(0);\r\n        edit = edit.substring(1) + equality2.charAt(0);\r\n        equality2 = equality2.substring(1);\r\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        // The >= encourages trailing rather than leading whitespace on edits.\r\n        if (score >= bestScore) {\r\n          bestScore = score;\r\n          bestEquality1 = equality1;\r\n          bestEdit = edit;\r\n          bestEquality2 = equality2;\r\n        }\r\n      }\r\n\r\n      if (diffs[pointer - 1][1] != bestEquality1) {\r\n        // We have an improvement, save it back to the diff.\r\n        if (bestEquality1) {\r\n          diffs[pointer - 1][1] = bestEquality1;\r\n        } else {\r\n          diffs.splice(pointer - 1, 1);\r\n          pointer--;\r\n        }\r\n        diffs[pointer][1] = bestEdit;\r\n        if (bestEquality2) {\r\n          diffs[pointer + 1][1] = bestEquality2;\r\n        } else {\r\n          diffs.splice(pointer + 1, 1);\r\n          pointer--;\r\n        }\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n// Define some regex patterns for matching boundaries.\r\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\ndiff_match_patch.whitespaceRegex_ = /\\s/;\r\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\r\n/**\r\n * Reduce the number of edits by eliminating operationally trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Is there an insertion operation before the last equality.\r\n  var pre_ins = false;\r\n  // Is there a deletion operation before the last equality.\r\n  var pre_del = false;\r\n  // Is there an insertion operation after the last equality.\r\n  var post_ins = false;\r\n  // Is there a deletion operation after the last equality.\r\n  var post_del = false;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)) {\r\n        // Candidate found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        pre_ins = post_ins;\r\n        pre_del = post_del;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // Not a candidate, and can never become one.\r\n        equalitiesLength = 0;\r\n        lastequality = null;\r\n      }\r\n      post_ins = post_del = false;\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_DELETE) {\r\n        post_del = true;\r\n      } else {\r\n        post_ins = true;\r\n      }\r\n      /*\r\n       * Five types to be split:\r\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<del>C</del>\r\n       */\r\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        equalitiesLength--;  // Throw away the equality we just deleted;\r\n        lastequality = null;\r\n        if (pre_ins && pre_del) {\r\n          // No changes made which could affect previous entry, keep going.\r\n          post_ins = post_del = true;\r\n          equalitiesLength = 0;\r\n        } else {\r\n          equalitiesLength--;  // Throw away the previous equality.\r\n          pointer = equalitiesLength > 0 ?\r\n              equalities[equalitiesLength - 1] : -1;\r\n          post_ins = post_del = false;\r\n        }\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Reorder and merge like edit sections.  Merge equalities.\r\n * Any edit section can move as long as it doesn't cross an equality.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  var commonlength;\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete + count_insert > 1) {\r\n          if (count_delete !== 0 && count_insert !== 0) {\r\n            // Factor out any common prefixies.\r\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              if ((pointer - count_delete - count_insert) > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                  DIFF_EQUAL) {\r\n                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n              } else {\r\n                diffs.splice(0, 0, [DIFF_EQUAL,\r\n                                    text_insert.substring(0, commonlength)]);\r\n                pointer++;\r\n              }\r\n              text_insert = text_insert.substring(commonlength);\r\n              text_delete = text_delete.substring(commonlength);\r\n            }\r\n            // Factor out any common suffixies.\r\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                  commonlength) + diffs[pointer][1];\r\n              text_insert = text_insert.substring(0, text_insert.length -\r\n                  commonlength);\r\n              text_delete = text_delete.substring(0, text_delete.length -\r\n                  commonlength);\r\n            }\r\n          }\r\n          // Delete the offending records and add the merged ones.\r\n          if (count_delete === 0) {\r\n            diffs.splice(pointer - count_insert,\r\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n          } else if (count_insert === 0) {\r\n            diffs.splice(pointer - count_delete,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n          } else {\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n                [DIFF_INSERT, text_insert]);\r\n          }\r\n          pointer = pointer - count_delete - count_insert +\r\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n          // Merge this equality with the previous one.\r\n          diffs[pointer - 1][1] += diffs[pointer][1];\r\n          diffs.splice(pointer, 1);\r\n        } else {\r\n          pointer++;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n  }\r\n  if (diffs[diffs.length - 1][1] === '') {\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n  }\r\n\r\n  // Second pass: look for single edits surrounded on both sides by equalities\r\n  // which can be shifted sideways to eliminate an equality.\r\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n  var changes = false;\r\n  pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n        // Shift the edit over the previous equality.\r\n        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                        diffs[pointer - 1][1].length);\r\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n        diffs.splice(pointer - 1, 1);\r\n        changes = true;\r\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n          diffs[pointer + 1][1]) {\r\n        // Shift the edit over the next equality.\r\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n        diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n        diffs.splice(pointer + 1, 1);\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n  // If shifts were made, the diff needs reordering and another shift sweep.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * loc is a location in text1, compute and return the equivalent location in\r\n * text2.\r\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {number} loc Location within text1.\r\n * @return {number} Location within text2.\r\n */\r\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n  var chars1 = 0;\r\n  var chars2 = 0;\r\n  var last_chars1 = 0;\r\n  var last_chars2 = 0;\r\n  var x;\r\n  for (x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n      chars1 += diffs[x][1].length;\r\n    }\r\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n      chars2 += diffs[x][1].length;\r\n    }\r\n    if (chars1 > loc) {  // Overshot the location.\r\n      break;\r\n    }\r\n    last_chars1 = chars1;\r\n    last_chars2 = chars2;\r\n  }\r\n  // Was the location was deleted?\r\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n    return last_chars2;\r\n  }\r\n  // Add the remaining character length.\r\n  return last_chars2 + (loc - last_chars1);\r\n};\r\n\r\n\r\n/**\r\n * Convert a diff array into a pretty HTML report.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} HTML representation.\r\n */\r\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n  var html = [];\r\n  var pattern_amp = /&/g;\r\n  var pattern_lt = /</g;\r\n  var pattern_gt = />/g;\r\n  var pattern_para = /\\n/g;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n    var data = diffs[x][1];  // Text of change.\r\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n        break;\r\n      case DIFF_DELETE:\r\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        html[x] = '<span>' + text + '</span>';\r\n        break;\r\n    }\r\n  }\r\n  return html.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the source text (all equalities and deletions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Source text.\r\n */\r\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the destination text (all equalities and insertions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Destination text.\r\n */\r\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_DELETE) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute the Levenshtein distance; the number of inserted, deleted or\r\n * substituted characters.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {number} Number of changes.\r\n */\r\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n  var levenshtein = 0;\r\n  var insertions = 0;\r\n  var deletions = 0;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];\r\n    var data = diffs[x][1];\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        insertions += data.length;\r\n        break;\r\n      case DIFF_DELETE:\r\n        deletions += data.length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // A deletion and an insertion is one substitution.\r\n        levenshtein += Math.max(insertions, deletions);\r\n        insertions = 0;\r\n        deletions = 0;\r\n        break;\r\n    }\r\n  }\r\n  levenshtein += Math.max(insertions, deletions);\r\n  return levenshtein;\r\n};\r\n\r\n\r\n/**\r\n * Crush the diff into an encoded string which describes the operations\r\n * required to transform text1 into text2.\r\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Delta text.\r\n */\r\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    switch (diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        text[x] = '+' + encodeURI(diffs[x][1]);\r\n        break;\r\n      case DIFF_DELETE:\r\n        text[x] = '-' + diffs[x][1].length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        text[x] = '=' + diffs[x][1].length;\r\n        break;\r\n    }\r\n  }\r\n  return text.join('\\t').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Given the original text1, and an encoded string which describes the\r\n * operations required to transform text1 into text2, compute the full diff.\r\n * @param {string} text1 Source string for the diff.\r\n * @param {string} delta Delta text.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n  var diffs = [];\r\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n  var pointer = 0;  // Cursor in text1\r\n  var tokens = delta.split(/\\t/g);\r\n  for (var x = 0; x < tokens.length; x++) {\r\n    // Each token begins with a one character parameter which specifies the\r\n    // operation of this token (delete, insert, equality).\r\n    var param = tokens[x].substring(1);\r\n    switch (tokens[x].charAt(0)) {\r\n      case '+':\r\n        try {\r\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n        }\r\n        break;\r\n      case '-':\r\n        // Fall through.\r\n      case '=':\r\n        var n = parseInt(param, 10);\r\n        if (isNaN(n) || n < 0) {\r\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n        }\r\n        var text = text1.substring(pointer, pointer += n);\r\n        if (tokens[x].charAt(0) == '=') {\r\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n        } else {\r\n          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n        }\r\n        break;\r\n      default:\r\n        // Blank tokens are ok (from a trailing \\t).\r\n        // Anything else is an error.\r\n        if (tokens[x]) {\r\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                          tokens[x]);\r\n        }\r\n    }\r\n  }\r\n  if (pointer != text1.length) {\r\n    throw new Error('Delta length (' + pointer +\r\n        ') does not equal source text length (' + text1.length + ').');\r\n  }\r\n  return diffs;\r\n};\r\n\r\n\r\n//  MATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n */\r\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n  // Check for null inputs.\r\n  if (text == null || pattern == null || loc == null) {\r\n    throw new Error('Null input. (match_main)');\r\n  }\r\n\r\n  loc = Math.max(0, Math.min(loc, text.length));\r\n  if (text == pattern) {\r\n    // Shortcut (potentially not guaranteed by the algorithm)\r\n    return 0;\r\n  } else if (!text.length) {\r\n    // Nothing to match.\r\n    return -1;\r\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n    return loc;\r\n  } else {\r\n    // Do a fuzzy compare.\r\n    return this.match_bitap_(text, pattern, loc);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n * Bitap algorithm.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n  if (pattern.length > this.Match_MaxBits) {\r\n    throw new Error('Pattern too long for this browser.');\r\n  }\r\n\r\n  // Initialise the alphabet.\r\n  var s = this.match_alphabet_(pattern);\r\n\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Compute and return the score for a match with e errors and x location.\r\n   * Accesses loc and pattern through being a closure.\r\n   * @param {number} e Number of errors in match.\r\n   * @param {number} x Location of match.\r\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n   * @private\r\n   */\r\n  function match_bitapScore_(e, x) {\r\n    var accuracy = e / pattern.length;\r\n    var proximity = Math.abs(loc - x);\r\n    if (!dmp.Match_Distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n    return accuracy + (proximity / dmp.Match_Distance);\r\n  }\r\n\r\n  // Highest score beyond which we give up.\r\n  var score_threshold = this.Match_Threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  var best_loc = text.indexOf(pattern, loc);\r\n  if (best_loc != -1) {\r\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    // What about in the other direction? (speedup)\r\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n    if (best_loc != -1) {\r\n      score_threshold =\r\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    }\r\n  }\r\n\r\n  // Initialise the bit arrays.\r\n  var matchmask = 1 << (pattern.length - 1);\r\n  best_loc = -1;\r\n\r\n  var bin_min, bin_mid;\r\n  var bin_max = pattern.length + text.length;\r\n  var last_rd;\r\n  for (var d = 0; d < pattern.length; d++) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from 'loc' we can stray at this\r\n    // error level.\r\n    bin_min = 0;\r\n    bin_mid = bin_max;\r\n    while (bin_min < bin_mid) {\r\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n        bin_min = bin_mid;\r\n      } else {\r\n        bin_max = bin_mid;\r\n      }\r\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n    }\r\n    // Use the result from this iteration as the maximum for the next.\r\n    bin_max = bin_mid;\r\n    var start = Math.max(1, loc - bin_mid + 1);\r\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n    var rd = Array(finish + 2);\r\n    rd[finish + 1] = (1 << d) - 1;\r\n    for (var j = finish; j >= start; j--) {\r\n      // The alphabet (s) is a sparse hash, so the following line generates\r\n      // warnings.\r\n      var charMatch = s[text.charAt(j - 1)];\r\n      if (d === 0) {  // First pass: exact match.\r\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n      } else {  // Subsequent passes: fuzzy match.\r\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                last_rd[j + 1];\r\n      }\r\n      if (rd[j] & matchmask) {\r\n        var score = match_bitapScore_(d, j - 1);\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (score <= score_threshold) {\r\n          // Told you so.\r\n          score_threshold = score;\r\n          best_loc = j - 1;\r\n          if (best_loc > loc) {\r\n            // When passing loc, don't exceed our current distance from loc.\r\n            start = Math.max(1, 2 * loc - best_loc);\r\n          } else {\r\n            // Already passed loc, downhill from here on in.\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // No hope for a (better) match at greater error levels.\r\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n      break;\r\n    }\r\n    last_rd = rd;\r\n  }\r\n  return best_loc;\r\n};\r\n\r\n\r\n/**\r\n * Initialise the alphabet for the Bitap algorithm.\r\n * @param {string} pattern The text to encode.\r\n * @return {!Object} Hash of character locations.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n  var s = {};\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] = 0;\r\n  }\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n//  PATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Increase the context until it is unique,\r\n * but don't let the pattern expand beyond Match_MaxBits.\r\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n * @param {string} text Source text.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n  if (text.length == 0) {\r\n    return;\r\n  }\r\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n  var padding = 0;\r\n\r\n  // Look for the first and last matches of pattern in text.  If two different\r\n  // matches are found, increase the pattern length.\r\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n         this.Patch_Margin) {\r\n    padding += this.Patch_Margin;\r\n    pattern = text.substring(patch.start2 - padding,\r\n                             patch.start2 + patch.length1 + padding);\r\n  }\r\n  // Add one chunk for good luck.\r\n  padding += this.Patch_Margin;\r\n\r\n  // Add the prefix.\r\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n  if (prefix) {\r\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n  }\r\n  // Add the suffix.\r\n  var suffix = text.substring(patch.start2 + patch.length1,\r\n                              patch.start2 + patch.length1 + padding);\r\n  if (suffix) {\r\n    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n  }\r\n\r\n  // Roll back the start points.\r\n  patch.start1 -= prefix.length;\r\n  patch.start2 -= prefix.length;\r\n  // Extend the lengths.\r\n  patch.length1 += prefix.length + suffix.length;\r\n  patch.length2 += prefix.length + suffix.length;\r\n};\r\n\r\n\r\n/**\r\n * Compute a list of patches to turn text1 into text2.\r\n * Use diffs if provided, otherwise compute it ourselves.\r\n * There are four ways to call this function, depending on what data is\r\n * available to the caller:\r\n * Method 1:\r\n * a = text1, b = text2\r\n * Method 2:\r\n * a = diffs\r\n * Method 3 (optimal):\r\n * a = text1, b = diffs\r\n * Method 4 (deprecated, use method 3):\r\n * a = text1, b = text2, c = diffs\r\n *\r\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n * Array of diff tuples for text1 to text2 (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n  var text1, diffs;\r\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 1: text1, text2\r\n    // Compute diffs from text1 and text2.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n    if (diffs.length > 2) {\r\n      this.diff_cleanupSemantic(diffs);\r\n      this.diff_cleanupEfficiency(diffs);\r\n    }\r\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 2: diffs\r\n    // Compute text1 from diffs.\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n    text1 = this.diff_text1(diffs);\r\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 3: text1, diffs\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      opt_c && typeof opt_c == 'object') {\r\n    // Method 4: text1, text2, diffs\r\n    // text2 is not used.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n  } else {\r\n    throw new Error('Unknown call format to patch_make.');\r\n  }\r\n\r\n  if (diffs.length === 0) {\r\n    return [];  // Get rid of the null case.\r\n  }\r\n  var patches = [];\r\n  var patch = new diff_match_patch.patch_obj();\r\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n  var char_count1 = 0;  // Number of characters into the text1 string.\r\n  var char_count2 = 0;  // Number of characters into the text2 string.\r\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n  // context info.\r\n  var prepatch_text = text1;\r\n  var postpatch_text = text1;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var diff_type = diffs[x][0];\r\n    var diff_text = diffs[x][1];\r\n\r\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n      // A new patch starts here.\r\n      patch.start1 = char_count1;\r\n      patch.start2 = char_count2;\r\n    }\r\n\r\n    switch (diff_type) {\r\n      case DIFF_INSERT:\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        patch.length2 += diff_text.length;\r\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                         postpatch_text.substring(char_count2);\r\n        break;\r\n      case DIFF_DELETE:\r\n        patch.length1 += diff_text.length;\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                         postpatch_text.substring(char_count2 +\r\n                             diff_text.length);\r\n        break;\r\n      case DIFF_EQUAL:\r\n        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength && diffs.length != x + 1) {\r\n          // Small equality inside a patch.\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length1 += diff_text.length;\r\n          patch.length2 += diff_text.length;\r\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n          // Time for a new patch.\r\n          if (patchDiffLength) {\r\n            this.patch_addContext_(patch, prepatch_text);\r\n            patches.push(patch);\r\n            patch = new diff_match_patch.patch_obj();\r\n            patchDiffLength = 0;\r\n            // Unlike Unidiff, our patch lists have a rolling context.\r\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n            // Update prepatch text & pos to reflect the application of the\r\n            // just completed patch.\r\n            prepatch_text = postpatch_text;\r\n            char_count1 = char_count2;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Update the current character count.\r\n    if (diff_type !== DIFF_INSERT) {\r\n      char_count1 += diff_text.length;\r\n    }\r\n    if (diff_type !== DIFF_DELETE) {\r\n      char_count2 += diff_text.length;\r\n    }\r\n  }\r\n  // Pick up the leftover patch if not empty.\r\n  if (patchDiffLength) {\r\n    this.patch_addContext_(patch, prepatch_text);\r\n    patches.push(patch);\r\n  }\r\n\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Given an array of patches, return another array that is identical.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n  // Making deep copies is hard in JavaScript.\r\n  var patchesCopy = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var patch = patches[x];\r\n    var patchCopy = new diff_match_patch.patch_obj();\r\n    patchCopy.diffs = [];\r\n    for (var y = 0; y < patch.diffs.length; y++) {\r\n      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n    }\r\n    patchCopy.start1 = patch.start1;\r\n    patchCopy.start2 = patch.start2;\r\n    patchCopy.length1 = patch.length1;\r\n    patchCopy.length2 = patch.length2;\r\n    patchesCopy[x] = patchCopy;\r\n  }\r\n  return patchesCopy;\r\n};\r\n\r\n\r\n/**\r\n * Merge a set of patches onto the text.  Return a patched text, as well\r\n * as a list of true/false values indicating which patches were applied.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @param {string} text Old text.\r\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n *      new text and an array of boolean values.\r\n */\r\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n  if (patches.length == 0) {\r\n    return [text, []];\r\n  }\r\n\r\n  // Deep copy the patches so that no changes are made to originals.\r\n  patches = this.patch_deepCopy(patches);\r\n\r\n  var nullPadding = this.patch_addPadding(patches);\r\n  text = nullPadding + text + nullPadding;\r\n\r\n  this.patch_splitMax(patches);\r\n  // delta keeps track of the offset between the expected and actual location\r\n  // of the previous patch.  If there are patches expected at positions 10 and\r\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n  // has an effective expected position of 22.\r\n  var delta = 0;\r\n  var results = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var expected_loc = patches[x].start2 + delta;\r\n    var text1 = this.diff_text1(patches[x].diffs);\r\n    var start_loc;\r\n    var end_loc = -1;\r\n    if (text1.length > this.Match_MaxBits) {\r\n      // patch_splitMax will only provide an oversized pattern in the case of\r\n      // a monster delete.\r\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                  expected_loc);\r\n      if (start_loc != -1) {\r\n        end_loc = this.match_main(text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits);\r\n        if (end_loc == -1 || start_loc >= end_loc) {\r\n          // Can't find valid trailing context.  Drop this patch.\r\n          start_loc = -1;\r\n        }\r\n      }\r\n    } else {\r\n      start_loc = this.match_main(text, text1, expected_loc);\r\n    }\r\n    if (start_loc == -1) {\r\n      // No match found.  :(\r\n      results[x] = false;\r\n      // Subtract the delta for this failed patch from subsequent patches.\r\n      delta -= patches[x].length2 - patches[x].length1;\r\n    } else {\r\n      // Found a match.  :)\r\n      results[x] = true;\r\n      delta = start_loc - expected_loc;\r\n      var text2;\r\n      if (end_loc == -1) {\r\n        text2 = text.substring(start_loc, start_loc + text1.length);\r\n      } else {\r\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n      }\r\n      if (text1 == text2) {\r\n        // Perfect match, just shove the replacement text in.\r\n        text = text.substring(0, start_loc) +\r\n               this.diff_text2(patches[x].diffs) +\r\n               text.substring(start_loc + text1.length);\r\n      } else {\r\n        // Imperfect match.  Run a diff to get a framework of equivalent\r\n        // indices.\r\n        var diffs = this.diff_main(text1, text2, false);\r\n        if (text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n            this.Patch_DeleteThreshold) {\r\n          // The end points match, but the content is unacceptably bad.\r\n          results[x] = false;\r\n        } else {\r\n          this.diff_cleanupSemanticLossless(diffs);\r\n          var index1 = 0;\r\n          var index2;\r\n          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n            var mod = patches[x].diffs[y];\r\n            if (mod[0] !== DIFF_EQUAL) {\r\n              index2 = this.diff_xIndex(diffs, index1);\r\n            }\r\n            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n              text = text.substring(0, start_loc + index2) + mod[1] +\r\n                     text.substring(start_loc + index2);\r\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n              text = text.substring(0, start_loc + index2) +\r\n                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n                         index1 + mod[1].length));\r\n            }\r\n            if (mod[0] !== DIFF_DELETE) {\r\n              index1 += mod[1].length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Strip the padding off.\r\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n  return [text, results];\r\n};\r\n\r\n\r\n/**\r\n * Add some padding on text start and end so that edges can match something.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} The padding string added to each side.\r\n */\r\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n  var paddingLength = this.Patch_Margin;\r\n  var nullPadding = '';\r\n  for (var x = 1; x <= paddingLength; x++) {\r\n    nullPadding += String.fromCharCode(x);\r\n  }\r\n\r\n  // Bump all the patches forward.\r\n  for (var x = 0; x < patches.length; x++) {\r\n    patches[x].start1 += paddingLength;\r\n    patches[x].start2 += paddingLength;\r\n  }\r\n\r\n  // Add some padding on start of first diff.\r\n  var patch = patches[0];\r\n  var diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n    patch.start1 -= paddingLength;  // Should be 0.\r\n    patch.start2 -= paddingLength;  // Should be 0.\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[0][1].length) {\r\n    // Grow first equality.\r\n    var extraLength = paddingLength - diffs[0][1].length;\r\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n    patch.start1 -= extraLength;\r\n    patch.start2 -= extraLength;\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  // Add some padding on end of last diff.\r\n  patch = patches[patches.length - 1];\r\n  diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.push([DIFF_EQUAL, nullPadding]);\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n    // Grow last equality.\r\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  return nullPadding;\r\n};\r\n\r\n\r\n/**\r\n * Look through the patches and break up any which are longer than the maximum\r\n * limit of the match algorithm.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n  var patch_size = this.Match_MaxBits;\r\n  for (var x = 0; x < patches.length; x++) {\r\n    if (patches[x].length1 <= patch_size) {\r\n      continue;\r\n    }\r\n    var bigpatch = patches[x];\r\n    // Remove the big old patch.\r\n    patches.splice(x--, 1);\r\n    var start1 = bigpatch.start1;\r\n    var start2 = bigpatch.start2;\r\n    var precontext = '';\r\n    while (bigpatch.diffs.length !== 0) {\r\n      // Create one of several smaller patches.\r\n      var patch = new diff_match_patch.patch_obj();\r\n      var empty = true;\r\n      patch.start1 = start1 - precontext.length;\r\n      patch.start2 = start2 - precontext.length;\r\n      if (precontext !== '') {\r\n        patch.length1 = patch.length2 = precontext.length;\r\n        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n      }\r\n      while (bigpatch.diffs.length !== 0 &&\r\n             patch.length1 < patch_size - this.Patch_Margin) {\r\n        var diff_type = bigpatch.diffs[0][0];\r\n        var diff_text = bigpatch.diffs[0][1];\r\n        if (diff_type === DIFF_INSERT) {\r\n          // Insertions are harmless.\r\n          patch.length2 += diff_text.length;\r\n          start2 += diff_text.length;\r\n          patch.diffs.push(bigpatch.diffs.shift());\r\n          empty = false;\r\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n                   diff_text.length > 2 * patch_size) {\r\n          // This is a large deletion.  Let it pass in one chunk.\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          empty = false;\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          bigpatch.diffs.shift();\r\n        } else {\r\n          // Deletion or equality.  Only take as much as we can stomach.\r\n          diff_text = diff_text.substring(0,\r\n              patch_size - patch.length1 - this.Patch_Margin);\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          if (diff_type === DIFF_EQUAL) {\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n          } else {\r\n            empty = false;\r\n          }\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          if (diff_text == bigpatch.diffs[0][1]) {\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            bigpatch.diffs[0][1] =\r\n                bigpatch.diffs[0][1].substring(diff_text.length);\r\n          }\r\n        }\r\n      }\r\n      // Compute the head context for the next patch.\r\n      precontext = this.diff_text2(patch.diffs);\r\n      precontext =\r\n          precontext.substring(precontext.length - this.Patch_Margin);\r\n      // Append the end context for this patch.\r\n      var postcontext = this.diff_text1(bigpatch.diffs)\r\n                            .substring(0, this.Patch_Margin);\r\n      if (postcontext !== '') {\r\n        patch.length1 += postcontext.length;\r\n        patch.length2 += postcontext.length;\r\n        if (patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n        } else {\r\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n        }\r\n      }\r\n      if (!empty) {\r\n        patches.splice(++x, 0, patch);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Take a list of patches and return a textual representation.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} Text representation of patches.\r\n */\r\ndiff_match_patch.prototype.patch_toText = function(patches) {\r\n  var text = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    text[x] = patches[x];\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Parse a textual representation of patches and return a list of Patch objects.\r\n * @param {string} textline Text representation of patches.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.patch_fromText = function(textline) {\r\n  var patches = [];\r\n  if (!textline) {\r\n    return patches;\r\n  }\r\n  var text = textline.split('\\n');\r\n  var textPointer = 0;\r\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n  while (textPointer < text.length) {\r\n    var m = text[textPointer].match(patchHeader);\r\n    if (!m) {\r\n      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n    }\r\n    var patch = new diff_match_patch.patch_obj();\r\n    patches.push(patch);\r\n    patch.start1 = parseInt(m[1], 10);\r\n    if (m[2] === '') {\r\n      patch.start1--;\r\n      patch.length1 = 1;\r\n    } else if (m[2] == '0') {\r\n      patch.length1 = 0;\r\n    } else {\r\n      patch.start1--;\r\n      patch.length1 = parseInt(m[2], 10);\r\n    }\r\n\r\n    patch.start2 = parseInt(m[3], 10);\r\n    if (m[4] === '') {\r\n      patch.start2--;\r\n      patch.length2 = 1;\r\n    } else if (m[4] == '0') {\r\n      patch.length2 = 0;\r\n    } else {\r\n      patch.start2--;\r\n      patch.length2 = parseInt(m[4], 10);\r\n    }\r\n    textPointer++;\r\n\r\n    while (textPointer < text.length) {\r\n      var sign = text[textPointer].charAt(0);\r\n      try {\r\n        var line = decodeURI(text[textPointer].substring(1));\r\n      } catch (ex) {\r\n        // Malformed URI sequence.\r\n        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n      }\r\n      if (sign == '-') {\r\n        // Deletion.\r\n        patch.diffs.push([DIFF_DELETE, line]);\r\n      } else if (sign == '+') {\r\n        // Insertion.\r\n        patch.diffs.push([DIFF_INSERT, line]);\r\n      } else if (sign == ' ') {\r\n        // Minor equality.\r\n        patch.diffs.push([DIFF_EQUAL, line]);\r\n      } else if (sign == '@') {\r\n        // Start of next patch.\r\n        break;\r\n      } else if (sign === '') {\r\n        // Blank line?  Whatever.\r\n      } else {\r\n        // WTF?\r\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n      }\r\n      textPointer++;\r\n    }\r\n  }\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\ndiff_match_patch.patch_obj = function() {\r\n  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n  this.diffs = [];\r\n  /** @type {?number} */\r\n  this.start1 = null;\r\n  /** @type {?number} */\r\n  this.start2 = null;\r\n  /** @type {number} */\r\n  this.length1 = 0;\r\n  /** @type {number} */\r\n  this.length2 = 0;\r\n};\r\n\r\n\r\n/**\r\n * Emmulate GNU diff's format.\r\n * Header: @@ -382,8 +481,9 @@\r\n * Indicies are printed as 1-based, not 0-based.\r\n * @return {string} The GNU diff string.\r\n */\r\ndiff_match_patch.patch_obj.prototype.toString = function() {\r\n  var coords1, coords2;\r\n  if (this.length1 === 0) {\r\n    coords1 = this.start1 + ',0';\r\n  } else if (this.length1 == 1) {\r\n    coords1 = this.start1 + 1;\r\n  } else {\r\n    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n  }\r\n  if (this.length2 === 0) {\r\n    coords2 = this.start2 + ',0';\r\n  } else if (this.length2 == 1) {\r\n    coords2 = this.start2 + 1;\r\n  } else {\r\n    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n  }\r\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n  var op;\r\n  // Escape the body of the patch with %xx notation.\r\n  for (var x = 0; x < this.diffs.length; x++) {\r\n    switch (this.diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        op = '+';\r\n        break;\r\n      case DIFF_DELETE:\r\n        op = '-';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        op = ' ';\r\n        break;\r\n    }\r\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n  }\r\n  return text.join('').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n// The following export code was added by @ForbesLindesay\r\nmodule.exports = diff_match_patch;\r\nmodule.exports['diff_match_patch'] = diff_match_patch;\r\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/diff-match-patch/index.js\n ** module id = 8\n ** module chunks = 0 1\n **/","import textConfig from '../../../configs/text.config';\nimport './suggestions-form.tpl.jade';\n\nclass SuggestionsDirective {\n    /* @ngInject */\n    constructor() {\n        this.restrict = 'E';\n        this.replace = true;\n        this.templateUrl = 'suggestions-form.tpl.jade';\n        this.controller = function (Restangular, $filter) {\n            'ngInject';\n            this.open = false;\n            this.text = textConfig;\n            this.alert = {\n                show: false,\n                success: true\n            };\n\n            this.suggestion = {\n                type: 1,\n                userId: 1,\n                createdOn: $filter('date')(new Date(), 'yyyy-MM-d'),\n                text: ''\n            }\n\n            this.toggleForm = () => {\n                this.open = !this.open;\n            };\n\n            this.sentSuggestion = () => {\n                Restangular.all('suggestions').post(this.suggestion).then((result) => {\n                    this.suggestion.text = '';\n                    this.alert.show = true;\n                });\n            };\n\n            this.closeMessage = () => {\n                this.alert.show = false;\n            }\n        };\n        this.controllerAs = 'ctrl';\n        this.bindToController = true;\n    }\n}\n\nexport default () => new SuggestionsDirective();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/common/directives/suggestions/suggestions.directive.js\n **/","const wellspeakText = {\n    title: 'WellSpeak',\n    source: {\n        random: 'Random Sentence',\n        custom: 'My Sentence',\n        source: 'GRAMMAR RULES',\n        placeholder: 'Choose a rule above',\n        selectPlaceholder: 'Select rule from the dictionary',\n        example: 'xample: '\n    },\n    recognizing: {\n        wait: 'counting result',\n        turnOn: 'and start to talk ',\n        speakNow: 'SPEAK NOW',\n        pronounciation: 'Your Pronounciation',\n        clickHere: 'Click Here',\n        missed: 'missed',\n        wrong: 'wrong'\n    },\n    sidebar: {\n        myProfile: 'My Profile',\n        myStat: 'My Statistics',\n        settings: 'Settings',\n        support: 'Support',\n    },\n    helperLayout: {\n        switcher: 'Random/Manual Sentence switcher',\n        pronunciation: ' Sentence for pronunciation appears here ',\n        check: 'Pronunciation results appear here ',\n        panel: 'Action panel',\n        volume: 'Click to listen to example ',\n        mic: 'Click to start talk'\n    },\n    appDisabled: {\n        mainText: 'We are sorry, but the service works only in Google Chrome.',\n        link: 'Please use Google Chrome to make your pronunciation better.',\n        download: 'Download'\n    },\n    suggestionsForm: {\n        leaveComent: 'Leave us a comment',\n        button: 'Send your ideas',\n        phrase: 'New phrase',\n        suggestion: 'Suggestion',\n        successMessage: 'Thank you for participation!',\n        errorMessage: 'Something went wrong. Please, try later.'\n    }\n}\n\nexport default wellspeakText;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/configs/text.config.js\n **/","module.exports = __webpack_public_path__ + \"suggestions-form.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/common/directives/suggestions/suggestions-form.tpl.jade\n ** module id = 11\n ** module chunks = 0\n **/","import SpeachModule from './speech';\nimport NavbarController from './header.controller';\n\n/* @ngInject */\nexport default angular.module('app.modules', [\n    SpeachModule\n])\n.controller('NavbarController', NavbarController)\n.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/index.js\n **/","import './templates';\nimport SpeachModuleRoute from './speech.route';\nimport SpeachModuleController from './speech.controller';\nimport SpeachFactory from './speech.service';\n\n/* @ngInject */\nexport default angular.module('app.speech', [])\n.config(SpeachModuleRoute)\n.controller('SpeachModuleController', SpeachModuleController)\n.factory('SpeachFactory', SpeachFactory)\n.name;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/speech/index.js\n **/","import '../../../../assets/media/images/logo.png';\n\nimport './speech.tpl.jade';\nimport './speech.src.tpl.jade';\nimport './speech.src.random.tpl.jade';\nimport './speech.src.custom.tpl.jade';\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/speech/templates/index.js\n **/","module.exports = __webpack_public_path__ + \"static/png/logo.png\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/assets/media/images/logo.png\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"speech.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/speech/templates/speech.tpl.jade\n ** module id = 16\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"speech.src.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/speech/templates/speech.src.tpl.jade\n ** module id = 17\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"speech.src.random.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/speech/templates/speech.src.random.tpl.jade\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"speech.src.custom.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/speech/templates/speech.src.custom.tpl.jade\n ** module id = 19\n ** module chunks = 0\n **/","import '../header.tpl.jade';\nimport '../sidebar.tpl.jade';\n\nimport './templates/speech.tpl.jade';\nimport './templates/speech.src.tpl.jade';\nimport SpeachModuleController from './speech.controller';\n\nexport default function($stateProvider) {\n    'ngInject';\n\n    $stateProvider\n    .state('speech', {\n        url: '/',\n        views: {\n            '': {\n                templateUrl: 'speech.tpl.jade',\n                controller: 'SpeachModuleController',\n                controllerAs: 'ctrl'\n            },\n            'header@speech': {\n                templateUrl: 'header.tpl.jade',\n                controller: 'NavbarController',\n                controllerAs: 'ctrl'\n            },\n            'source@speech': {\n                templateUrl: 'speech.src.tpl.jade'\n            }\n        }\n    })\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/speech/speech.route.js\n **/","module.exports = __webpack_public_path__ + \"header.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/header.tpl.jade\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"sidebar.tpl.jade\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/app/modules/sidebar.tpl.jade\n ** module id = 22\n ** module chunks = 0\n **/","import textConfig from '../../configs/text.config';\n\nclass SpeachModuleController {\n    /* @ngInject */\n    constructor($scope, SpeachFactory) {\n\n        this.$scope = $scope;\n        this.text = textConfig;\n        this.SpeachFactory = SpeachFactory;\n        this.helper = false;\n        this.explanation = false;\n        this.WatsonSpeech = require('WatsonSpeech');\n        this.loadingResults = false;\n        this.source = 'random';\n\n        this.phrases = [];\n        this.activePhraseIndex = null;\n\n        this.recognizing = false;\n        this.listening = false;\n\n        this.hasResults = false;\n        this.userResult = '';\n        this.userResultDiffs = {};\n\n        this.speechDefined = true;\n    }\n\n\n\n    listen() {\n        let audio = this.WatsonSpeech.TextToSpeech.synthesize({\n            text: this.userSource,\n            token: this.SpeachFactory.tokenTTS\n        });\n\n        this.listening = true;\n        audio.addEventListener('ended', ()=>{\n             this.listening = false;\n             this.$scope.$apply();\n         });\n\n\n    }\n\n    get sourceTemplate() {\n        return `speech.src.${this.source}.tpl.jade`;\n    }\n\n    setFirstRule() {\n        this.selectedRule = this.SpeachFactory.rules[0];\n        this.changeRule();\n    }\n\n    get rules() {\n        return this.SpeachFactory.rules;\n    }\n\n    get ruleTypes() {\n        return this.SpeachFactory.ruleTypes;\n    }\n\n    get ruleExample() {\n        return _.find(this.SpeachFactory.rulesExamples, (example) => {\n            return example.RuleId === this.selectedRule.Id;\n        }).ShortExample;\n    }\n\n    changeRule() {\n        this.cleanResults();\n        if(this.selectedRule){\n            this.phrases = [];\n            this.getNewPhrase();\n        }\n    }\n\n    getNewPhrase() {\n        let ctrl = this;\n        this.SpeachFactory.getNewPhrase(this.selectedRule.Id).then((phrase) => {\n            ctrl.phrases.push(phrase);\n            ctrl.activePhraseIndex = ctrl.phrases.length - 1;\n        });\n    }\n\n    cleanResults() {\n        this.userResult = '';\n        this.hasResults = false;\n    }\n\n    goBack() {\n        if (this.activePhraseIndex > 0) {\n            this.activePhraseIndex = --this.activePhraseIndex;\n        }\n        this.cleanResults();\n    }\n\n    goForward() {\n        if (this.activePhraseIndex < this.phrases.length - 1) {\n            this.activePhraseIndex = ++this.activePhraseIndex;\n        } else {\n            this.getNewPhrase();\n        }\n        this.cleanResults();\n    }\n\n    get disabledBack() {\n        return !this.selectedRule || this.activePhraseIndex < 1;\n    }\n\n    sourceType(type) {\n        this.source = type;\n        this.cleanResults();\n    }\n\n    isActiveSource(source) {\n        return this.source === source;\n    }\n\n    get userSource() {\n        return (this.isActiveSource('random') && this.phrases.length) ? this.phrases[this.activePhraseIndex].Phrase : this.userSentence;\n    }\n\n    setResult(data) {\n        if (data && typeof data === 'string'){\n            this.hasResults = true;\n            this.userResult = data;\n        } else {\n            this.hasResults = false;\n        }\n        this.recognizing = false;\n        this.loadingResults = false;\n        this.$scope.$apply();\n    }\n\n    startButton() {\n        this.cleanResults();\n        if (this.recognizing) {\n            this.recognizing = false;\n            this.loadingResults = true;\n            return;\n        }\n        this.recognizing = true;\n        this.WatsonSpeech.SpeechToText.recognizeMicrophone({\n            token: this.SpeachFactory.tokenSTT,\n            continuous: false,\n            keepMicrophone: navigator.userAgent.indexOf('Firefox') > 0\n        })\n        .promise()\n        .then(this.setResult.bind(this))\n        .catch(function() { console.log('error')});\n    }\n\n    toggleHelper() {\n        this.helper = !this.helper;\n    }\n\n    toggleExplanation() {\n        this.explanation = !this.explanation;\n    }\n\n    isHappy() {\n        return this.userResultDiffs.percentage >= 96;\n    }\n\n    isIndifferent() {\n        return this.userResultDiffs.percentage > 76 && this.userResultDiffs.percentage < 95;\n    }\n\n    isSad() {\n        return this.userResultDiffs.percentage <= 75;\n    }\n\n};\n\nexport default SpeachModuleController;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/speech/speech.controller.js\n **/","/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * IBM Watson Speech JavaScript SDK\n *\n * Top-level module includes the version, a [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) pollyfill, and both of the speech libraries.\n *\n * If using a bundler such as browserify, you may optionally include sub-modules directly to reduce the size of the final bundle\n *\n * @module watson-speech\n */\n\n/**\n * Release version\n *\n * envify automatically rewrites this during the release process\n */\nexports.version = process.env.TRAVIS_BRANCH;\n\n/**\n *\n * @see module:watson-speech/speech-to-text\n */\nexports.SpeechToText = require('./speech-to-text');\n\n/**\n *\n * @see module:watson-speech/text-to-speech\n */\nexports.TextToSpeech = require('./text-to-speech');\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/watson-speech/index.js\n ** module id = 24\n ** module chunks = 0 1\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 25\n ** module chunks = 0 1\n **/","'use strict';\n\n/**\n * IBM Watson Speech to Text JavaScript SDK\n *\n * The primary methods for interacting with the Speech to Text JS SDK are:\n *  * `recognizeMicrophone()` for live microphone input\n *  * `recognizeElement()` for transcribing `<audio>` and `<video>` elements\n *  * `recognizeFile()` for file `<input>`'s and other data sources\n *\n * However, the underlying streams and utils that they use are also provided for advanced usage.\n *\n * @module watson-speech/speech-to-text\n */\n\nmodule.exports = {\n\n  // \"easy-mode\" API\n  /**\n   * @see module:watson-speech/speech-to-text/recognize-microphone\n   */\n  recognizeMicrophone: require('./recognize-microphone'),\n\n  /**\n   * @see module:watson-speech/speech-to-text/recognize-blob\n   */\n  recognizeFile: require('./recognize-file'),\n\n  /**\n   * @see module:watson-speech/speech-to-text/get-models\n   */\n  getModels: require('./get-models'),\n\n\n  // individual components to build more customized solutions\n  /**\n   * @see WebAudioL16Stream\n   */\n  WebAudioL16Stream: require('./webaudio-l16-stream'),\n\n  /**\n   * @see RecognizeStream\n   */\n  RecognizeStream: require('./recognize-stream'),\n\n  /**\n   * @see FilePlayer\n   */\n  FilePlayer: require('./file-player'),\n\n  /**\n   * @see FormatStream\n   */\n  FormatStream: require('./format-stream'),\n\n  /**\n   * @see TimingStream\n   */\n  TimingStream: require('./timing-stream'),\n\n  /**\n   * @see WritableElementStream\n   */\n  WritableElementStream: require('./writable-element-stream'),\n\n  // external components exposed for convenience\n\n  /**\n   * @see https://www.npmjs.com/package/get-user-media-promise\n   */\n  getUserMedia: require('get-user-media-promise'),\n\n  /**\n   * @see https://www.npmjs.com/package/microphone-stream\n   */\n  MicrophoneStream: require('microphone-stream'),\n\n  /**\n   * @see https://nodejs.org/api/buffer.html\n   */\n  Buffer: Buffer\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/watson-speech/speech-to-text/index.js\n ** module id = 26\n ** module chunks = 0 1\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 27\n ** module chunks = 0 1\n **/","/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\nvar getUserMedia = require('get-user-media-promise');\nvar MicrophoneStream = require('microphone-stream');\nvar RecognizeStream = require('./recognize-stream.js');\nvar L16 = require('./webaudio-l16-stream.js');\nvar FormatStream = require('./format-stream.js');\nvar assign = require('object.assign/polyfill')();\nvar WritableElementStream = require('./writable-element-stream');\nvar Writable = require('stream').Writable;\n\nvar preservedMicStream;\nvar bitBucket = new Writable({\n  write: function(chunk, encoding, callback) {\n    // when the keepMicrophone option is enabled, unused audio data is sent here so that it isn't buffered by other streams.\n    callback();\n  },\n  objectMode: true, // can still accept strings/buffers\n  decodeStrings: false\n});\n\n/**\n * @module watson-speech/speech-to-text/recognize-microphone\n */\n\n/**\n * Create and return a RecognizeStream sourcing audio from the user's microphone\n *\n * @param {Object} options - Also passed to {RecognizeStream}, and {FormatStream} when applicable\n * @param {String} options.token - Auth Token - see https://github.com/watson-developer-cloud/node-sdk#authorization\n * @param {Boolean} [options.format=true] - pipe the text through a {FormatStream} which performs light formatting. Also controls smart_formatting option unless explicitly set.\n * @param {Boolean} [options.keepMicrophone=false] - keeps an internal reference to the microphone stream to reuse in subsequent calls (prevents multiple permissions dialogs in firefox)\n * @param {String|DOMElement} [options.outputElement] pipe the text to a WriteableElementStream targeting the specified element. Also defaults objectMode to true to enable interim results.\n *\n * @returns {RecognizeStream|FormatStream}\n */\nmodule.exports = function recognizeMicrophone(options) {\n  if (!options || !options.token) {\n    throw new Error('WatsonSpeechToText: missing required parameter: opts.token');\n  }\n\n  // the WritableElementStream works best in objectMode\n  if (options.outputElement && options.objectMode !== false) {\n    options.objectMode = true;\n  }\n\n  // default format to true (capitals and periods)\n  // default smart_formatting to options.format value (dates, currency, etc.)\n  options.format = (options.format !== false);\n  if (typeof options.smart_formatting === 'undefined') {\n    options.smart_formatting = options.format;\n  }\n\n  // we don't want the readable stream to have objectMode on the input even if we're setting it for the output\n  var rsOpts = assign({}, options);\n  rsOpts.readableObjectMode = options.objectMode;\n  rsOpts['content-type'] = 'audio/l16;rate=16000';\n  delete rsOpts.objectMode;\n\n  var recognizeStream = new RecognizeStream(rsOpts);\n\n  var keepMic = options.keepMicrophone;\n  var getMicStream;\n  if (keepMic && preservedMicStream) {\n    preservedMicStream.unpipe(bitBucket);\n    getMicStream = Promise.resolve(preservedMicStream);\n  } else {\n    getMicStream = getUserMedia({video: false, audio: true}).then(function(mic) {\n      var micStream = new MicrophoneStream(mic, {\n        objectMode: true,\n        bufferSize: options.bufferSize\n      });\n      if (keepMic) {\n        preservedMicStream = micStream;\n      }\n      return Promise.resolve(micStream);\n    });\n  }\n\n  // set up the output first so that we have a place to emit errors\n  // if there's trouble with the input stream\n  var stream = recognizeStream;\n  if (options.format) {\n    stream = stream.pipe(new FormatStream(options));\n    stream.stop = recognizeStream.stop.bind(recognizeStream);\n  }\n\n  if (options.outputElement) {\n    stream.pipe(new WritableElementStream(options));\n  }\n\n  getMicStream.catch(function(err) {\n    stream.emit('error', err);\n  });\n\n  getMicStream.then(function(micStream) {\n    var l16Stream = new L16({writableObjectMode: true});\n\n    micStream\n      .pipe(l16Stream)\n      .pipe(recognizeStream);\n\n    /**\n     * unpipes the mic stream to prevent any more audio from being sent over the wire\n     * temporarily re-pipes it to the bitBucket (basically /dev/null)  becuse\n     * otherwise it will buffer the audio from in between calls and prepend it to the next one\n     *\n     * @private\n     */\n    function end() {\n      micStream.unpipe(l16Stream);\n      micStream.pipe(bitBucket);\n      l16Stream.end();\n    }\n    // trigger on both stop and end events:\n    // stop will not fire when a stream ends due to a timeout or having continuous: false\n    // but when stop does fire, we want to honor it immediately\n    // end will always fire, but it may take a few moments after stop\n    if (keepMic) {\n      recognizeStream.on('end', end);\n      recognizeStream.on('stop', end);\n    } else {\n      recognizeStream.on('end', micStream.stop.bind(micStream));\n      recognizeStream.on('stop', micStream.stop.bind(micStream));\n    }\n\n  }).catch(recognizeStream.emit.bind(recognizeStream, 'error'));\n\n\n  return stream;\n};\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/watson-speech/speech-to-text/recognize-microphone.js\n ** module id = 31\n ** module chunks = 0 1\n **/","// loosely based on example code at https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n(function (root) {\n  'use strict';\n\n  /**\n   * Error thrown when any required feature is missing (Promises, navigator, getUserMedia)\n   * @constructor\n   */\n  function NotSupportedError() {\n    this.name = 'NotSupportedError';\n    this.message = 'getUserMedia is not implemented in this browser';\n  }\n  NotSupportedError.prototype = Error.prototype;\n\n  /**\n   * Fake Promise instance that behaves like a Promise except that it always rejects with a NotSupportedError.\n   * Used for situations where there is no global Promise constructor.\n   *\n   * The message will report that the getUserMedia API is not available.\n   * This is technically true because every browser that supports getUserMedia also supports promises.\n   **\n   * @see http://caniuse.com/#feat=stream\n   * @see http://caniuse.com/#feat=promises\n   * @constructor\n   */\n  function FakePromise() {\n    // make it chainable like a real promise\n    this.then = function() {\n      return this;\n    };\n\n    // but always reject with an error\n    var err = new NotSupportedError();\n    this.catch = function(cb) {\n      setTimeout(function () {\n        cb(err);\n      });\n    }\n  }\n\n  /**\n   * Wrapper for navigator.mediaDevices.getUserMedia.\n   * Always returns a Promise or Promise-like object, even in environments without a global Promise constructor\n   *\n   * @stream https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n   *\n   * @param {Object} constraints - must include one or both of audio/video along with optional details for video\n   * @param {Boolean} [constraints.audio] - include audio data in the stream\n   * @param {Boolean|Object} [constraints.video] - include video data in the stream. May be a boolean or an object with additional constraints, see\n   * @returns {Promise<MediaStream>} a promise that resolves to a MediaStream object\n     */\n  function getUserMedia(constraints) {\n    // ensure that Promises are supported and we have a navigator object\n    if (typeof Promise === 'undefined') {\n      return new FakePromise();\n    }\n\n    // Try the more modern, promise-based MediaDevices API first\n    //https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      return navigator.mediaDevices.getUserMedia(constraints);\n    }\n\n    // fall back to the older method second, wrap it in a promise.\n    return new Promise(function(resolve, reject) {\n      // if navigator doesn't exist, then we can't use the getUserMedia API. (And probably aren't even in a browser.)\n      // assuming it does, try getUserMedia and then all of the prefixed versions\n      var gum = navigator && navigator.getUserMedia || navigator.webkitGetUserMedia ||  navigator.mozGetUserMedia || navigator.msGetUserMedia;\n      if (!gum) {\n        return reject(new NotSupportedError())\n      }\n      gum.call(navigator, constraints, resolve, reject);\n    });\n  }\n\n  getUserMedia.NotSupportedError = NotSupportedError;\n\n  // UMD, loosely based on https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return getUserMedia;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = getUserMedia;\n  } else {\n    // Browser globals\n    // pollyfill the MediaDevices API if it does not exist.\n    root.nagivator.mediaDevices = root.navigator.mediaDevices || {};\n    root.nagivator.mediaDevices.getUserMedia = root.nagivator.mediaDevices.getUserMedia || getUserMedia;\n  }\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/get-user-media-promise/lib/get-user-media-promise.js\n ** module id = 32\n ** module chunks = 0 1\n **/","'use strict';\nvar Readable = require('stream').Readable;\nvar util = require('util');\n\n/**\n * Turns a MediaStream object (from getUserMedia) into a Node.js Readable stream and optionally converts the audio to Buffers\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia\n *\n * @param {MediaStream} stream https://developer.mozilla.org/en-US/docs/Web/API/MediaStream\n * @param {Object} [opts] options\n * @param {Boolean} [opts.objectMode=false] Puts the stream into ObjectMode where it emits AudioBuffers instead of Buffers - see https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer\n * @param {Number|null} [opts.bufferSize=null] https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n * @constructor\n */\nfunction MicrophoneStream(stream, opts) {\n  // \"It is recommended for authors to not specify this buffer size and allow the implementation to pick a good\n  // buffer size to balance between latency and audio quality.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor\n  // however, webkitAudioContext (safari) requires it to be set'\n  // Possible values: null, 256, 512, 1024, 2048, 4096, 8192, 16384\n  var bufferSize = (typeof window.AudioContext === 'undefined' ? 4096 : null);\n  opts = opts || {};\n\n  bufferSize = opts.bufferSize || bufferSize;\n\n  // We can only emit one channel's worth of audio, so only one input. (Who has multiple microphones anyways?)\n  var inputChannels = 1;\n\n  // we shouldn't need any output channels (going back to the browser), but chrome is buggy and won't give us any audio without one\n  var outputChannels = 1;\n\n  Readable.call(this, opts);\n\n  var self = this;\n  var recording = true;\n\n  /**\n   * Convert and emit the raw audio data\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode/onaudioprocess\n   * @param {AudioProcessingEvent} e https://developer.mozilla.org/en-US/docs/Web/API/AudioProcessingEvent\n   */\n  function recorderProcess(e) {\n    // onaudioprocess can be called at least once after we've stopped\n    if (recording) {\n      self.push(opts.objectMode ? e.inputBuffer : new Buffer(e.inputBuffer.getChannelData(0)));\n    }\n  }\n\n  var AudioContext = window.AudioContext || window.webkitAudioContext;\n  var context = new AudioContext();\n  var audioInput = context.createMediaStreamSource(stream);\n  var recorder = context.createScriptProcessor(bufferSize, inputChannels, outputChannels);\n\n  recorder.onaudioprocess = recorderProcess;\n\n  audioInput.connect(recorder);\n\n  // other half of workaround for chrome bugs\n  recorder.connect(context.destination);\n\n  this.stop = function() {\n    if (context.state === 'closed') {\n      return;\n    }\n    try {\n      stream.getTracks()[0].stop();\n    } catch (ex) {\n      // This fails in some older versions of chrome. Nothing we can do about it.\n    }\n    recorder.disconnect();\n    audioInput.disconnect();\n    try {\n      context.close(); // returns a promise;\n    } catch (ex) {\n      // this can also fail in older versions of chrome\n    }\n    recording = false;\n    self.push(null);\n    self.emit('close');\n  };\n\n  process.nextTick(function() {\n    self.emit('format', {\n      channels: 1,\n      bitDepth: 32,\n      sampleRate: context.sampleRate,\n      signed: true,\n      float: true\n    });\n  });\n}\nutil.inherits(MicrophoneStream, Readable);\n\nMicrophoneStream.prototype._read = function(/* bytes */) {\n  // no-op, (flow-control doesn't really work on sound)\n};\n\n/**\n * Converts a Buffer back into the raw Float32Array format that browsers use.\n * Note: this is just a new DataView for the same underlying buffer -\n * the actual audio data is not copied or changed here.\n *\n * @param {Buffer} chunk node-style buffer of audio data from a 'data' event or read() call\n * @return {Float32Array} raw 32-bit float data view of audio data\n */\nMicrophoneStream.toRaw = function toFloat32(chunk) {\n  return new Float32Array(chunk.buffer);\n};\n\nmodule.exports = MicrophoneStream;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/microphone-stream/microphone-stream.js\n ** module id = 33\n ** module chunks = 0 1\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stream-browserify/index.js\n ** module id = 34\n ** module chunks = 0 1\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 35\n ** module chunks = 0 1\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 36\n ** module chunks = 0 1\n **/","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\nif (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/readable.js\n ** module id = 37\n ** module chunks = 0 1\n **/","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar hasPrependListener = typeof EE.prototype.prependListener === 'function';\n\nfunction prependListener(emitter, event, fn) {\n  if (hasPrependListener) return emitter.prependListener(event, fn);\n\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS. This is here\n  // only because this code needs to continue to work with older versions\n  // of Node.js that do not include the prependListener() method. The goal\n  // is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nvar Duplex;\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nvar Duplex;\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = bufferShim.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended) return 0;\n\n  if (state.objectMode) return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\n  }\n\n  if (n <= 0) return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended) state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && !this._readableState.endEmitted) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0) return null;\n\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var _buf = list[0];\n        var cpy = Math.min(n - c, _buf.length);\n\n        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);\n\n        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/lib/_stream_readable.js\n ** module id = 38\n ** module chunks = 0 1\n **/","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process-nextick-args/index.js\n ** module id = 39\n ** module chunks = 0 1\n **/","'use strict';\n\nvar buffer = require('buffer');\nvar Buffer = buffer.Buffer;\nvar SlowBuffer = buffer.SlowBuffer;\nvar MAX_LEN = buffer.kMaxLength || 2147483647;\nexports.alloc = function alloc(size, fill, encoding) {\n  if (typeof Buffer.alloc === 'function') {\n    return Buffer.alloc(size, fill, encoding);\n  }\n  if (typeof encoding === 'number') {\n    throw new TypeError('encoding must not be number');\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  var enc = encoding;\n  var _fill = fill;\n  if (_fill === undefined) {\n    enc = undefined;\n    _fill = 0;\n  }\n  var buf = new Buffer(size);\n  if (typeof _fill === 'string') {\n    var fillBuf = new Buffer(_fill, enc);\n    var flen = fillBuf.length;\n    var i = -1;\n    while (++i < size) {\n      buf[i] = fillBuf[i % flen];\n    }\n  } else {\n    buf.fill(_fill);\n  }\n  return buf;\n}\nexports.allocUnsafe = function allocUnsafe(size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    return Buffer.allocUnsafe(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size > MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new Buffer(size);\n}\nexports.from = function from(value, encodingOrOffset, length) {\n  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {\n    return Buffer.from(value, encodingOrOffset, length);\n  }\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n  if (typeof value === 'string') {\n    return new Buffer(value, encodingOrOffset);\n  }\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    var offset = encodingOrOffset;\n    if (arguments.length === 1) {\n      return new Buffer(value);\n    }\n    if (typeof offset === 'undefined') {\n      offset = 0;\n    }\n    var len = length;\n    if (typeof len === 'undefined') {\n      len = value.byteLength - offset;\n    }\n    if (offset >= value.byteLength) {\n      throw new RangeError('\\'offset\\' is out of bounds');\n    }\n    if (len > value.byteLength - offset) {\n      throw new RangeError('\\'length\\' is out of bounds');\n    }\n    return new Buffer(value.slice(offset, offset + len));\n  }\n  if (Buffer.isBuffer(value)) {\n    var out = new Buffer(value.length);\n    value.copy(out, 0, 0, value.length);\n    return out;\n  }\n  if (value) {\n    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {\n      return new Buffer(value);\n    }\n    if (value.type === 'Buffer' && Array.isArray(value.data)) {\n      return new Buffer(value.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');\n}\nexports.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  if (typeof Buffer.allocUnsafeSlow === 'function') {\n    return Buffer.allocUnsafeSlow(size);\n  }\n  if (typeof size !== 'number') {\n    throw new TypeError('size must be a number');\n  }\n  if (size >= MAX_LEN) {\n    throw new RangeError('size is too large');\n  }\n  return new SlowBuffer(size);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer-shims/index.js\n ** module id = 40\n ** module chunks = 0 1\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-util-is/lib/util.js\n ** module id = 41\n ** module chunks = 0 1\n **/","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/lib/_stream_duplex.js\n ** module id = 43\n ** module chunks = 0 1\n **/","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*<replacement>*/\nvar bufferShim = require('buffer-shims');\n/*</replacement>*/\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n  // Always throw error if a null is written\n  // if we are not in object mode then throw\n  // if it is not a buffer, string, or undefined.\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = bufferShim.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/lib/_stream_writable.js\n ** module id = 44\n ** module chunks = 0 1\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 45\n ** module chunks = 0 1\n **/","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/util-deprecate/browser.js\n ** module id = 46\n ** module chunks = 0 1\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/string_decoder/index.js\n ** module id = 47\n ** module chunks = 0 1\n **/","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('Not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/lib/_stream_transform.js\n ** module id = 48\n ** module chunks = 0 1\n **/","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/lib/_stream_passthrough.js\n ** module id = 49\n ** module chunks = 0 1\n **/","module.exports = require(\"./lib/_stream_writable.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/writable.js\n ** module id = 50\n ** module chunks = 0 1\n **/","module.exports = require(\"./lib/_stream_duplex.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/duplex.js\n ** module id = 51\n ** module chunks = 0 1\n **/","module.exports = require(\"./lib/_stream_transform.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/transform.js\n ** module id = 52\n ** module chunks = 0 1\n **/","module.exports = require(\"./lib/_stream_passthrough.js\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/readable-stream/passthrough.js\n ** module id = 53\n ** module chunks = 0 1\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/util/util.js\n ** module id = 54\n ** module chunks = 0 1\n **/","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/util/support/isBufferBrowser.js\n ** module id = 55\n ** module chunks = 0 1\n **/","/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n\nvar Duplex = require('stream').Duplex;\nvar util = require('util');\nvar pick = require('object.pick');\nvar W3CWebSocket = require('websocket').w3cwebsocket;\nvar contentType = require('./content-type');\nvar defaults = require('defaults');\nvar qs = require('../util/querystring.js');\n\nvar OPENING_MESSAGE_PARAMS_ALLOWED = ['continuous', 'max_alternatives', 'timestamps', 'word_confidence', 'inactivity_timeout',\n  'content-type', 'interim_results', 'keywords', 'keywords_threshold', 'word_alternatives_threshold', 'profanity_filter', 'smart_formatting'];\n\nvar QUERY_PARAMS_ALLOWED = ['model', 'watson-token']; // , 'X-Watson-Learning-Opt-Out' - should be allowed but currently isn't due to a service bug\n\n\n/**\n * pipe()-able Node.js Readable/Writeable stream - accepts binary audio and emits text/objects in it's `data` events.\n *\n * Uses WebSockets under the hood. For audio with no recognizable speech, no `data` events are emitted.\n *\n * By default, only finalized text is emitted in the data events, however in `readableObjectMode` (usually just `objectMode` when using a helper method).\n *\n *  An interim result looks like this:\n ```js\n { alternatives:\n   [ { timestamps:\n        [ [ 'it', 20.9, 21.04 ],\n          [ 'is', 21.04, 21.17 ],\n          [ 'a', 21.17, 21.25 ],\n          [ 'site', 21.25, 21.56 ],\n          [ 'that', 21.56, 21.7 ],\n          [ 'hardly', 21.7, 22.06 ],\n          [ 'anyone', 22.06, 22.49 ],\n          [ 'can', 22.49, 22.67 ],\n          [ 'behold', 22.67, 23.13 ],\n          [ 'without', 23.13, 23.46 ],\n          [ 'some', 23.46, 23.67 ],\n          [ 'sort', 23.67, 23.91 ],\n          [ 'of', 23.91, 24 ],\n          [ 'unwanted', 24, 24.58 ],\n          [ 'emotion', 24.58, 25.1 ] ],\n       transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotion ' } ],\n  final: false,\n  result_index: 3 }\n ```\n\n While a final result looks like this (some features only appear in final results):\n ```js\n  { alternatives:\n     [ { word_confidence:\n          [ [ 'it', 1 ],\n            [ 'is', 0.956286624429304 ],\n            [ 'a', 0.8105753725270362 ],\n            [ 'site', 1 ],\n            [ 'that', 1 ],\n            [ 'hardly', 1 ],\n            [ 'anyone', 1 ],\n            [ 'can', 1 ],\n            [ 'behold', 0.5273598005406737 ],\n            [ 'without', 1 ],\n            [ 'some', 1 ],\n            [ 'sort', 1 ],\n            [ 'of', 1 ],\n            [ 'unwanted', 1 ],\n            [ 'emotion', 0.49401837076320887 ] ],\n         confidence: 0.881,\n         transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotion ',\n         timestamps:\n          [ [ 'it', 20.9, 21.04 ],\n            [ 'is', 21.04, 21.17 ],\n            [ 'a', 21.17, 21.25 ],\n            [ 'site', 21.25, 21.56 ],\n            [ 'that', 21.56, 21.7 ],\n            [ 'hardly', 21.7, 22.06 ],\n            [ 'anyone', 22.06, 22.49 ],\n            [ 'can', 22.49, 22.67 ],\n            [ 'behold', 22.67, 23.13 ],\n            [ 'without', 23.13, 23.46 ],\n            [ 'some', 23.46, 23.67 ],\n            [ 'sort', 23.67, 23.91 ],\n            [ 'of', 23.91, 24 ],\n            [ 'unwanted', 24, 24.58 ],\n            [ 'emotion', 24.58, 25.1 ] ] },\n       { transcript: 'it is a sight that hardly anyone can behold without some sort of unwanted emotion ' },\n       { transcript: 'it is a site that hardly anyone can behold without some sort of unwanted emotions ' } ],\n    final: true,\n    result_index: 3 }\n ```\n\n *\n * @param {Object} options\n * @param {String} [options.model='en-US_BroadbandModel'] - voice model to use. Microphone streaming only supports broadband models.\n * @param {String} [options.url='wss://stream.watsonplatform.net/speech-to-text/api'] base URL for service\n * @param {String} [options.content-type='audio/wav'] - content type of audio; can be automatically determined from file header in most cases. only wav, flac, and ogg/opus are supported\n * @param {Boolean} [options.interim_results=true] - Send back non-final previews of each \"sentence\" as it is being processed. These results are ignored in text mode.\n * @param {Boolean} [options.continuous=true] - set to false to automatically stop the transcription after the first \"sentence\"\n * @param {Boolean} [options.word_confidence=false] - include confidence scores with results. Defaults to true when in objectMode.\n * @param {Boolean} [options.timestamps=false] - include timestamps with results. Defaults to true when in objectMode.\n * @param {Number} [options.max_alternatives=1] - maximum number of alternative transcriptions to include. Defaults to 3 when in objectMode.\n * @param {Array<String>} [options.keywords] - a list of keywords to search for in the audio\n * @param {Number} [options.keywords_threshold] - Number between 0 and 1 representing the minimum confidence before including a keyword in the results. Required when options.keywords is set\n * @param {Number} [options.word_alternatives_threshold] - Number between 0 and 1 representing the minimum confidence before including an alternative word in the results. Must be set to enable word alternatives,\n * @param {Boolean} [options.profanity_filter=false] - set to true to filter out profanity and replace the words with *'s\n * @param {Number} [options.inactivity_timeout=30] - how many seconds of silence before automatically closing the stream (even if continuous is true). use -1 for infinity\n * @param {Boolean} [options.readableObjectMode=false] - emit `result` objects instead of string Buffers for the `data` events. Changes several other defaults.\n * @param {Number} [options.X-WDC-PL-OPT-OUT=0] - set to 1 to opt-out of allowing Watson to use this request to improve it's services\n * @param {Boolean} [options.smart_formatting=false] - formats numeric values such as dates, times, currency, etc.\n *\n * @constructor\n */\nfunction RecognizeStream(options) {\n  Duplex.call(this, options);\n  this.options = options;\n  this.listening = false;\n  this.initialized = false;\n  this.finished = false;\n  var self = this;\n\n  /**\n   * listening for `results` events should put the stream in flowing mode just like `data` events\n   *\n   * @param {String} event\n   */\n  function flowForResults(event) {\n    if (event === 'results' || event === 'result') {\n      self.removeListener('newListener', flowForResults);\n      process.nextTick(function() {\n        self.on('data', function() {\n        }); // todo: is there a better way to put a stream in flowing mode?\n      });\n      if (!options.silent) {\n        // todo: move this to the node.js wrapper\n        // eslint-disable-next-line no-console\n        console.log(new Error('Watson Speech to Text RecognizeStream: the ' + event + ' event is deprecated and will be removed from a future release. ' +\n          'Please set {objectMode: true} and listen for the data event instead. ' +\n          'Pass {silent: true} to disable this message.'));\n      }\n    }\n  }\n  this.on('newListener', flowForResults);\n}\nutil.inherits(RecognizeStream, Duplex);\n\n\nRecognizeStream.prototype.initialize = function() {\n  var options = this.options;\n\n  // todo: apply these corrections to other methods (?)\n  if (options.token && !options['watson-token']) {\n    options['watson-token'] = options.token;\n  }\n  if (options.content_type && !options['content-type']) {\n    options['content-type'] = options.content_type;\n  }\n  if (options['X-WDC-PL-OPT-OUT'] && !options['X-Watson-Learning-Opt-Out']) {\n    options['X-Watson-Learning-Opt-Out'] = options['X-WDC-PL-OPT-OUT'];\n  }\n\n  var queryParams = util._extend({model: 'en-US_BroadbandModel'}, pick(options, QUERY_PARAMS_ALLOWED));\n  var queryString = qs.stringify(queryParams);\n  var url = (options.url || 'wss://stream.watsonplatform.net/speech-to-text/api').replace(/^http/, 'ws') + '/v1/recognize?' + queryString;\n\n  // turn off all the extras if we're just outputting text\n  var textModeDefaults = {\n    action: 'start',\n    'content-type': 'audio/wav',\n    continuous: true,\n    inactivity_timeout: 30,\n    interim_results: true,\n    word_confidence: false,\n    timestamps: false,\n    max_alternatives: 1\n  };\n\n  // but turn everything on if we're in objectMode and the end user can consume it\n  var objectModeDefaults = {\n    action: 'start',\n    'content-type': 'audio/wav',\n    continuous: true,\n    inactivity_timeout: 30,\n    interim_results: true,\n    word_confidence: false,\n    timestamps: false,\n    max_alternatives: 1\n  };\n\n  var openingMessage = defaults(\n    pick(options, OPENING_MESSAGE_PARAMS_ALLOWED),\n    (options.objectMode || options.readableObjectMode) ? objectModeDefaults : textModeDefaults\n  );\n\n  var self = this;\n\n  // node params: requestUrl, protocols, origin, headers, extraRequestOptions\n  // browser params: requestUrl, protocols (all others ignored)\n  var socket = this.socket = new W3CWebSocket(url, null, null, options.headers, null);\n\n  // when the input stops, let the service know that we're done\n  self.on('finish', self.finish.bind(self));\n\n  socket.onerror = function(error) {\n    self.listening = false;\n    self.emit('error', error);\n  };\n\n\n  this.socket.onopen = function() {\n    self.sendJSON(openingMessage);\n    self.emit('connect');\n  };\n\n  this.socket.onclose = function(e) {\n    if (self.listening) {\n      self.listening = false;\n      self.push(null);\n    }\n    /**\n     * @event RecognizeStream#close\n     * @param {Number} reasonCode\n     * @param {String} description\n     */\n    self.emit('close', e.code, e.reason);\n    /**\n     * @event RecognizeStream#connection-close\n     * @param {Number} reasonCode\n     * @param {String} description\n     * @deprecated\n     */\n    self.emit('connection-close', e.code, e.reason);\n  };\n\n  /**\n   * @event RecognizeStream#error\n   * @param {String} msg custom error message\n   * @param {*} [frame] unprocessed frame (should have a .data property with either string or binary data)\n   * @param {Error} [err]\n   */\n  function emitError(msg, frame, err) {\n    if (err) {\n      err.message = msg + ' ' + err.message;\n    } else {\n      err = new Error(msg);\n    }\n    err.raw = frame;\n    self.emit('error', err);\n  }\n\n  socket.onmessage = function(frame) {\n    if (typeof frame.data !== 'string') {\n      return emitError('Unexpected binary data received from server', frame);\n    }\n\n    var data;\n    try {\n      data = JSON.parse(frame.data);\n    } catch (jsonEx) {\n      return emitError('Invalid JSON received from service:', frame, jsonEx);\n    }\n\n    /**\n     * @event RecognizeStream#receive-json\n     * @param {Object} msg - the raw JSON received from Watson - sometimes useful for debugging\n     */\n    self.emit('receive-json', data);\n\n    if (data.error) {\n      emitError(data.error, frame);\n    } else if (data.state === 'listening') {\n      // this is emitted both when the server is ready for audio, and after we send the close message to indicate that it's done processing\n      if (self.listening) {\n        self.listening = false;\n        self.push(null);\n        socket.close();\n      } else {\n        self.listening = true;\n        self.emit('listening');\n      }\n    } else if (data.results) {\n      /**\n       * Object with array of interim or final results, possibly including confidence scores, alternatives, and word timing. May have no results at all for empty audio files.\n       * @event RecognizeStream#results\n       * @param {Object} results\n       * @deprecated - use objectMode and listen for the 'data' event instead\n       */\n      self.emit('results', data.results);\n\n      // note: currently there is always either 0 or 1 entries in the results array. However, this may change in the future.\n      data.results.forEach(function(result) {\n        result.index = data.result_index;\n        /**\n         * Object with interim or final results, possibly including confidence scores, alternatives, and word timing.\n         * @event RecognizeStream#results\n         * @param {Object} results\n         * @deprecated - use objectMode and listen for the 'data' event instead\n         */\n        self.emit('result', result);\n        if (options.objectMode || options.readableObjectMode) {\n          /**\n           * Object with interim or final results, possibly including confidence scores, alternatives, and word timing.\n           * @event RecognizeStream#data\n           * @param {Object} data\n           */\n          self.push(result);\n        } else if (result.final && result.alternatives) {\n          /**\n           * Finalized text\n           * @event RecognizeStream#data\n           * @param {String} transcript\n           */\n          self.push(result.alternatives[0].transcript, 'utf8');\n        }\n      });\n    } else {\n      emitError('Unrecognised message from server', frame);\n    }\n  };\n\n  this.initialized = true;\n};\n\nRecognizeStream.prototype.sendJSON = function sendJSON(msg) {\n  /**\n   * @event RecognizeStream#send-json\n   * @param {Object} msg - the raw JSON sent to Watson - sometimes useful for debugging\n   */\n  this.emit('send-json', msg);\n  return this.socket.send(JSON.stringify(msg));\n};\n\nRecognizeStream.prototype.sendData = function sendData(data) {\n  this.emit('send-data', data);\n  return this.socket.send(data);\n};\n\nRecognizeStream.prototype._read = function(/* size*/) {\n  // there's no easy way to control reads from the underlying library\n  // so, the best we can do here is a no-op\n};\n\nRecognizeStream.prototype._write = function(chunk, encoding, callback) {\n  var self = this;\n  if (self.finished) {\n    // can't send any more data after the stop message (although this shouldn't happen normally...)\n    return;\n  }\n  if (self.listening) {\n    self.sendData(chunk);\n    this.afterSend(callback);\n  } else {\n    if (!this.initialized) {\n      if (!this.options['content-type']) {\n        this.options['content-type'] = RecognizeStream.getContentType(chunk);\n      }\n      this.initialize();\n    }\n    this.once('listening', function() {\n      self.sendData(chunk);\n      self.afterSend(callback);\n    });\n  }\n};\n\n// flow control - don't ask for more data until we've finished what we have\n// todo: see if this can be improved\nRecognizeStream.prototype.afterSend = function afterSend(next) {\n  if (this.socket.bufferedAmount <= this._writableState.highWaterMark || 0) {\n    next(); // eslint-disable-line callback-return\n  } else {\n    setTimeout(this.afterSend.bind(this, next), 10);\n  }\n};\n\nRecognizeStream.prototype.stop = function() {\n  this.emit('stop');\n  this.finish();\n};\n\nRecognizeStream.prototype.finish = function finish() {\n  // this is called both when the source stream finishes, and when .stop() is fired, but we only want to send the stop message once.\n  if (this.finished) {\n    return;\n  }\n  this.finished = true;\n  var self = this;\n  var closingMessage = {action: 'stop'};\n  if (self.socket && self.socket.readyState !== self.socket.CLOSED && self.socket.readyState !== self.socket.CLOSING) {\n    self.sendJSON(closingMessage);\n  } else {\n    this.once('connect', function() {\n      self.sendJSON(closingMessage);\n    });\n  }\n};\n\nRecognizeStream.prototype.promise = require('./to-promise');\n\n\nRecognizeStream.getContentType = function(buffer) {\n  return contentType(buffer.slice(0, 4).toString());\n};\n\n\nmodule.exports = RecognizeStream;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/watson-speech/speech-to-text/recognize-stream.js\n ** module id = 56\n ** module chunks = 0 1\n **/","/*!\n * object.pick <https://github.com/jonschlinkert/object.pick>\n *\n * Copyright (c) 2014-2015 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nmodule.exports = function pick(obj, keys) {\n  if (!isObject(obj) && typeof obj !== 'function') {\n    return {};\n  }\n\n  var res = {};\n  if (typeof keys === 'string') {\n    if (keys in obj) {\n      res[keys] = obj[keys];\n    }\n    return res;\n  }\n\n  var len = keys.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var key = keys[idx];\n    if (key in obj) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/object.pick/index.js\n ** module id = 57\n ** module chunks = 0 1\n **/","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar isArray = require('isarray');\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && isArray(val) === false;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isobject/index.js\n ** module id = 58\n ** module chunks = 0 1\n **/","import textConfig from '../configs/text.config';\n\nclass NavbarController {\n    /* @ngInject */\n    constructor() {\n        this.text = textConfig;\n        this.sidebar = false;\n    }\n\n    toggleSidebar() {\n        this.sidebar = !this.sidebar;\n    }\n}\n\n\nexport default NavbarController;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/client/app/modules/header.controller.js\n **/"],"sourceRoot":""}